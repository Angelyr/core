!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.8	//
A	ma/maAffine.h	/^    apf::Matrix3x3 A; $/;"	m	class:ma::Affine
A	test/eigen_test.cc	/^  double A[3][3];$/;"	m	struct:Input	file:
AD	ma/maReposition.cc	/^typedef mth::AD<double, 3> AD;$/;"	t	namespace:ma	file:
AD	mth/mthAD.h	/^    AD():x_(0), dx_() {zero();}$/;"	f	class:mth::AD
AD	mth/mthAD.h	/^    AD():x_(0.) {zero();}$/;"	f	class:mth::AD
AD	mth/mthAD.h	/^    AD(AD<B, 0> const& other) {zero(); copy(other);}$/;"	f	class:mth::AD
AD	mth/mthAD.h	/^    AD(AD<B, N> const& other) {copy(other);}$/;"	f	class:mth::AD
AD	mth/mthAD.h	/^    AD(AD<T, N> const& other) {copy(other);}$/;"	f	class:mth::AD
AD	mth/mthAD.h	/^    AD(double val):x_(val), dx_() {zero();}$/;"	f	class:mth::AD
AD	mth/mthAD.h	/^    AD(double x):x_(x) {zero();}$/;"	f	class:mth::AD
AD	mth/mthAD.h	/^class AD$/;"	c	namespace:mth
AD	mth/mthAD.h	/^class AD<T,0>$/;"	c	namespace:mth
AD	test/test_AD.cc	/^typedef mth::AD<double, 3> AD;$/;"	t	file:
ADAPT_REPART	zoltan/apfZoltan.h	/^  ADAPT_REPART,$/;"	e	enum:apf::ZoltanApproach
ADVec	ma/maReposition.cc	/^typedef mth::Vector<AD, 3> ADVec;$/;"	t	namespace:ma	file:
AGM_BDRY_TYPES	gmi/agm.h	/^  AGM_BDRY_TYPES$/;"	e	enum:agm_bdry_type
AGM_BOUNDARY	gmi/agm.h	/^  AGM_BOUNDARY,$/;"	e	enum:agm_obj_type
AGM_EDGE	gmi/agm.h	/^  AGM_EDGE,$/;"	e	enum:agm_ent_type
AGM_EDGE_USE	gmi/agm.h	/^  AGM_EDGE_USE,$/;"	e	enum:agm_use_type
AGM_ENDPOINTS	gmi/agm.h	/^  AGM_ENDPOINTS,$/;"	e	enum:agm_bdry_type
AGM_ENTITY	gmi/agm.h	/^  AGM_ENTITY,$/;"	e	enum:agm_obj_type
AGM_ENT_TYPES	gmi/agm.h	/^  AGM_ENT_TYPES$/;"	e	enum:agm_ent_type
AGM_FACE	gmi/agm.h	/^  AGM_FACE,$/;"	e	enum:agm_ent_type
AGM_FACE_USE	gmi/agm.h	/^  AGM_FACE_USE,$/;"	e	enum:agm_use_type
AGM_H	gmi/agm.h	12;"	d
AGM_LOOP	gmi/agm.h	/^  AGM_LOOP,$/;"	e	enum:agm_bdry_type
AGM_OBJ_TYPES	gmi/agm.h	/^  AGM_OBJ_TYPES$/;"	e	enum:agm_obj_type
AGM_REGION	gmi/agm.h	/^  AGM_REGION,$/;"	e	enum:agm_ent_type
AGM_SHELL	gmi/agm.h	/^  AGM_SHELL,$/;"	e	enum:agm_bdry_type
AGM_USE	gmi/agm.h	/^  AGM_USE,$/;"	e	enum:agm_obj_type
AGM_USE_TYPES	gmi/agm.h	/^  AGM_USE_TYPES$/;"	e	enum:agm_use_type
AGM_VERTEX	gmi/agm.h	/^  AGM_VERTEX,$/;"	e	enum:agm_ent_type
AGM_VERTEX_USE	gmi/agm.h	/^  AGM_VERTEX_USE,$/;"	e	enum:agm_use_type
APFARRAYDATA_H	apf/apfArrayData.h	9;"	d
APFCAP	apf_cap/apfCAP.h	2;"	d
APFCAVITYOP_H	apf/apfCavityOp.h	9;"	d
APFDYNAMICMATRIX_H	apf/apfDynamicMatrix.h	9;"	d
APFDYNAMICVECTOR_H	apf/apfDynamicVector.h	9;"	d
APFELEMENTOF_H	apf/apfElementOf.h	9;"	d
APFELEMENT_H	apf/apfElement.h	9;"	d
APFFIELDDATA_H	apf/apfFieldData.h	9;"	d
APFFIELDOF_H	apf/apfFieldOf.h	9;"	d
APFFIELD_H	apf/apfField.h	9;"	d
APFINTEGRATE_H	apf/apfIntegrate.h	9;"	d
APFMATRIXELEMENT_H	apf/apfMatrixElement.h	9;"	d
APFMATRIXFIELD_H	apf/apfMatrixField.h	9;"	d
APFMATRIX_H	apf/apfMatrix.h	9;"	d
APFMDS_H	mds/apfMDS.h	12;"	d
APFNUMBERINGCLASS_H	apf/apfNumberingClass.h	9;"	d
APFNUMBERING_H	apf/apfNumbering.h	9;"	d
APFPACKEDFIELD_H	apf/apfPackedField.h	9;"	d
APFSCALARELEMENT_H	apf/apfScalarElement.h	9;"	d
APFSCALARFIELD_H	apf/apfScalarField.h	9;"	d
APFSHAPE_H	apf/apfShape.h	9;"	d
APFSIMDATAOF_H	apf_sim/apfSIMDataOf.h	2;"	d
APFSIM_H	apf_sim/apfSIM.h	2;"	d
APFTAGDATA_H	apf/apfTagData.h	9;"	d
APFVECTORELEMENT_H	apf/apfVectorElement.h	9;"	d
APFVECTORFIELD_H	apf/apfVectorField.h	9;"	d
APFVTK_H	apf/apfVtk.h	9;"	d
APF_2_MTH_H	apf/apf2mth.h	9;"	d
APF_ALBANY_H	stk/apfAlbany.h	9;"	d
APF_ARRAY_H	apf/apfArray.h	9;"	d
APF_BOX_H	mds/apfBox.h	2;"	d
APF_CONST_ITERATE	apf/apf.h	606;"	d
APF_CONVERT_H	apf/apfConvert.h	9;"	d
APF_COORD_DATA_H	apf/apfCoordData.h	9;"	d
APF_DYNAMIC_ARRAY_H	apf/apfDynamicArray.h	9;"	d
APF_FILE_H	apf/apfFile.h	9;"	d
APF_GEOMETRY_H	apf/apfGeometry.h	2;"	d
APF_H	apf/apf.h	9;"	d
APF_ITERATE	apf/apf.h	601;"	d
APF_MESH2_H	apf/apfMesh2.h	9;"	d
APF_MESH_H	apf/apfMesh.h	9;"	d
APF_MIXED_NUMBERING_H	apf/apfMixedNumbering.h	9;"	d
APF_NEW_H	apf/apfNew.h	9;"	d
APF_OMEGA_H_H	omega_h/apfOmega_h.h	2;"	d
APF_PARTITION_H	apf/apfPartition.h	9;"	d
APF_PM_H	mds/apfPM.h	12;"	d
APF_STK_H	stk/apfSTK.h	9;"	d
APF_USER_DATA_H	apf/apfUserData.h	9;"	d
APF_VECTOR_H	apf/apfVector.h	9;"	d
APF_ZOLTAN_CALLBACKS_H	zoltan/apfZoltanCallbacks.h	9;"	d
APF_ZOLTAN_H	zoltan/apfZoltan.h	9;"	d
APF_ZOLTAN_MESH_H	zoltan/apfZoltanMesh.h	9;"	d
Adapt	crv/crvAdapt.cc	/^Adapt::Adapt(ma::Input* in)$/;"	f	class:crv::Adapt
Adapt	crv/crvAdapt.h	/^class Adapt : public ma::Adapt$/;"	c	namespace:crv
Adapt	ma/maAdapt.cc	/^Adapt::Adapt(Input* in)$/;"	f	class:ma::Adapt
Adapt	ma/maAdapt.h	/^class Adapt$/;"	c	namespace:ma
AdaptCallback	phasta/phAdapt.cc	/^  AdaptCallback(apf::Mesh2* m, apf::Field* szfld)$/;"	f	struct:ph::AdaptCallback
AdaptCallback	phasta/phAdapt.cc	/^  AdaptCallback(apf::Mesh2* m, apf::Field* szfld, ph::Input* inp)$/;"	f	struct:ph::AdaptCallback
AdaptCallback	phasta/phAdapt.cc	/^struct AdaptCallback : public Parma_GroupCode$/;"	s	namespace:ph	file:
Adapter	dsp/dspAdapters.h	/^class Adapter {$/;"	c	namespace:dsp
AddOp	apf/apfFieldData.cc	/^    AddOp(FieldDataOf<T>* ld1, FieldDataOf<T>* ld2,$/;"	f	class:apf::AddOp
AddOp	apf/apfFieldData.cc	/^class AddOp : public FieldOp$/;"	c	namespace:apf	file:
AdjPart	parma/diffMC/maximalIndependentSet/mis.h	/^    typedef struct AdjPart {$/;"	s	namespace:misLuby
AdjReorder	apf/apfNumbering.h	/^inline int AdjReorder(Numbering * num) { return adjReorder(num); }$/;"	f	namespace:apf
Adjacency Structures	mds/mds.tex	/^unheard of.$/;"	s
Adjacent	apf/apfMesh.h	/^typedef DynamicArray<MeshEntity*> Adjacent;$/;"	t	namespace:apf
Adjacent	pumi/pumi.h	/^typedef apf::Adjacent Adjacent; \/\/ adjacency container$/;"	t
AdvMeshing_EXPORT	test/generate.cc	34;"	d	file:
Affine	ma/maAffine.h	/^class Affine$/;"	c	namespace:ma
Ai	crv/crvShapeHandler.cc	/^    mth::Matrix<double> Ai[4];$/;"	m	class:crv::BezierTransfer	file:
Algorithm	apf/stitch.tex	/^downward set $(\\downarrow e)^*$.$/;"	s
AllBlocks	phasta/phBlock.h	/^struct AllBlocks$/;"	s	namespace:ph
AllEdgeCollapser	ma/maCoarsen.cc	/^    AllEdgeCollapser(Adapt* a, int md):$/;"	f	class:ma::AllEdgeCollapser
AllEdgeCollapser	ma/maCoarsen.cc	/^class AllEdgeCollapser : public Operator$/;"	c	namespace:ma	file:
AllFieldsData	ma/maExtrude.cc	/^struct AllFieldsData {$/;"	s	namespace:ma::__anon28	file:
AlmostEqualRelativeAndAbs	parma/diffMC/parma_commons.cc	/^inline bool AlmostEqualRelativeAndAbs(double A, double B,$/;"	f
AnIso	test/aniso_ma_test.cc	/^    AnIso(ma::Mesh* m)$/;"	f	class:AnIso
AnIso	test/aniso_ma_test.cc	/^class AnIso : public ma::AnisotropicFunction$/;"	c	file:
AnisoSizeField	ma/maSize.cc	/^  AnisoSizeField()$/;"	f	struct:ma::AnisoSizeField
AnisoSizeField	ma/maSize.cc	/^  AnisoSizeField(Mesh* m, AnisotropicFunction* f):$/;"	f	struct:ma::AnisoSizeField
AnisoSizeField	ma/maSize.cc	/^struct AnisoSizeField : public MetricSizeField$/;"	s	namespace:ma	file:
AnisotropicFunction	ma/maSize.h	/^class AnisotropicFunction$/;"	c	namespace:ma
AnisotropicX	test/refine2x.cc	/^    AnisotropicX(ma::Mesh* mesh, int splitDir) {$/;"	f	class:AnisotropicX
AnisotropicX	test/refine2x.cc	/^class AnisotropicX: public ma::AnisotropicFunction {$/;"	c	file:
Array	apf/apfArray.h	/^class Array : public can::Array<T, N> {$/;"	c	namespace:apf
Array	can/canArray.h	/^    Array() : sz(0), elems(0) {}$/;"	f	class:can::Array
Array	can/canArray.h	/^    Array() {}$/;"	f	class:can::Array
Array	can/canArray.h	/^    Array(Array<T,0> const& other) : sz(0), elems(0) {copy(other);}$/;"	f	class:can::Array
Array	can/canArray.h	/^    Array(Array<T,N> const& other) {copy(other);}$/;"	f	class:can::Array
Array	can/canArray.h	/^    Array(unsigned n) : sz(0), elems(0) {resize(n);}$/;"	f	class:can::Array
Array	can/canArray.h	/^class Array$/;"	c	namespace:can
Array	can/canArray.h	/^class Array<T,0>$/;"	c	namespace:can
ArrayDataOf	apf/apfArrayData.cc	/^class ArrayDataOf : public FieldDataOf<T>$/;"	c	namespace:apf	file:
Associative	parma/diffMC/parma_associative.h	/^      Associative() {$/;"	f	class:parma::Associative
Associative	parma/diffMC/parma_associative.h	/^  template <class T> class Associative {$/;"	c	namespace:parma
AutoSolutionTransfer	ma/maSolutionTransfer.cc	/^AutoSolutionTransfer::AutoSolutionTransfer(Mesh* m)$/;"	f	class:ma::AutoSolutionTransfer
AutoSolutionTransfer	ma/maSolutionTransfer.h	/^class AutoSolutionTransfer : public SolutionTransfers$/;"	c	namespace:ma
Average	parma/diffMC/parma_monitor.cc	/^  Average::Average(unsigned int l) : CircBuffer(l) {}$/;"	f	class:parma::Average
Average	parma/diffMC/parma_monitor.h	/^  class Average : public CircBuffer {$/;"	c	namespace:parma
AverageOp	spr/sprEstimateError.cc	/^    AverageOp(Estimation* e):$/;"	f	class:spr::AverageOp
AverageOp	spr/sprEstimateError.cc	/^class AverageOp : public apf::CavityOp$/;"	c	namespace:spr	file:
AverageOp	spr/sprEstimateTargetError.cc	/^    AverageOp(Estimation* est):$/;"	f	class:spr::target::AverageOp
AverageOp	spr/sprEstimateTargetError.cc	/^class AverageOp : public apf::CavityOp$/;"	c	namespace:spr::target	file:
Axpy	apf/apfFieldOf.cc	/^class Axpy : public FieldOp$/;"	c	namespace:apf	file:
B	crv/crvBlended.cc	/^static int B[apf::Mesh::TYPES] =$/;"	m	namespace:crv	file:
B737	test/capStoneIsoAdaptB737.cc	/^    B737(ma::Mesh* m)$/;"	f	class:B737
B737	test/capStoneIsoAdaptB737.cc	/^class B737 : public ma::IsotropicFunction$/;"	c	file:
BAD_QUALITY	ma/maAdapt.h	/^  BAD_QUALITY   = (1<< 5),$/;"	e	enum:ma::__anon25
BC	phasta/phBC.h	/^struct BC$/;"	s	namespace:ph
BCFactories	phasta/phAttrib.cc	/^typedef std::map<std::string, BCFactory> BCFactories;$/;"	t	file:
BCFactory	phasta/phAttrib.cc	/^typedef ph::BC* (*BCFactory)(pAttribute a, pGEntity ge);$/;"	t	class:ph	file:
BCPointerLess	phasta/phBC.h	/^struct BCPointerLess$/;"	s	namespace:ph
BCs	phasta/phBC.h	/^struct BCs$/;"	s	namespace:ph
BF	test/poisson.cc	/^    apf::NewArray<double> BF;$/;"	m	class:__anon17::Poisson	file:
BILLION	phasta/phiotimer.cc	11;"	d	file:
BOTTOMFACE	test/icesheet.cc	23;"	d	file:
BOTTOMTAG	test/icesheet.cc	15;"	d	file:
BOTTOM_EDGE	test/icesheet.cc	25;"	d	file:
BOTTOM_PERIMETERTAG	test/icesheet.cc	18;"	d	file:
BOTTOM_VERTEX	test/icesheet.cc	28;"	d	file:
BSpline	test/fusion3.cc	/^  BSpline():order(-1){}$/;"	f	class:BSpline
BSpline	test/fusion3.cc	/^BSpline :: BSpline(int order_p, vector<double> &ctrlPts_p, vector<double> & knots_p)$/;"	f	class:BSpline
BSpline	test/fusion3.cc	/^class BSpline: public Expression$/;"	c	file:
BalOrStall	parma/diffMC/parma_stop.cc	/^  BalOrStall::BalOrStall(Average* imb, Average* sides, double sidesTol, int v)$/;"	f	class:parma::BalOrStall
BalOrStall	parma/diffMC/parma_stop.h	/^  class BalOrStall : public Stop {$/;"	c	namespace:parma
Balancer	apf/apfPartition.h	/^class Balancer$/;"	c	namespace:apf
Balancer	parma/diffMC/parma_balancer.cc	/^  Balancer::Balancer(apf::Mesh* m, double f, int v, const char* n)$/;"	f	class:parma::Balancer
Balancer	parma/diffMC/parma_balancer.h	/^  class Balancer : public apf::Balancer {$/;"	c	namespace:parma
Base	apf/apfDynamicArray.h	/^    typedef can::Array<T, 0> Base;$/;"	t	class:apf::DynamicArray
Base	apf/apfNew.h	/^    typedef can::NewArray<T> Base;$/;"	t	class:apf::NewArray
BaseTopLinker	ma/maLayerSnap.cc	/^  BaseTopLinker(Adapt* a_):$/;"	f	struct:ma::BaseTopLinker
BaseTopLinker	ma/maLayerSnap.cc	/^struct BaseTopLinker : public Crawler$/;"	s	namespace:ma	file:
BdryItr	parma/diffMC/parma_components.cc	/^      BdryItr() {$/;"	f	class:parma::dcComponents::BdryItr
BdryItr	parma/diffMC/parma_components.cc	/^  class dcComponents::BdryItr {$/;"	c	class:parma::dcComponents	file:
BdryVtxItr	parma/diffMC/parma_bdryVtx.h	/^  class BdryVtxItr {$/;"	c	namespace:parma
Bezier	crv/crvBezier.cc	/^  Bezier() {$/;"	f	class:crv::Bezier
Bezier	crv/crvBezier.cc	/^class Bezier : public apf::FieldShape$/;"	c	namespace:crv	file:
BezierCurver	crv/crv.h	/^    BezierCurver(apf::Mesh2* m, int P, int B) : MeshCurver(m,P)$/;"	f	class:crv::BezierCurver
BezierCurver	crv/crv.h	/^class BezierCurver : public MeshCurver$/;"	c	namespace:crv
BezierHandler	crv/crvShapeHandler.cc	/^    BezierHandler(ma::Adapt* a)$/;"	f	class:crv::BezierHandler
BezierHandler	crv/crvShapeHandler.cc	/^class BezierHandler : public ma::ShapeHandler$/;"	c	namespace:crv	file:
BezierTransfer	crv/crvShapeHandler.cc	/^    BezierTransfer(ma::Adapt* a)$/;"	f	class:crv::BezierTransfer
BezierTransfer	crv/crvShapeHandler.cc	/^class BezierTransfer : public ma::SolutionTransfer$/;"	c	namespace:crv	file:
Bij	crv/crvBernstein.cc	/^double Bij(const int i, const int j, const double u, const double v)$/;"	f	namespace:crv
Bij	crv/crvBernstein.cc	/^double Bij(const int ij[], const double xi[])$/;"	f	namespace:crv
Bijk	crv/crvBernstein.cc	/^double Bijk(const int i, const int j, const int k,$/;"	f	namespace:crv
Bijk	crv/crvBernstein.cc	/^double Bijk(const int ijk[], const double xi[])$/;"	f	namespace:crv
Bijkl	crv/crvBernstein.cc	/^double Bijkl(const int i, const int j, const int k, const int l,$/;"	f	namespace:crv
Bijkl	crv/crvBernstein.cc	/^double Bijkl(const int ijkl[], const double xi[])$/;"	f	namespace:crv
BlendedTetGetLocalGradients	crv/crvBlended.cc	/^void BlendedTetGetLocalGradients(apf::Mesh* m, apf::MeshEntity* e,$/;"	f	namespace:crv
BlendedTetGetValues	crv/crvBlended.cc	/^void BlendedTetGetValues(apf::Mesh* m, apf::MeshEntity* e,$/;"	f	namespace:crv
BlendedTriangleGetLocalGradients	crv/crvBlended.cc	/^void BlendedTriangleGetLocalGradients(apf::Mesh* m, apf::MeshEntity* e,$/;"	f	namespace:crv
BlendedTriangleGetValues	crv/crvBlended.cc	/^void BlendedTriangleGetValues(apf::Mesh* m, apf::MeshEntity* e,$/;"	f	namespace:crv
BlockKey	phasta/phBlock.h	/^struct BlockKey$/;"	s	namespace:ph
BlockKeyInterface	phasta/phBlock.h	/^struct BlockKeyInterface : public BlockKey$/;"	s	namespace:ph
Blocks	phasta/phBlock.h	/^struct Blocks : public BlocksCommon$/;"	s	namespace:ph
BlocksCommon	phasta/phBlock.h	/^struct BlocksCommon$/;"	s	namespace:ph
BlocksInterface	phasta/phBlock.h	/^struct BlocksInterface : public BlocksCommon$/;"	s	namespace:ph
Bodies	parma/rib/parma_rib.cc	/^Bodies::Bodies()$/;"	f	class:parma::Bodies
Bodies	parma/rib/parma_rib.h	/^struct Bodies$/;"	s	namespace:parma
Body	parma/rib/parma_rib.h	/^struct Body$/;"	s	namespace:parma
BothEval	ma/maSize.cc	/^  BothEval()$/;"	f	struct:ma::BothEval
BothEval	ma/maSize.cc	/^  BothEval(AnisotropicFunction* f)$/;"	f	struct:ma::BothEval
BothEval	ma/maSize.cc	/^struct BothEval$/;"	s	namespace:ma	file:
Boundary	dsp/dspSmoothers.h	/^typedef std::set<apf::ModelEntity*> Boundary;$/;"	t	namespace:dsp
BoxBuilder	mds/apfBox.cc	/^BoxBuilder::BoxBuilder(int nx, int ny, int nz,$/;"	f	class:apf::BoxBuilder
BoxBuilder	mds/apfBox.h	/^struct BoxBuilder$/;"	s	namespace:apf
Bubble	phasta/phBubble.cc	/^struct Bubble {$/;"	s	namespace:ph	file:
Bubbles	phasta/phBubble.cc	/^typedef std::vector<Bubble> Bubbles;$/;"	t	namespace:ph	file:
BuildCallback	apf/apfMesh2.h	/^class BuildCallback$/;"	c	namespace:apf
CAN_ARRAY_H	can/canArray.h	9;"	d
CAN_NEW_ARRAY_H	can/canNewArray.h	9;"	d
CHECKED	ma/maAdapt.h	/^  CHECKED       = (1<< 4),$/;"	e	enum:ma::__anon25
CHEF_H	phasta/chef.h	2;"	d
COLLAPSE	ma/maAdapt.h	/^  COLLAPSE      = (1<< 2),$/;"	e	enum:ma::__anon25
CONTAINER	pumi/mPartEntityContainer.h	/^    typedef List* CONTAINER;$/;"	t	class:mPartEntityContainer
CRVADAPT_H	crv/crvAdapt.h	9;"	d
CRVBEZIERSHAPES_H	crv/crvBezierShapes.h	9;"	d
CRVBEZIER_H	crv/crvBezier.h	9;"	d
CRVMATH_H	crv/crvMath.h	9;"	d
CRVQUALITY_H	crv/crvQuality.h	9;"	d
CRVSHAPE_H	crv/crvShape.h	9;"	d
CRVSNAP_H	crv/crvSnap.h	9;"	d
CRVTABLES_H	crv/crvTables.h	9;"	d
CRV_CRVSHAPEFIX_H	crv/crvShapeFixer.h	19;"	d
CRV_H	crv/crv.h	9;"	d
CUBE	ma/maReposition.cc	28;"	d	file:
CavEnts	parma/diffMC/parma_dijkstra.cc	/^  typedef std::set<apf::MeshEntity*> CavEnts;$/;"	t	namespace:__anon70	file:
Cavity	ma/maAdapt.cc	/^Cavity::Cavity()$/;"	f	class:ma::Cavity
Cavity	ma/maAdapt.h	/^class Cavity$/;"	c	namespace:ma
CavityOp	apf/apfCavityOp.cc	/^CavityOp::CavityOp(Mesh* m, bool cm):$/;"	f	class:apf::CavityOp
CavityOp	apf/apfCavityOp.h	/^class CavityOp$/;"	c	namespace:apf
CavityTransfer	ma/maSolutionTransfer.cc	/^    CavityTransfer(apf::Field* f):$/;"	f	class:ma::CavityTransfer
CavityTransfer	ma/maSolutionTransfer.cc	/^class CavityTransfer : public FieldTransfer$/;"	c	namespace:ma	file:
CentroidBalancer	parma/diffMC/parma_centroidDiffuser.cc	/^      CentroidBalancer(apf::Mesh* m, double f, int v)$/;"	f	class:__anon62::CentroidBalancer
CentroidBalancer	parma/diffMC/parma_centroidDiffuser.cc	/^  class CentroidBalancer : public parma::Balancer {$/;"	c	namespace:__anon62	file:
CentroidSelector	parma/diffMC/parma_centroidSelector.cc	/^      CentroidSelector(apf::Mesh* m, apf::MeshTag* w, Centroids* c)$/;"	f	class:parma::CentroidSelector
CentroidSelector	parma/diffMC/parma_centroidSelector.cc	/^  class CentroidSelector : public Selector {$/;"	c	namespace:parma	file:
Centroids	parma/diffMC/parma_centroids.cc	/^  Centroids::Centroids(apf::Mesh* m, apf::MeshTag* w, Sides* s) {$/;"	f	class:parma::Centroids
Centroids	parma/diffMC/parma_centroids.h	/^  class Centroids : public Associative<apf::Vector3> {$/;"	c	namespace:parma
Changing Layer Count	ma/layer.tex	/^unstructured mesh to account for this change.$/;"	s
CheckMatrixDerivIntegrator	test/test_matrix_grad.cc	/^    CheckMatrixDerivIntegrator(int order, apf::Field * matrix_deriv_fld) : Integrator(order), matrix_deriv_fld(matrix_deriv_fld) {}$/;"	f	class:CheckMatrixDerivIntegrator
CheckMatrixDerivIntegrator	test/test_matrix_grad.cc	/^class CheckMatrixDerivIntegrator : public apf::Integrator$/;"	c	file:
CircBuffer	parma/diffMC/parma_monitor.cc	/^  CircBuffer::CircBuffer(unsigned int l) {$/;"	f	class:parma::CircBuffer
CircBuffer	parma/diffMC/parma_monitor.h	/^  class CircBuffer {$/;"	c	namespace:parma
Class Hiding	design.tex	/^user-defined code to invoke at each entity and across part boundaries.$/;"	s
Coarsening	ma/adapt2.tex	/^\\maketitle$/;"	s
CodeMatch	ma/maTables.h	/^struct CodeMatch$/;"	s	namespace:ma
Collapse	ma/maCollapse.h	/^class Collapse$/;"	c	namespace:ma
CollapseChecker	ma/maCoarsen.cc	/^    CollapseChecker(Adapt* a, int md):$/;"	f	class:ma::CollapseChecker
CollapseChecker	ma/maCoarsen.cc	/^class CollapseChecker : public apf::CavityOp$/;"	c	namespace:ma	file:
CollectiveOperation	ma/maOperator.cc	/^    CollectiveOperation(Adapt* a, Operator* o):$/;"	f	class:ma::CollectiveOperation
CollectiveOperation	ma/maOperator.cc	/^class CollectiveOperation : public apf::CavityOp, public DeleteCallback$/;"	c	namespace:ma	file:
Comp	parma/diffMC/parma_components.cc	/^  struct Comp {$/;"	s	namespace:__anon65	file:
CompBC	phasta/phAttrib.cc	/^  CompBC(pAttribute a, pGEntity ge):SimBC(ge)$/;"	f	struct:CompBC
CompBC	phasta/phAttrib.cc	/^struct CompBC : public SimBC {$/;"	s	file:
CompContains	parma/diffMC/parma_graphDist.cc	/^      CompContains(parma::dcComponents& comps, unsigned compid)$/;"	f	class:__anon74::CompContains
CompContains	parma/diffMC/parma_graphDist.cc	/^  class CompContains : public parma::DijkstraContains {$/;"	c	namespace:__anon74	file:
CompUpdateContains	parma/diffMC/parma_graphDist.cc	/^      CompUpdateContains() {}$/;"	f	class:__anon74::CompUpdateContains
CompUpdateContains	parma/diffMC/parma_graphDist.cc	/^  class CompUpdateContains : public parma::DijkstraContains {$/;"	c	namespace:__anon74	file:
Compare	parma/rib/parma_rib.cc	/^struct Compare$/;"	s	namespace:parma	file:
CompareMigr	parma/diffMC/parma_edgeEqVtxSelector.cc	/^      struct CompareMigr {$/;"	s	class:__anon52::EdgeEqVtx	file:
CompareMigr	parma/diffMC/parma_elmLtVtxEdgeSelector.cc	/^      struct CompareMigr {$/;"	s	class:__anon64::ElmLtVtxEdgeSelector	file:
CompareMigr	parma/diffMC/parma_ltSelector.cc	/^      struct CompareMigr {$/;"	s	class:__anon58::LtSelector	file:
Components	parma/diffMC/parma_components.cc	/^  DCC::Components(apf::Mesh* mesh, unsigned verbose)$/;"	f	class:parma::DCC
Components	parma/diffMC/parma_components.h	/^  class dcComponents::Components : public dcPart {$/;"	c	class:parma::dcComponents
Constant	apf/apfShape.cc	/^    Constant()$/;"	f	class:apf::Constant
Constant	apf/apfShape.cc	/^class Constant : public FieldShape$/;"	c	namespace:apf	file:
ConstantBC	phasta/phBC.cc	/^ConstantBC::ConstantBC()$/;"	f	class:ph::ConstantBC
ConstantBC	phasta/phBC.h	/^struct ConstantBC : public BC$/;"	s	namespace:ph
ConstantIPFit	apf/apfIPShape.cc	/^    ConstantIPFit(int d) : IPBase(d, 1)$/;"	f	class:apf::ConstantIPFit
ConstantIPFit	apf/apfIPShape.cc	/^class ConstantIPFit : public IPBase$/;"	c	namespace:apf	file:
Constraint	phasta/phConstraint.cc	/^  Constraint(int n)$/;"	f	struct:ph::Constraint
Constraint	phasta/phConstraint.cc	/^struct Constraint$/;"	s	namespace:ph	file:
Container	parma/diffMC/parma_associative.h	/^    typedef std::map<int, T> Container;$/;"	t	class:parma::Associative
Contract	apf/apfPartition.h	/^  Contract(int nin, int nout):$/;"	f	struct:apf::Contract
Contract	apf/apfPartition.h	/^struct Contract : public Remap$/;"	s	namespace:apf
Converter	apf/apfConvert.cc	/^    Converter(Mesh *a, Mesh2 *b)$/;"	f	class:apf::Converter
Converter	apf/apfConvert.cc	/^class Converter$/;"	c	namespace:apf	file:
CoordData	apf/apfCoordData.h	/^class CoordData : public FieldDataOf<double>$/;"	c	namespace:apf
Coordinates	apf/attach.tex	/^such as $|W_e|$ and $g$ may have to be specified on a per-entity basis.$/;"	s
Copies	apf/apfMesh.h	/^typedef std::map<int,MeshEntity*> Copies;$/;"	t	namespace:apf
Copies	pumi/pumi.h	/^typedef apf::Copies Copies;$/;"	t
Copy	apf/apfMesh.h	/^  Copy():peer(0),entity(0) {}$/;"	f	struct:apf::Copy
Copy	apf/apfMesh.h	/^  Copy(int p, MeshEntity* e):peer(p),entity(e) {}$/;"	f	struct:apf::Copy
Copy	apf/apfMesh.h	/^struct Copy$/;"	s	namespace:apf
CopyArray	apf/apfMesh.h	/^typedef DynamicArray<Copy> CopyArray;$/;"	t	namespace:apf
CopyArray	pumi/pumi.h	/^typedef apf::CopyArray CopyArray; \/\/ array type for remote copies$/;"	t
CopyOp	apf/apfFieldData.cc	/^    CopyOp(FieldDataOf<T>* ld,$/;"	f	class:apf::CopyOp
CopyOp	apf/apfFieldData.cc	/^class CopyOp : public FieldOp$/;"	c	namespace:apf	file:
CountIntegrator	test/test_integrator.cc	/^    CountIntegrator() : Integrator(1), numEnt(0) {};$/;"	f	class:CountIntegrator
CountIntegrator	test/test_integrator.cc	/^class CountIntegrator : public apf::Integrator {$/;"	c	file:
CountMap	mds/apfPM.cc	/^typedef std::map<int,size_t> CountMap;$/;"	t	namespace:apf	file:
Counter	apf/apfNumbering.cc	/^class Counter : public FieldOp$/;"	c	namespace:apf	file:
Crawler	ma/maCrawler.h	/^  Crawler(Mesh* m):mesh(m) {}$/;"	f	struct:ma::Crawler
Crawler	ma/maCrawler.h	/^struct Crawler$/;"	s	namespace:ma
CrvEdgeEdgeFixer	crv/crvShapeFixer.cc	/^CrvEdgeEdgeFixer::CrvEdgeEdgeFixer(Adapt* a)$/;"	f	class:crv::CrvEdgeEdgeFixer
CrvEdgeEdgeFixer	crv/crvShapeFixer.h	/^class CrvEdgeEdgeFixer : public CrvTetFixerBase$/;"	c	namespace:crv
CrvFaceVertFixer	crv/crvShapeFixer.cc	/^CrvFaceVertFixer::CrvFaceVertFixer(Adapt* a)$/;"	f	class:crv::CrvFaceVertFixer
CrvFaceVertFixer	crv/crvShapeFixer.h	/^class CrvFaceVertFixer : public CrvTetFixerBase$/;"	c	namespace:crv
CrvLargeAngleTetFixer	crv/crvShapeFixer.cc	/^CrvLargeAngleTetFixer::CrvLargeAngleTetFixer(Adapt* a):$/;"	f	class:crv::CrvLargeAngleTetFixer
CrvLargeAngleTetFixer	crv/crvShapeFixer.h	/^class CrvLargeAngleTetFixer : public ma::Operator$/;"	c	namespace:crv
CrvLargeAngleTriFixer	crv/crvShapeFixer.cc	/^CrvLargeAngleTriFixer::CrvLargeAngleTriFixer(Adapt* a):$/;"	f	class:crv::CrvLargeAngleTriFixer
CrvLargeAngleTriFixer	crv/crvShapeFixer.h	/^class CrvLargeAngleTriFixer : public ma::Operator$/;"	c	namespace:crv
CrvShortEdgeFixer	crv/crvShapeFixer.cc	/^CrvShortEdgeFixer::CrvShortEdgeFixer(Adapt* a):$/;"	f	class:crv::CrvShortEdgeFixer
CrvShortEdgeFixer	crv/crvShapeFixer.h	/^class CrvShortEdgeFixer : public ma::Operator$/;"	c	namespace:crv
CrvTetFixerBase	crv/crvShapeFixer.h	/^class CrvTetFixerBase$/;"	c	namespace:crv
Curl	apf/apf.tex	/^\\[(\\nabla \\cdot f)^e(\\xi) = \\sum_{a\\in W(\\bar{e}} w_{a,x}(\\xi) \\cdot f_a\\]$/;"	b
CurveLocalizer	ma/maLayerCoarsen.cc	/^  CurveLocalizer(Adapt* a_, int r, apf::Migration* p):$/;"	f	struct:ma::CurveLocalizer
CurveLocalizer	ma/maLayerCoarsen.cc	/^struct CurveLocalizer : public Crawler$/;"	s	namespace:ma	file:
CylindricalShock	test/torus_ma_test.cc	/^    CylindricalShock(ma::Mesh* m)$/;"	f	class:CylindricalShock
CylindricalShock	test/torus_ma_test.cc	/^class CylindricalShock : public ma::AnisotropicFunction$/;"	c	file:
DCC	parma/diffMC/parma_components.cc	25;"	d	file:
DIAGONAL_1	ma/maAdapt.h	/^  DIAGONAL_1    = (1<<13),$/;"	e	enum:ma::__anon25
DIAGONAL_2	ma/maAdapt.h	/^  DIAGONAL_2    = (1<<14),$/;"	e	enum:ma::__anon25
DIR_FANOUT	phasta/ph.cc	/^  DIR_FANOUT = 2048$/;"	e	enum:ph::__anon92	file:
DIR_MODE	phasta/ph.cc	/^  DIR_MODE = S_IRWXU | S_IRWXG | S_IROTH | S_IXOTH$/;"	e	enum:ph::__anon91	file:
DONT_COLLAPSE	ma/maAdapt.h	/^  DONT_COLLAPSE = (1<< 3),$/;"	e	enum:ma::__anon25
DONT_MOVE	ma/maAdapt.h	/^  DONT_MOVE	= (1<<16)$/;"	e	enum:ma::__anon25
DONT_SNAP	ma/maAdapt.h	/^  DONT_SNAP     = (1<< 8),$/;"	e	enum:ma::__anon25
DONT_SPLIT	ma/maAdapt.h	/^  DONT_SPLIT    = (1<< 1),$/;"	e	enum:ma::__anon25
DONT_SWAP	ma/maAdapt.h	/^  DONT_SWAP     = (1<< 9),$/;"	e	enum:ma::__anon25
DOUBLE	apf/apfMesh.h	/^      DOUBLE,$/;"	e	enum:apf::Mesh::TagType
DSP_ADAPTERS_H	dsp/dspAdapters.h	2;"	d
DSP_GRAPH_DISTANCE_H	dsp/dspGraphDistance.h	2;"	d
DSP_H	dsp/dsp.h	2;"	d
DSP_SMOOTHERS_H	dsp/dspSmoothers.h	2;"	d
DataGetter	ma/maExtrude.cc	/^struct DataGetter {$/;"	s	namespace:ma::__anon28	file:
DataSetter	ma/maExtrude.cc	/^struct DataSetter {$/;"	s	namespace:ma::__anon28	file:
DblMap	phasta/phInput.cc	/^typedef std::map<std::string, double*> DblMap;$/;"	t	namespace:ph	file:
DebugBuildCallback	ma/maExtrude.cc	/^    DebugBuildCallback(Mesh* m, int expected_type):$/;"	f	class:ma::__anon28::DebugBuildCallback
DebugBuildCallback	ma/maExtrude.cc	/^class DebugBuildCallback : public apf::BuildCallback {$/;"	c	namespace:ma::__anon28	file:
DebugConstraint	phasta/phConstraint.cc	/^struct DebugConstraint$/;"	s	namespace:ph	file:
Definitions	apf/attach.tex	/^element field data attached to a mesh.$/;"	s
DeleteCallback	ma/maAdapt.cc	/^DeleteCallback::DeleteCallback(Adapt* a)$/;"	f	class:ma::DeleteCallback
DeleteCallback	ma/maAdapt.h	/^class DeleteCallback$/;"	c	namespace:ma
DgCopies	apf/apfMesh.h	/^typedef CopyArray DgCopies;$/;"	t	namespace:apf
DijkstraContains	parma/diffMC/parma_dijkstra.h	/^  class DijkstraContains {$/;"	c	namespace:parma
Disambiguator	ma/maLayerRefine.cc	/^  Disambiguator(Adapt* a_):$/;"	f	struct:ma::Disambiguator
Disambiguator	ma/maLayerRefine.cc	/^struct Disambiguator : public Crawler$/;"	s	namespace:ma	file:
DistItr	parma/diffMC/parma_bdryVtx.cc	/^      DistItr(apf::Mesh* m, apf::MeshTag* d) $/;"	f	class:__anon54::DistItr
DistItr	parma/diffMC/parma_bdryVtx.cc	/^  class DistItr : public parma::BdryVtxItr {$/;"	c	namespace:__anon54	file:
Distance	parma/diffMC/parma_centroidSelector.cc	/^      Distance(apf::Mesh* mesh, parma::Centroids* centroids) $/;"	f	class:__anon49::Distance
Distance	parma/diffMC/parma_centroidSelector.cc	/^  class Distance {$/;"	c	namespace:__anon49	file:
DistanceQ	parma/diffMC/parma_centroidSelector.cc	/^    typedef std::multimap<double,apf::MeshEntity*> DistanceQ;$/;"	t	class:__anon49::DistanceQueue	file:
DistanceQ	parma/diffMC/parma_distQ.h	/^    typedef typename std::multimap<int, apf::MeshEntity*, Compare> DistanceQ;$/;"	t	class:parma::DistanceQueue
DistanceQIter	parma/diffMC/parma_distQ.h	/^    typedef typename DistanceQ::iterator DistanceQIter;$/;"	t	class:parma::DistanceQueue
DistanceQueue	parma/diffMC/parma_centroidSelector.cc	/^      DistanceQueue(apf::Mesh* mesh, apf::MeshTag* tag, Distance* dist) $/;"	f	class:__anon49::DistanceQueue
DistanceQueue	parma/diffMC/parma_centroidSelector.cc	/^  class DistanceQueue {$/;"	c	namespace:__anon49	file:
DistanceQueue	parma/diffMC/parma_distQ.h	/^    DistanceQueue(apf::Mesh* mesh) : m(mesh)$/;"	f	class:parma::DistanceQueue
DistanceQueue	parma/diffMC/parma_distQ.h	/^  template <class Compare> class DistanceQueue {$/;"	c	namespace:parma
Distribution	apf/apf.tex	/^\\end{center}$/;"	s
Distribution	pumi/pumi.h	/^class Distribution$/;"	c
Distribution	pumi/pumi_mesh.cc	/^Distribution::Distribution(pMesh mesh)$/;"	f	class:Distribution
Divergence	apf/apf.tex	/^\\[w_{a,x} = J^{-1}w_{a,\\xi}\\]$/;"	b
Divide	apf/apfPartition.h	/^  Divide(int n):by(n) {}$/;"	f	struct:apf::Divide
Divide	apf/apfPartition.h	/^struct Divide : public Remap$/;"	s	namespace:apf
DoubleSplitCollapse	ma/maDoubleSplitCollapse.cc	/^DoubleSplitCollapse::DoubleSplitCollapse(Adapt* a):$/;"	f	class:ma::DoubleSplitCollapse
DoubleSplitCollapse	ma/maDoubleSplitCollapse.h	/^class DoubleSplitCollapse$/;"	c	namespace:ma
DoubleTagCAP	apf_cap/apfCAP.cc	/^    DoubleTagCAP(MeshDatabaseInterface* m, const char* name, int c):$/;"	f	class:apf::DoubleTagCAP
DoubleTagCAP	apf_cap/apfCAP.cc	/^class DoubleTagCAP : public TagCAP$/;"	c	namespace:apf	file:
DoubleTagSIM	apf_sim/apfSIM.cc	/^    DoubleTagSIM(pParMesh m, const char* name, int c):$/;"	f	class:apf::DoubleTagSIM
DoubleTagSIM	apf_sim/apfSIM.cc	/^class DoubleTagSIM : public TagSIM$/;"	c	namespace:apf	file:
Downward	apf/apfMesh.h	/^typedef MeshEntity* Downward[12];$/;"	t	namespace:apf
Downward	ma/maMesh.h	/^typedef apf::Downward Downward;$/;"	t	namespace:ma
DynamicArray	apf/apfDynamicArray.h	/^    DynamicArray() {}$/;"	f	class:apf::DynamicArray
DynamicArray	apf/apfDynamicArray.h	/^    DynamicArray(std::size_t n):Base((unsigned)n) {}$/;"	f	class:apf::DynamicArray
DynamicArray	apf/apfDynamicArray.h	/^class DynamicArray : public can::Array<T, 0> {$/;"	c	namespace:apf
DynamicArrayTopList	apf_sim/apfSIM.h	/^static void DynamicArrayTopList(const DynamicArray<T> & array, pPList & list)$/;"	f	namespace:apf
DynamicMatrix	apf/apfDynamicMatrix.h	/^    DynamicMatrix() {}$/;"	f	class:apf::DynamicMatrix
DynamicMatrix	apf/apfDynamicMatrix.h	/^    DynamicMatrix(std::size_t m, std::size_t n):$/;"	f	class:apf::DynamicMatrix
DynamicMatrix	apf/apfDynamicMatrix.h	/^class DynamicMatrix$/;"	c	namespace:apf
DynamicVector	apf/apfDynamicVector.h	/^    DynamicVector() {}$/;"	f	class:apf::DynamicVector
DynamicVector	apf/apfDynamicVector.h	/^    DynamicVector(std::size_t n):DynamicArray<double>(n) {}$/;"	f	class:apf::DynamicVector
DynamicVector	apf/apfDynamicVector.h	/^class DynamicVector : public DynamicArray<double>$/;"	c	namespace:apf
EDGE	apf/apfMesh.h	/^      EDGE,     \/\/1$/;"	e	enum:apf::Mesh::Type
EDGE_EDGE	crv/crvShapeFixer.h	/^    enum{EDGE_EDGE, FACE_VERT};$/;"	e	enum:crv::CrvLargeAngleTetFixer::__anon102
EDGE_EDGE	ma/maShape.cc	/^    enum { EDGE_EDGE, FACE_VERT };$/;"	e	enum:ma::LargeAngleTetFixer::__anon26	file:
ENT_TOPOLOGIES	pumi/pumi.h	/^  ENT_TOPOLOGIES$/;"	e	enum:PUMI_EntTopology
Edge	apf/apfShape.cc	/^    class Edge : public EntityShape$/;"	c	class:apf::LagrangeCubic	file:
Edge	apf/apfShape.cc	/^    class Edge : public EntityShape$/;"	c	class:apf::Linear	file:
Edge	apf/apfShape.cc	/^    class Edge : public EntityShape$/;"	c	class:apf::QuadraticBase	file:
Edge	crv/crvBezier.cc	/^  class Edge : public apf::EntityShape$/;"	c	class:crv::Bezier	file:
Edge Collapse Conditions	ma/new.tex	/^developments going from meshadapt 1.0 to 2.0.$/;"	s
Edge shape functions	apf/hierarchic.tex	/^functions and are of polynomial order $p=1$.$/;"	b
EdgeEdgeFixer	ma/maShape.cc	/^    EdgeEdgeFixer(Adapt* a):$/;"	f	class:ma::EdgeEdgeFixer
EdgeEdgeFixer	ma/maShape.cc	/^class EdgeEdgeFixer : public TetFixerBase$/;"	c	namespace:ma	file:
EdgeEqVtx	parma/diffMC/parma_edgeEqVtxSelector.cc	/^      EdgeEqVtx(apf::Mesh* m, apf::MeshTag* w, double maxV)$/;"	f	class:__anon52::EdgeEqVtx
EdgeEqVtx	parma/diffMC/parma_edgeEqVtxSelector.cc	/^  class EdgeEqVtx : public parma::VtxSelector {$/;"	c	namespace:__anon52	file:
EdgeIntegration	apf/apfIntegrate.cc	/^class EdgeIntegration : public EntityIntegration$/;"	c	namespace:apf	file:
EdgeIteratorSIM	apf_sim/apfSIM.cc	/^    EdgeIteratorSIM(pMesh part)$/;"	f	class:apf::EdgeIteratorSIM
EdgeIteratorSIM	apf_sim/apfSIM.cc	/^class EdgeIteratorSIM : public IteratorSIM$/;"	c	namespace:apf	file:
EdgeReshaper	crv/crvShape.cc	/^  EdgeReshaper(Adapt* a)$/;"	f	class:crv::EdgeReshaper
EdgeReshaper	crv/crvShape.cc	/^class EdgeReshaper : public ma::Operator$/;"	c	namespace:crv	file:
EdgeSwap	ma/maEdgeSwap.h	/^class EdgeSwap$/;"	c	namespace:ma
EdgeSwap2D	ma/maEdgeSwap.cc	/^    EdgeSwap2D(Adapt* a)$/;"	f	class:ma::EdgeSwap2D
EdgeSwap2D	ma/maEdgeSwap.cc	/^class EdgeSwap2D : public EdgeSwap$/;"	c	namespace:ma	file:
EdgeSwap3D	ma/maEdgeSwap.cc	/^    EdgeSwap3D(Adapt* a):$/;"	f	class:ma::EdgeSwap3D
EdgeSwap3D	ma/maEdgeSwap.cc	/^class EdgeSwap3D : public EdgeSwap$/;"	c	namespace:ma	file:
EdgeSwapper	crv/crvShape.cc	/^  EdgeSwapper(Adapt* a)$/;"	f	class:crv::EdgeSwapper
EdgeSwapper	crv/crvShape.cc	/^class EdgeSwapper : public ma::Operator$/;"	c	namespace:crv	file:
ElemSet	stk/apfAlbany.h	/^typedef std::vector<apf::MeshEntity*> ElemSet;$/;"	t	namespace:apf
ElemSets	stk/apfAlbany.h	/^typedef std::map<std::string, ElemSet> ElemSets;$/;"	t	namespace:apf
Element	apf/apfElement.cc	/^Element::Element(Field* f, MeshEntity* e)$/;"	f	class:apf::Element
Element	apf/apfElement.cc	/^Element::Element(Field* f, VectorElement* p)$/;"	f	class:apf::Element
Element	apf/apfElement.h	/^class Element$/;"	c	namespace:apf
Element	apf/apfIPShape.cc	/^    class Element : public EntityShape$/;"	c	class:apf::VoronoiShape	file:
Element	apf/apfShape.cc	/^    class Element : public EntityShape$/;"	c	class:apf::Constant	file:
ElementBuilder	apf/apfMesh2.cc	/^    ElementBuilder($/;"	f	class:apf::ElementBuilder
ElementBuilder	apf/apfMesh2.cc	/^class ElementBuilder : public ElementVertOp$/;"	c	namespace:apf	file:
ElementError	spr/sprEstimateError.cc	/^    ElementError(Estimation* e):$/;"	f	class:spr::ElementError
ElementError	spr/sprEstimateError.cc	/^class ElementError : public SInt$/;"	c	namespace:spr	file:
ElementError	spr/sprEstimateTargetError.cc	/^    ElementError(Estimation* e):$/;"	f	class:spr::target::ElementError
ElementError	spr/sprEstimateTargetError.cc	/^class ElementError : public ScalarIntegrator$/;"	c	namespace:spr::target	file:
ElementFinder	apf/apfMesh.cc	/^    ElementFinder(Mesh* m)$/;"	f	class:apf::ElementFinder
ElementFinder	apf/apfMesh.cc	/^class ElementFinder : public ElementVertOp$/;"	c	namespace:apf	file:
ElementOf	apf/apfElementOf.h	/^    ElementOf(FieldOf<T>* f, MeshEntity* e):$/;"	f	class:apf::ElementOf
ElementOf	apf/apfElementOf.h	/^    ElementOf(FieldOf<T>* f, VectorElement* p):$/;"	f	class:apf::ElementOf
ElementOf	apf/apfElementOf.h	/^class ElementOf : public Element$/;"	c	namespace:apf
ElementVertOp	apf/apfMesh.h	/^class ElementVertOp$/;"	c	namespace:apf
ElevateFunction	crv/crvElevation.cc	/^typedef void (*ElevateFunction)(int P, int r,$/;"	t	namespace:crv	file:
ElevateJacobianDetFunction	crv/crvElevation.cc	/^typedef void (*ElevateJacobianDetFunction)(int P, int r,$/;"	t	namespace:crv	file:
ElmBalancer	parma/diffMC/parma_elmBalancer.cc	/^      ElmBalancer(apf::Mesh* m, double f, int v)$/;"	f	class:__anon60::ElmBalancer
ElmBalancer	parma/diffMC/parma_elmBalancer.cc	/^  class ElmBalancer : public parma::Balancer {$/;"	c	namespace:__anon60	file:
ElmBdrySides	parma/diffMC/parma_elmBdrySides.cc	/^      ElmBdrySides(apf::Mesh* m) : Sides(m) {$/;"	f	class:parma::ElmBdrySides
ElmBdrySides	parma/diffMC/parma_elmBdrySides.cc	/^  class ElmBdrySides : public Sides {$/;"	c	namespace:parma	file:
ElmGhostFinder	parma/diffMC/parma_ghostWeights.cc	/^      ElmGhostFinder(apf::Mesh* m, apf::MeshTag* w)$/;"	f	class:parma::ElmGhostFinder
ElmGhostFinder	parma/diffMC/parma_ghostWeights.cc	/^  class ElmGhostFinder : public GhostFinder {$/;"	c	namespace:parma	file:
ElmLtSelector	parma/diffMC/parma_ltSelector.cc	/^      ElmLtSelector(apf::Mesh* m, apf::MeshTag* w, double primeMaxW, int primeDim)$/;"	f	class:__anon58::ElmLtSelector
ElmLtSelector	parma/diffMC/parma_ltSelector.cc	/^  class ElmLtSelector : public LtSelector {$/;"	c	namespace:__anon58	file:
ElmLtVtx	parma/diffMC/parma_vtxElmBalancer.cc	/^      ElmLtVtx(apf::Mesh* m, double f, double maxV, int v)$/;"	f	class:__anon71::ElmLtVtx
ElmLtVtx	parma/diffMC/parma_vtxElmBalancer.cc	/^  class ElmLtVtx : public parma::Balancer {$/;"	c	namespace:__anon71	file:
ElmLtVtxEdge	parma/diffMC/parma_elmLtVtxEdgeBalancer.cc	/^      ElmLtVtxEdge(apf::Mesh* m, double f, double maxV, double maxE, int v)$/;"	f	class:__anon66::ElmLtVtxEdge
ElmLtVtxEdge	parma/diffMC/parma_elmLtVtxEdgeBalancer.cc	/^  class ElmLtVtxEdge : public parma::Balancer {$/;"	c	namespace:__anon66	file:
ElmLtVtxEdge	parma/diffMC/parma_elmLtVtxEdgeTargets.cc	/^      ElmLtVtxEdge(Sides* s, Weights* w[3], int sideTol,$/;"	f	class:parma::ElmLtVtxEdge
ElmLtVtxEdge	parma/diffMC/parma_elmLtVtxEdgeTargets.cc	/^  class ElmLtVtxEdge : public Targets {$/;"	c	namespace:parma	file:
ElmLtVtxEdgeSelector	parma/diffMC/parma_elmLtVtxEdgeSelector.cc	/^      ElmLtVtxEdgeSelector(apf::Mesh* m, apf::MeshTag* w, double maxV, double maxE)$/;"	f	class:__anon64::ElmLtVtxEdgeSelector
ElmLtVtxEdgeSelector	parma/diffMC/parma_elmLtVtxEdgeSelector.cc	/^  class ElmLtVtxEdgeSelector : public parma::VtxSelector {$/;"	c	namespace:__anon64	file:
ElmSelector	parma/diffMC/parma_elmSelector.cc	/^      ElmSelector(apf::Mesh* m, apf::MeshTag* w)$/;"	f	class:__anon56::ElmSelector
ElmSelector	parma/diffMC/parma_elmSelector.cc	/^  class ElmSelector : public parma::VtxSelector {$/;"	c	namespace:__anon56	file:
ElmSideSides	parma/diffMC/parma_elmSideSides.cc	/^      ElmSideSides(apf::Mesh* m) : Sides(m) {$/;"	f	class:parma::ElmSideSides
ElmSideSides	parma/diffMC/parma_elmSideSides.cc	/^  class ElmSideSides : public Sides {$/;"	c	namespace:parma	file:
EmptyAdapter	dsp/dspAdapters.cc	/^class EmptyAdapter : public Adapter {$/;"	c	namespace:dsp	file:
EmptySmoother	dsp/dspSmoothers.cc	/^class EmptySmoother : public Smoother {$/;"	c	namespace:dsp	file:
EnsaArrays	phasta/phOutput.h	/^struct EnsaArrays$/;"	s	namespace:ph
EntWeights	parma/diffMC/parma_entWeights.cc	/^  EntWeights::EntWeights(apf::Mesh* m, apf::MeshTag* w, Sides* s, int d) $/;"	f	class:parma::EntWeights
EntWeights	parma/diffMC/parma_entWeights.h	/^  class EntWeights : public Weights {$/;"	c	namespace:parma
Entity	ma/maMesh.h	/^typedef apf::MeshEntity Entity;$/;"	t	namespace:ma
Entity identifiers	mds/mds.tex	/^all entities.$/;"	s
EntityArray	ma/maMesh.h	/^typedef apf::DynamicArray<Entity*> EntityArray;$/;"	t	namespace:ma
EntityIntegration	apf/apfIntegrate.h	/^class EntityIntegration$/;"	c	namespace:apf
EntitySet	apf/apfNumbering.cc	/^typedef std::set<MeshEntity*> EntitySet;$/;"	t	namespace:apf	file:
EntitySet	ma/maMesh.h	/^typedef std::set<Entity*> EntitySet;$/;"	t	namespace:ma
EntitySet	spr/sprRecoverField.cc	/^typedef std::set<apf::MeshEntity*> EntitySet;$/;"	t	namespace:spr	file:
EntityShape	apf/apfShape.h	/^class EntityShape$/;"	c	namespace:apf
EntityVector	apf/apfMesh2.h	/^typedef std::vector<MeshEntity*> EntityVector;$/;"	t	namespace:apf
EntityVector	apf/apfMigrate.cc	/^typedef std::vector<MeshEntity*> EntityVector;$/;"	t	namespace:apf	file:
EntityVector	ma/maLayerCollapse.h	/^typedef std::vector<Entity*> EntityVector;$/;"	t	namespace:ma
EntityVector	pumi/pumi.h	/^typedef apf::EntityVector EntityVector;$/;"	t
Entry	pumi/GenTag.cc	/^typedef Taggable::Entry Entry;$/;"	t	file:
Entry	pumi/GenTag.h	/^    struct Entry$/;"	s	class:Taggable
Error	spr/sprEstimateError.cc	/^    Error(Estimation* e):$/;"	f	class:spr::Error
Error	spr/sprEstimateError.cc	/^class Error : public ElementError$/;"	c	namespace:spr	file:
Error2	spr/sprEstimateError.cc	/^    Error2(Estimation* e):$/;"	f	class:spr::Error2
Error2	spr/sprEstimateError.cc	/^class Error2 : public ElementError$/;"	c	namespace:spr	file:
Estimation	spr/sprEstimateError.cc	/^struct Estimation {$/;"	s	namespace:spr	file:
Estimation	spr/sprEstimateTargetError.cc	/^struct Estimation {$/;"	s	namespace:spr::target	file:
Expand	apf/apfPartition.h	/^  Expand(int nin, int nout):$/;"	f	struct:apf::Expand
Expand	apf/apfPartition.h	/^struct Expand : public Remap$/;"	s	namespace:apf
Expression	test/fusion3.cc	/^class Expression$/;"	c	file:
F	test/poisson.cc	/^    mth::Vector<double> F;$/;"	m	class:__anon17::Poisson	file:
FACE_VERT	crv/crvShapeFixer.h	/^    enum{EDGE_EDGE, FACE_VERT};$/;"	e	enum:crv::CrvLargeAngleTetFixer::__anon102
FACE_VERT	ma/maShape.cc	/^    enum { EDGE_EDGE, FACE_VERT };$/;"	e	enum:ma::LargeAngleTetFixer::__anon26	file:
FIELD_PARAMS	phasta/phIO.c	13;"	d	file:
FIELD_TYPES	pumi/pumi.h	/^  FIELD_TYPES$/;"	e	enum:PUMI_FieldType
FIXED	apf/apfNumbering.cc	/^enum { FIXED = -2, FREE_BUT_NOT_NUMBERED = -1 };$/;"	e	enum:apf::__anon43	file:
FREE_BUT_NOT_NUMBERED	apf/apfNumbering.cc	/^enum { FIXED = -2, FREE_BUT_NOT_NUMBERED = -1 };$/;"	e	enum:apf::__anon43	file:
FaceIteratorSIM	apf_sim/apfSIM.cc	/^    FaceIteratorSIM(pMesh part)$/;"	f	class:apf::FaceIteratorSIM
FaceIteratorSIM	apf_sim/apfSIM.cc	/^class FaceIteratorSIM : public IteratorSIM$/;"	c	namespace:apf	file:
FaceSplit	ma/maFaceSplit.cc	/^FaceSplit::FaceSplit(Adapt* a):$/;"	f	class:ma::FaceSplit
FaceSplit	ma/maFaceSplit.h	/^class FaceSplit$/;"	c	namespace:ma
FaceSplitCollapse	ma/maFaceSplitCollapse.cc	/^  FaceSplitCollapse::FaceSplitCollapse(Adapt* a):$/;"	f	class:ma::FaceSplitCollapse
FaceSplitCollapse	ma/maFaceSplitCollapse.h	/^class FaceSplitCollapse$/;"	c	namespace:ma
FaceVertFixer	ma/maShape.cc	/^    FaceVertFixer(Adapt* a):$/;"	f	class:ma::FaceVertFixer
FaceVertFixer	ma/maShape.cc	/^class FaceVertFixer : public TetFixerBase$/;"	c	namespace:ma	file:
Field	apf/apf.tex	/^\\end{tabular}$/;"	s
Field	apf/apf.tex	/^at the user's request.$/;"	b
Field	apf/apfField.h	/^class Field : public FieldBase$/;"	c	namespace:apf
FieldBCs	phasta/phBC.h	/^struct FieldBCs$/;"	s	namespace:ph
FieldBase	apf/apfField.h	/^class FieldBase$/;"	c	namespace:apf
FieldData	apf/apfFieldData.h	/^class FieldData$/;"	c	namespace:apf
FieldData	ma/maExtrude.cc	/^typedef std::vector<LayerFieldData> FieldData;$/;"	t	namespace:ma::__anon28	file:
FieldDataGetter	ma/maExtrude.cc	/^  FieldDataGetter(apf::Field* f):field(f) {}$/;"	f	struct:ma::__anon28::FieldDataGetter
FieldDataGetter	ma/maExtrude.cc	/^struct FieldDataGetter : public DataGetter {$/;"	s	namespace:ma::__anon28	file:
FieldDataOf	apf/apfFieldData.h	/^class FieldDataOf : public FieldData$/;"	c	namespace:apf
FieldDataSetter	ma/maExtrude.cc	/^  FieldDataSetter(apf::Field* f):field(f) {}$/;"	f	struct:ma::__anon28::FieldDataSetter
FieldDataSetter	ma/maExtrude.cc	/^struct FieldDataSetter : public DataSetter {$/;"	s	namespace:ma::__anon28	file:
FieldOf	apf/apfFieldOf.h	/^class FieldOf : public Field$/;"	c	namespace:apf
FieldOp	apf/apfField.h	/^class FieldOp$/;"	c	namespace:apf
FieldReader	ma/maSize.cc	/^    FieldReader(apf::Field* f)$/;"	f	class:ma::FieldReader
FieldReader	ma/maSize.cc	/^class FieldReader : public IsotropicFunction$/;"	c	namespace:ma	file:
FieldShape	apf/apfShape.h	/^class FieldShape$/;"	c	namespace:apf
FieldTransfer	ma/maSolutionTransfer.cc	/^    FieldTransfer(apf::Field* f)$/;"	f	class:ma::FieldTransfer
FieldTransfer	ma/maSolutionTransfer.cc	/^class FieldTransfer : public SolutionTransfer$/;"	c	namespace:ma	file:
Fields	ma/maExtrude.cc	/^typedef std::vector<apf::Field*> Fields;$/;"	t	namespace:ma::__anon28	file:
FirstProblemPlane	ma/maSnapper.cc	/^FirstProblemPlane::FirstProblemPlane(Adapt* a, Tag* st)$/;"	f	class:ma::FirstProblemPlane
FirstProblemPlane	ma/maSnapper.h	/^class FirstProblemPlane$/;"	c	namespace:ma
FixBySwap	ma/maShape.cc	/^    FixBySwap(Adapt* a):$/;"	f	class:ma::FixBySwap
FixBySwap	ma/maShape.cc	/^class FixBySwap : public TetFixerBase$/;"	c	namespace:ma	file:
FixedMetricIntegrator	ma/maQuality.cc	/^    FixedMetricIntegrator(Mesh* inMesh, const Matrix& inQ):$/;"	f	class:ma::FixedMetricIntegrator
FixedMetricIntegrator	ma/maQuality.cc	/^class FixedMetricIntegrator : public apf::Integrator$/;"	c	namespace:ma	file:
Flexibility	mds/mds.tex	/^applications add at least as many entities as they remove.$/;"	s
Frame	apf/apfGeometry.cc	/^Frame::Frame()$/;"	f	class:apf::Frame
Frame	apf/apfGeometry.cc	/^Frame::Frame(Matrix3x3 const& l, Vector3 const& t):$/;"	f	class:apf::Frame
Frame	apf/apfGeometry.h	/^struct Frame {$/;"	s	namespace:apf
FrameEval	ma/maSize.cc	/^  FrameEval()$/;"	f	struct:ma::FrameEval
FrameEval	ma/maSize.cc	/^  FrameEval(BothEval* b)$/;"	f	struct:ma::FrameEval
FrameEval	ma/maSize.cc	/^struct FrameEval : public apf::Function$/;"	s	namespace:ma	file:
FullLayer	ma/maExtrude.cc	/^struct FullLayer {$/;"	s	namespace:ma::__anon28	file:
Function	apf/apf.h	/^struct Function$/;"	s	namespace:apf
Future work	apf/hierarchic.tex	/^\\]$/;"	s
GBF	test/poisson.cc	/^    apf::NewArray<apf::Vector3> GBF;$/;"	m	class:__anon17::Poisson	file:
GENTAG_H	pumi/GenTag.h	11;"	d
GEOMBC_READ	phasta/phiotimer.h	/^  GEOMBC_READ,$/;"	e	enum:phastaio_file
GEOMBC_WRITE	phasta/phiotimer.h	/^  GEOMBC_WRITE,$/;"	e	enum:phastaio_file
GMI_ANALYTIC_H	gmi/gmi_analytic.h	11;"	d
GMI_BASE_H	gmi/gmi_base.h	11;"	d
GMI_CAP_H	gmi_cap/gmi_cap.h	11;"	d
GMI_H	gmi/gmi.h	11;"	d
GMI_LOOKUP_H	gmi/gmi_lookup.h	12;"	d
GMI_MESH_H	gmi/gmi_mesh.h	11;"	d
GMI_NULL_H	gmi/gmi_null.h	11;"	d
GMI_SIM_H	gmi_sim/gmi_sim.h	11;"	d
GRAPH	zoltan/apfZoltan.h	/^  GRAPH$/;"	e	enum:apf::ZoltanMethod
GRStream	phasta/phstream.cc	/^  struct GRStream{$/;"	s	file:
GT	apf/apfGradientByVolume.cc	/^    typedef typename GradientOf<T>::type GT;$/;"	t	class:apf::GradientIntegrator	file:
GT	apf/apfGradientByVolume.cc	/^    typedef typename GradientOf<T>::type GT;$/;"	t	class:apf::RecoverGradient	file:
GenIterator	pumi/GenIterator.h	/^    GenIterator(const GenIterator<OtherIterator, Entity>& other)$/;"	f	class:GenIterator
GenIterator	pumi/GenIterator.h	/^  class GenIterator$/;"	c
GenIterator	pumi/GenIterator.h	/^inline GenIterator<Iterator, Entity>::GenIterator(const Iterator &begin, const Iterator &end, int dim, int topo, void* argptr, void (*ptr2Func) (Iterator&, Iterator&, void*, int, int))$/;"	f	class:GenIterator
GeomB737	test/capStoneSizeFields.h	/^    GeomB737(ma::Mesh* m, double inFactor)$/;"	f	class:GeomB737
GeomB737	test/capStoneSizeFields.h	/^class GeomB737 : public ma::IsotropicFunction$/;"	c
GeomRobin	test/capStoneSizeFields.h	/^    GeomRobin(ma::Mesh* m, double inFactor)$/;"	f	class:GeomRobin
GeomRobin	test/capStoneSizeFields.h	/^class GeomRobin : public ma::IsotropicFunction$/;"	c
GetCentroidFunction	ma/maTemplates.cc	/^typedef Vector (*GetCentroidFunction)($/;"	t	namespace:ma	file:
GetGradient	apf/apfGradientByVolume.cc	/^class GetGradient<Vector3>$/;"	c	namespace:apf	file:
GetGradient	apf/apfGradientByVolume.cc	/^class GetGradient<double>$/;"	c	namespace:apf	file:
GhostEdgeBalancer	parma/diffMC/parma_ghostElement.cc	/^      GhostEdgeBalancer(apf::Mesh* m, double f, int v)$/;"	f	class:__anon45::GhostEdgeBalancer
GhostEdgeBalancer	parma/diffMC/parma_ghostElement.cc	/^  class GhostEdgeBalancer : public parma::Balancer {$/;"	c	namespace:__anon45	file:
GhostElementFinder	parma/diffMC/parma_ghostMPASWeights.cc	/^      GhostElementFinder(apf::Mesh* m, apf::MeshTag* w, int l, int b)$/;"	f	class:parma::GhostElementFinder
GhostElementFinder	parma/diffMC/parma_ghostMPASWeights.cc	/^  class GhostElementFinder {$/;"	c	namespace:parma	file:
GhostElmBalancer	parma/diffMC/parma_ghost.cc	/^      GhostElmBalancer(apf::Mesh* m, int l, double f, int v)$/;"	f	class:__anon68::GhostElmBalancer
GhostElmBalancer	parma/diffMC/parma_ghost.cc	/^  class GhostElmBalancer : public parma::Balancer {$/;"	c	namespace:__anon68	file:
GhostElmGtVtxBalancer	parma/diffMC/parma_ghost.cc	/^    GhostElmGtVtxBalancer(apf::Mesh* m, int l, double f, int v)$/;"	f	class:GhostElmGtVtxBalancer
GhostElmGtVtxBalancer	parma/diffMC/parma_ghost.cc	/^class GhostElmGtVtxBalancer : public parma::Balancer {$/;"	c	file:
GhostFinder	parma/diffMC/parma_ghostWeights.cc	/^  class GhostFinder {$/;"	c	namespace:parma	file:
GhostMPASWeights	parma/diffMC/parma_ghostMPASWeights.cc	/^      GhostMPASWeights(apf::Mesh* m, apf::MeshTag* wtag, Sides* s, int layers, int bridge)$/;"	f	class:parma::GhostMPASWeights
GhostMPASWeights	parma/diffMC/parma_ghostMPASWeights.cc	/^  class GhostMPASWeights : public Weights {$/;"	c	namespace:parma	file:
GhostToEntWeight	parma/diffMC/parma_ghostWeights.cc	/^      GhostToEntWeight(GhostWeights* gw, int dim)$/;"	f	class:parma::GhostToEntWeight
GhostToEntWeight	parma/diffMC/parma_ghostWeights.cc	/^  class GhostToEntWeight : public Weights {$/;"	c	namespace:parma	file:
GhostVtxLtElmBalancer	parma/diffMC/parma_ghost.cc	/^      GhostVtxLtElmBalancer(apf::Mesh* m, double f, int v, int l)$/;"	f	class:__anon68::GhostVtxLtElmBalancer
GhostVtxLtElmBalancer	parma/diffMC/parma_ghost.cc	/^  class GhostVtxLtElmBalancer : public parma::Balancer {$/;"	c	namespace:__anon68	file:
GhostWeights	parma/diffMC/parma_ghostWeights.cc	/^      GhostWeights(apf::Mesh* m, Sides* s,$/;"	f	class:parma::GhostWeights
GhostWeights	parma/diffMC/parma_ghostWeights.cc	/^  class GhostWeights : public Associative<double*> {$/;"	c	namespace:parma	file:
Ghosting	pumi/pumi.h	/^class Ghosting$/;"	c
Ghosting	pumi/pumi_ghost.cc	/^Ghosting::Ghosting(pMesh mesh, int d)$/;"	f	class:Ghosting
Gid	apf/apfConstruct.cc	/^typedef int Gid;$/;"	t	namespace:apf	file:
GlobalErrorTerm	spr/sprEstimateTargetError.cc	/^    GlobalErrorTerm(Estimation* e) : ElementError(e) {}$/;"	f	class:spr::target::GlobalErrorTerm
GlobalErrorTerm	spr/sprEstimateTargetError.cc	/^class GlobalErrorTerm : public ElementError$/;"	c	namespace:spr::target	file:
GlobalMap	stk/apfSTK.cc	/^typedef std::map<long,Node> GlobalMap;$/;"	t	namespace:apf	file:
GlobalNumbering	apf/apfMesh.h	/^typedef NumberingOf<long> GlobalNumbering;$/;"	t	namespace:apf
GlobalNumbering	apf/apfMixedNumbering.h	/^typedef NumberingOf<long> GlobalNumbering;$/;"	t	namespace:apf
GlobalNumbering	apf/apfNumbering.h	/^typedef NumberingOf<long> GlobalNumbering;$/;"	t	namespace:apf
GlobalToVert	apf/apfConvert.h	/^typedef std::map<int, MeshEntity*> GlobalToVert;$/;"	t	namespace:apf
GlobalToVert	mds/apfMDS.h	/^typedef std::map<int, MeshEntity*> GlobalToVert;$/;"	t	namespace:apf
Globalizer	apf/apfNumbering.cc	/^class Globalizer : public FieldOp$/;"	c	namespace:apf	file:
Goal	apf/attach.tex	/^\\maketitle$/;"	s
GradientIntegrator	apf/apfGradientByVolume.cc	/^    GradientIntegrator(Field* f_in):Integrator(1)$/;"	f	class:apf::GradientIntegrator
GradientIntegrator	apf/apfGradientByVolume.cc	/^class GradientIntegrator : public Integrator$/;"	c	namespace:apf	file:
GradientOf	apf/apfGradientByVolume.cc	/^class GradientOf<Vector3>$/;"	c	namespace:apf	file:
GradientOf	apf/apfGradientByVolume.cc	/^class GradientOf<double>$/;"	c	namespace:apf	file:
Greater	parma/diffMC/parma_distQ.h	/^  struct Greater {$/;"	s	namespace:parma
GregoryCurver	crv/crv.h	/^    GregoryCurver(apf::Mesh2* m, int P, int B)$/;"	f	class:crv::GregoryCurver
GregoryCurver	crv/crv.h	/^class GregoryCurver : public BezierCurver$/;"	c	namespace:crv
GregorySurface4	crv/crvBezier.cc	/^  GregorySurface4() {$/;"	f	class:crv::GregorySurface4
GregorySurface4	crv/crvBezier.cc	/^class GregorySurface4 : public apf::FieldShape$/;"	c	namespace:crv	file:
Grid	mds/apfBox.cc	/^Grid::Grid(int nx, int ny, int nz):$/;"	f	class:apf::Grid
Grid	mds/apfBox.h	/^struct Grid {$/;"	s	namespace:apf
GroupCode	parma/group/parma_group.cc	/^typedef Parma_GroupCode GroupCode;$/;"	t	file:
GroupCode	phasta/condense.cc	/^  struct GroupCode : public Parma_GroupCode {$/;"	s	namespace:__anon85	file:
GroupCode	test/collapse.cc	/^  struct GroupCode : public Parma_GroupCode {$/;"	s	namespace:__anon6	file:
GroupCode	test/fusion.cc	/^struct GroupCode : public Parma_GroupCode$/;"	s	file:
GroupCode	test/fusion2.cc	/^struct GroupCode : public Parma_GroupCode$/;"	s	file:
GroupCode	test/serialize.cc	/^struct GroupCode : public Parma_GroupCode$/;"	s	file:
H0	mds/mds.c	/^static int const H0[] = {MDS_VERTEX,MDS_VERTEX,MDS_VERTEX,MDS_VERTEX$/;"	v	file:
H01	mds/mds.c	/^static int const H01[] = {0,1,1,2,2,3,3,0$/;"	v	file:
H1	mds/mds.c	/^static int const H1[] = {MDS_EDGE,MDS_EDGE,MDS_EDGE,MDS_EDGE$/;"	v	file:
H10	mds/mds.c	/^static int const H10[] = {0,3,0,1,1, 2,2, 3$/;"	v	file:
H12	mds/mds.c	/^static int const H12[] = {3,2, 1, 0$/;"	v	file:
H2	mds/mds.c	/^static int const H2[] = {MDS_QUADRILATERAL,MDS_QUADRILATERAL,MDS_QUADRILATERAL$/;"	v	file:
H21	mds/mds.c	/^static int const H21[] = {0,1,0,2,0,3,0,4$/;"	v	file:
HEX	apf/apfMesh.h	/^      HEX,      \/\/5$/;"	e	enum:apf::Mesh::Type
HEXAHEDRON	phasta/phBlock.h	/^  HEXAHEDRON   = 2,$/;"	e	enum:ph::__anon86
HEdge2	apf/apfHierarchic.cc	/^class HEdge2 : public EntityShape {$/;"	c	namespace:apf	file:
HEdge3	apf/apfHierarchic.cc	/^class HEdge3 : public EntityShape {$/;"	c	namespace:apf	file:
HTetrahedron2	apf/apfHierarchic.cc	/^class HTetrahedron2 : public EntityShape {$/;"	c	namespace:apf	file:
HTriangle2	apf/apfHierarchic.cc	/^class HTriangle2 : public EntityShape {$/;"	c	namespace:apf	file:
HTriangle3	apf/apfHierarchic.cc	/^class HTriangle3 : public EntityShape {$/;"	c	namespace:apf	file:
HVertex	apf/apfHierarchic.cc	/^class HVertex : public EntityShape {$/;"	c	namespace:apf	file:
HYPERGRAPH	zoltan/apfZoltan.h	/^  HYPERGRAPH,$/;"	e	enum:apf::ZoltanMethod
HasAll	apf/apfVtk.h	/^class HasAll : public FieldOp$/;"	c	namespace:apf
HasFlag	ma/maAdapt.cc	/^HasFlag::HasFlag(Adapt* a, int f)$/;"	f	class:ma::HasFlag
HasFlag	ma/maAdapt.h	/^struct HasFlag : public Predicate$/;"	s	namespace:ma
HasTag	ma/maAdapt.cc	/^HasTag::HasTag(Mesh* m, Tag* t)$/;"	f	class:ma::HasTag
HasTag	ma/maAdapt.h	/^struct HasTag : public Predicate$/;"	s	namespace:ma
Hexahedron	apf/apfShape.cc	/^    class Hexahedron : public EntityShape$/;"	c	class:apf::Linear	file:
HexahedronIntegration	apf/apfIntegrate.cc	/^class HexahedronIntegration : public EntityIntegration$/;"	c	namespace:apf	file:
Hierarchic2	apf/apfHierarchic.cc	/^class Hierarchic2 : public FieldShape {$/;"	c	namespace:apf	file:
Hierarchic3	apf/apfHierarchic.cc	/^    Hierarchic3() {}$/;"	f	class:apf::Hierarchic3
Hierarchic3	apf/apfHierarchic.cc	/^class Hierarchic3 : public FieldShape$/;"	c	namespace:apf	file:
HighOrderTransfer	ma/maSolutionTransfer.cc	/^    HighOrderTransfer(apf::Field* f):$/;"	f	class:ma::HighOrderTransfer
HighOrderTransfer	ma/maSolutionTransfer.cc	/^class HighOrderTransfer : public SolutionTransfer$/;"	c	namespace:ma	file:
ID	mds/apfPM.h	/^  int ID; \/\/ debugging purpose$/;"	m	struct:apf::PME
ID	mds/mds.c	292;"	d	file:
INDEX	mds/mds.c	294;"	d	file:
INT	apf/apfMesh.h	/^      INT,$/;"	e	enum:apf::Mesh::TagType
INTERIORTAG	test/icesheet.cc	14;"	d	file:
INTERIOR_REGION	test/icesheet.cc	30;"	d	file:
IPBase	apf/apfIPShape.cc	/^    IPBase(int d, int o):dimension(d),order(o) {$/;"	f	class:apf::IPBase
IPBase	apf/apfIPShape.cc	/^class IPBase : public FieldShape$/;"	c	namespace:apf	file:
IPShape	apf/apfIPShape.cc	/^    IPShape(int d, int o):$/;"	f	class:apf::IPShape
IPShape	apf/apfIPShape.cc	/^class IPShape : public IPBase$/;"	c	namespace:apf	file:
IdentitySizeField	ma/maSize.cc	/^IdentitySizeField::IdentitySizeField(Mesh* m):$/;"	f	class:ma::IdentitySizeField
IdentitySizeField	ma/maSize.h	/^struct IdentitySizeField : public SizeField$/;"	s	namespace:ma
ImbOrMaxNeighbor	parma/diffMC/parma_shapeOptimizer.cc	/^      ImbOrMaxNeighbor(parma::Average* nbAvg, double maxNbTol, int targets, int v=0)$/;"	f	class:__anon47::ImbOrMaxNeighbor
ImbOrMaxNeighbor	parma/diffMC/parma_shapeOptimizer.cc	/^  class ImbOrMaxNeighbor : public parma::Stop {$/;"	c	namespace:__anon47	file:
Implementation	apf/apf.tex	/^\\sum_{a\\in W(\\bar{e})} w_{a,x}(\\xi) \\times f_a\\]$/;"	s
IndependentSetFinder	ma/maCoarsen.cc	/^    IndependentSetFinder(Adapt* a):$/;"	f	class:ma::IndependentSetFinder
IndependentSetFinder	ma/maCoarsen.cc	/^class IndependentSetFinder : public apf::CavityOp$/;"	c	namespace:ma	file:
Indices	mds/apfBox.cc	/^Indices::Indices() : x(0), y(0), z(0) {}$/;"	f	class:apf::Indices
Indices	mds/apfBox.cc	/^Indices::Indices(int a, int b, int c): x(a),y(b),z(c) {}$/;"	f	class:apf::Indices
Indices	mds/apfBox.h	/^struct Indices$/;"	s	namespace:apf
Init	ma/maCollapse.cc	/^void Collapse::Init(Adapt* a)$/;"	f	class:ma::Collapse
Init	ma/maRegionCollapse.cc	/^void RegionCollapse::Init(Adapt* a, double fa)$/;"	f	class:ma::RegionCollapse
Init	ma/maVertRemover.cc	/^void VertRemover::Init(Adapt* a)$/;"	f	class:ma::VertRemover
Input	ma/maInput.h	/^class Input$/;"	c	namespace:ma
Input	phasta/phInput.cc	/^Input::Input()$/;"	f	class:ph::Input
Input	phasta/phInput.h	/^class Input$/;"	c	namespace:ph
Input	test/eigen_test.cc	/^struct Input {$/;"	s	file:
Input and Ouput Meshes	ma/adapt.tex	/^The paper admits that this choice can be made.$/;"	s
IntBC	phasta/phAttrib.cc	/^  IntBC(pAttribute a, pGEntity ge):SimBC(ge)$/;"	f	struct:IntBC
IntBC	phasta/phAttrib.cc	/^struct IntBC : public SimBC$/;"	s	file:
IntMap	phasta/phInput.cc	/^typedef std::map<std::string, int*> IntMap;$/;"	t	namespace:ph	file:
IntTagCAP	apf_cap/apfCAP.cc	/^    IntTagCAP(MeshDatabaseInterface* m, const char* name, int c):$/;"	f	class:apf::IntTagCAP
IntTagCAP	apf_cap/apfCAP.cc	/^class IntTagCAP : public TagCAP$/;"	c	namespace:apf	file:
IntTagSIM	apf_sim/apfSIM.cc	/^    IntTagSIM(pParMesh m, const char* name, int c):$/;"	f	class:apf::IntTagSIM
IntTagSIM	apf_sim/apfSIM.cc	/^class IntTagSIM : public TagSIM$/;"	c	namespace:apf	file:
Integration	apf/apfIntegrate.h	/^class Integration$/;"	c	namespace:apf
IntegrationPoint	apf/apfIntegrate.h	/^  IntegrationPoint(Vector3 const& p, double w):$/;"	f	struct:apf::IntegrationPoint
IntegrationPoint	apf/apfIntegrate.h	/^struct IntegrationPoint$/;"	s	namespace:apf
Integrator	apf/apf.h	/^class Integrator$/;"	c	namespace:apf
Integrator	apf/apfIntegrate.cc	/^Integrator::Integrator(int o):$/;"	f	class:apf::Integrator
Interface	apf/attach.tex	/^being used to define coordinates.$/;"	s
InterfaceConstraint	phasta/phConstraint.cc	/^struct InterfaceConstraint : public Constraint$/;"	s	namespace:ph	file:
InterpolatingCurver	crv/crv.h	/^    InterpolatingCurver(apf::Mesh2* m, int P) : MeshCurver(m,P) {};$/;"	f	class:crv::InterpolatingCurver
InterpolatingCurver	crv/crv.h	/^class InterpolatingCurver : public MeshCurver$/;"	c	namespace:crv
Introduction	apf/hierarchic.tex	/^\\maketitle$/;"	s
IsBadCrvQuality	crv/crvShape.cc	/^  IsBadCrvQuality(Adapt* a_):a(a_)$/;"	f	struct:crv::IsBadCrvQuality
IsBadCrvQuality	crv/crvShape.cc	/^struct IsBadCrvQuality : public ma::Predicate$/;"	s	namespace:crv	file:
IsBadQuality	ma/maShape.cc	/^  IsBadQuality(Adapt* a_):a(a_) {}$/;"	f	struct:ma::IsBadQuality
IsBadQuality	ma/maShape.cc	/^struct IsBadQuality : public Predicate$/;"	s	namespace:ma	file:
IsFalseRebuild	ma/maMatchedCollapse.cc	/^struct IsFalseRebuild {$/;"	s	namespace:ma	file:
IsoSizeField	ma/maSize.cc	/^  IsoSizeField(Mesh* m, IsotropicFunction* f):$/;"	f	struct:ma::IsoSizeField
IsoSizeField	ma/maSize.cc	/^struct IsoSizeField : public AnisoSizeField$/;"	s	namespace:ma	file:
IsoUserField	ma/maSize.cc	/^  IsoUserField(Mesh* m, apf::Field* f):$/;"	f	struct:ma::IsoUserField
IsoUserField	ma/maSize.cc	/^struct IsoUserField : public IsoSizeField$/;"	s	namespace:ma	file:
IsoWrapper	ma/maSize.cc	/^  IsoWrapper(IsotropicFunction* f)$/;"	f	struct:ma::IsoWrapper
IsoWrapper	ma/maSize.cc	/^struct IsoWrapper : public AnisotropicFunction$/;"	s	namespace:ma	file:
IsotropicFunction	ma/maSize.h	/^class IsotropicFunction$/;"	c	namespace:ma
Item	parma/diffMC/parma_associative.h	/^      typedef std::pair<const int, T> Item;$/;"	t	class:parma::Associative
Iterator	ma/maMesh.h	/^typedef apf::MeshIterator Iterator;$/;"	t	namespace:ma
IteratorSIM	apf_sim/apfSIM.cc	/^class IteratorSIM$/;"	c	namespace:apf	file:
K	test/poisson.cc	/^    mth::Matrix<double> K;$/;"	m	class:__anon17::Poisson	file:
KNAPSACK_H_	parma/diffMC/zeroOneKnapsack.h	2;"	d
Kernel functions	apf/hierarchic.tex	/^\\end{align*}$/;"	s
Knapsack	parma/diffMC/zeroOneKnapsack.h	/^typedef void* Knapsack;$/;"	t
KnownBC	phasta/phBC.cc	/^struct KnownBC$/;"	s	namespace:ph	file:
L2Projector	test/hierarchic.cc	/^L2Projector::L2Projector(apf::Mesh* m, int p) {$/;"	f	class:__anon20::L2Projector
L2Projector	test/hierarchic.cc	/^class L2Projector {$/;"	c	namespace:__anon20	file:
LAYER	ma/maAdapt.h	/^  LAYER         = (1<<10),$/;"	e	enum:ma::__anon25
LAYER_BASE	ma/maAdapt.h	/^  LAYER_BASE    = (1<<11),$/;"	e	enum:ma::__anon25
LAYER_TOP	ma/maAdapt.h	/^  LAYER_TOP     = (1<<12),$/;"	e	enum:ma::__anon25
LAYER_UNSNAP	ma/maAdapt.h	/^  LAYER_UNSNAP  = (1<<15),$/;"	e	enum:ma::__anon25
LION_BASE64_H	lion/lionBase64.h	2;"	d
LION_COMPRESS	lion/lionCompress.h	2;"	d
LION_PRINT_H	lion/lionPrint.h	2;"	d
LONG	apf/apfMesh.h	/^      LONG };$/;"	e	enum:apf::Mesh::TagType
LOWER_MASK	parma/diffMC/maximalIndependentSet/mersenne_twister.cc	23;"	d	file:
LagrangeCubic	apf/apfShape.cc	/^    LagrangeCubic() { registerSelf(apf::LagrangeCubic::getName()); }$/;"	f	class:apf::LagrangeCubic
LagrangeCubic	apf/apfShape.cc	/^class LagrangeCubic : public FieldShape$/;"	c	namespace:apf	file:
LagrangeQuadratic	apf/apfShape.cc	/^    LagrangeQuadratic() { registerSelf(apf::LagrangeQuadratic::getName()); }$/;"	f	class:apf::LagrangeQuadratic
LagrangeQuadratic	apf/apfShape.cc	/^class LagrangeQuadratic : public QuadraticBase$/;"	c	namespace:apf	file:
LaplacianSmoother	dsp/dspSmoothers.cc	/^class LaplacianSmoother : public Smoother {$/;"	c	namespace:dsp	file:
LargeAngleTetAligner	ma/maShape.cc	/^    LargeAngleTetAligner(Adapt* a):$/;"	f	class:ma::LargeAngleTetAligner
LargeAngleTetAligner	ma/maShape.cc	/^class LargeAngleTetAligner : public Operator$/;"	c	namespace:ma	file:
LargeAngleTetFixer	ma/maShape.cc	/^    LargeAngleTetFixer(Adapt* a):$/;"	f	class:ma::LargeAngleTetFixer
LargeAngleTetFixer	ma/maShape.cc	/^class LargeAngleTetFixer : public Operator$/;"	c	namespace:ma	file:
LargeAngleTriFixer	ma/maShape.cc	/^    LargeAngleTriFixer(Adapt* a)$/;"	f	class:ma::LargeAngleTriFixer
LargeAngleTriFixer	ma/maShape.cc	/^class LargeAngleTriFixer : public Operator$/;"	c	namespace:ma	file:
Layer	ma/maCrawler.h	/^  typedef std::vector<Entity*> Layer;$/;"	t	struct:ma::Crawler
LayerCollapse	ma/maLayerCollapse.cc	/^LayerCollapse::LayerCollapse(Adapt* a_)$/;"	f	class:ma::LayerCollapse
LayerCollapse	ma/maLayerCollapse.h	/^struct LayerCollapse$/;"	s	namespace:ma
LayerFieldData	ma/maExtrude.cc	/^typedef std::vector<double> LayerFieldData;$/;"	t	namespace:ma::__anon28	file:
LayerNumberer	ma/maCrawler.cc	/^  LayerNumberer(Adapt* a_):$/;"	f	struct:ma::LayerNumberer
LayerNumberer	ma/maCrawler.cc	/^struct LayerNumberer : public Crawler$/;"	s	namespace:ma	file:
LayerSnapper	ma/maLayerSnap.cc	/^  LayerSnapper(Adapt* a_, Tag* t_):$/;"	f	struct:ma::LayerSnapper
LayerSnapper	ma/maLayerSnap.cc	/^struct LayerSnapper : public Crawler$/;"	s	namespace:ma	file:
Layers	ma/maExtrude.cc	/^typedef std::vector<Crawler::Layer> Layers;$/;"	t	namespace:ma::__anon28	file:
Legendre polynomials	apf/hierarchic.tex	/^of kernel functions $\\phi_i$ and barycentric coordinates $A_i$ for elements.$/;"	s
Less	parma/diffMC/parma_distQ.h	/^  struct Less {$/;"	s	namespace:parma
Less	parma/diffMC/parma_stop.h	/^  class Less : public Stop { $/;"	c	namespace:parma
Level	parma/diffMC/parma_components.h	/^  typedef std::set<apf::MeshEntity*> Level;$/;"	t	namespace:parma
Level	parma/diffMC/parma_dijkstra.cc	/^  typedef std::set<apf::MeshEntity*> Level;$/;"	t	namespace:__anon70	file:
Limitations	mds/mds.tex	/^all of these requirements are fulfilled.$/;"	s
Line	apf/apfGeometry.cc	/^Line::Line()$/;"	f	class:apf::Line
Line	apf/apfGeometry.cc	/^Line::Line(Vector3 const& o, Vector3 const& d):$/;"	f	class:apf::Line
Line	apf/apfGeometry.h	/^struct Line {$/;"	s	namespace:apf
LineConstraint	phasta/phConstraint.cc	/^  LineConstraint():$/;"	f	struct:ph::LineConstraint
LineConstraint	phasta/phConstraint.cc	/^struct LineConstraint : public Constraint$/;"	s	namespace:ph	file:
LineConstraintElas	phasta/phConstraint.cc	/^  LineConstraintElas():$/;"	f	struct:ph::LineConstraintElas
LineConstraintElas	phasta/phConstraint.cc	/^struct LineConstraintElas : public Constraint$/;"	s	namespace:ph	file:
LineSegment	apf/apfGeometry.cc	/^LineSegment::LineSegment()$/;"	f	class:apf::LineSegment
LineSegment	apf/apfGeometry.cc	/^LineSegment::LineSegment(Vector3 const& a, Vector3 const& b):$/;"	f	class:apf::LineSegment
LineSegment	apf/apfGeometry.h	/^struct LineSegment {$/;"	s	namespace:apf
Linear	apf/apfShape.cc	/^    Linear() { registerSelf(apf::Linear::getName()); }$/;"	f	class:apf::Linear
Linear	apf/apfShape.cc	/^class Linear : public FieldShape$/;"	c	namespace:apf	file:
Linear	test/curvetest.cc	/^    Linear(ma::Mesh* m)$/;"	f	class:Linear
Linear	test/curvetest.cc	/^class Linear : public ma::IsotropicFunction$/;"	c	file:
Linear	test/dg_ma_test.cc	/^    Linear(ma::Mesh* m)$/;"	f	class:Linear
Linear	test/dg_ma_test.cc	/^class Linear : public ma::IsotropicFunction$/;"	c	file:
Linear	test/ma_test.cc	/^    Linear(ma::Mesh* m)$/;"	f	class:Linear
Linear	test/ma_test.cc	/^class Linear : public ma::IsotropicFunction$/;"	c	file:
Linear Algebra	apf/apf.tex	/^\\section{Implementation}$/;"	b
Linear1	test/capStoneSizeFields.h	/^    Linear1(ma::Mesh* m, double inFactor)$/;"	f	class:Linear1
Linear1	test/capStoneSizeFields.h	/^class Linear1 : public ma::IsotropicFunction$/;"	c
Linear2	test/capStoneSizeFields.h	/^    Linear2(ma::Mesh* m, double inFactor)$/;"	f	class:Linear2
Linear2	test/capStoneSizeFields.h	/^class Linear2 : public ma::IsotropicFunction$/;"	c
Linear3	test/capStoneSizeFields.h	/^    Linear3(ma::Mesh* m, double inFactor)$/;"	f	class:Linear3
Linear3	test/capStoneSizeFields.h	/^class Linear3 : public ma::IsotropicFunction$/;"	c
LinearHandler	ma/maShapeHandler.cc	/^    LinearHandler(Adapt* a)$/;"	f	class:ma::LinearHandler
LinearHandler	ma/maShapeHandler.cc	/^class LinearHandler : public ShapeHandler$/;"	c	namespace:ma	file:
LinearIPFit	apf/apfIPShape.cc	/^    LinearIPFit(int d) : IPBase(d, 2)$/;"	f	class:apf::LinearIPFit
LinearIPFit	apf/apfIPShape.cc	/^class LinearIPFit : public IPBase$/;"	c	namespace:apf	file:
LinearTransfer	ma/maSolutionTransfer.cc	/^    LinearTransfer(apf::Field* f):$/;"	f	class:ma::LinearTransfer
LinearTransfer	ma/maSolutionTransfer.cc	/^class LinearTransfer : public FieldTransfer$/;"	c	namespace:ma	file:
Link	phasta/phLinks.h	/^typedef std::vector<apf::MeshEntity*> Link;$/;"	t	namespace:ph
LinkKey	phasta/phLinks.h	/^  LinkKey(int s, int p):send(s),peer(p) {}$/;"	f	struct:ph::LinkKey
LinkKey	phasta/phLinks.h	/^struct LinkKey$/;"	s	namespace:ph
Links	phasta/phLinks.h	/^typedef std::map<LinkKey, Link> Links;$/;"	t	namespace:ph
List	pumi/pumi_list.h	/^    List():count(0) {}$/;"	f	class:List
List	pumi/pumi_list.h	/^class List$/;"	c
ListIterator	pumi/pumi_list.h	/^    ListIterator():current(0) {}$/;"	f	class:ListIterator
ListIterator	pumi/pumi_list.h	/^    ListIterator(ListMember* p):current(p) {}$/;"	f	class:ListIterator
ListIterator	pumi/pumi_list.h	/^class ListIterator : public std::iterator<std::forward_iterator_tag,T*>$/;"	c
ListMember	pumi/pumi_list.h	/^    ListMember():previous(this),next(this) {}$/;"	f	class:ListMember
ListMember	pumi/pumi_list.h	/^class ListMember$/;"	c
Lobatto functions	apf/hierarchic.tex	/^\\]$/;"	s
LogAnisoSizeField	ma/maSize.cc	/^  LogAnisoSizeField()$/;"	f	struct:ma::LogAnisoSizeField
LogAnisoSizeField	ma/maSize.cc	/^  LogAnisoSizeField(Mesh* m, AnisotropicFunction* f):$/;"	f	struct:ma::LogAnisoSizeField
LogAnisoSizeField	ma/maSize.cc	/^struct LogAnisoSizeField : public MetricSizeField$/;"	s	namespace:ma	file:
LogMEval	ma/maSize.cc	/^  LogMEval()$/;"	f	struct:ma::LogMEval
LogMEval	ma/maSize.cc	/^  LogMEval(AnisotropicFunction* f)$/;"	f	struct:ma::LogMEval
LogMEval	ma/maSize.cc	/^struct LogMEval : public apf::Function$/;"	s	namespace:ma	file:
LongTagSIM	apf_sim/apfSIM.cc	/^    LongTagSIM(pParMesh m, const char* name, int c):$/;"	f	class:apf::LongTagSIM
LongTagSIM	apf_sim/apfSIM.cc	/^class LongTagSIM : public TagSIM$/;"	c	namespace:apf	file:
LtSelector	parma/diffMC/parma_ltSelector.cc	/^      LtSelector(apf::Mesh* m, apf::MeshTag* w, double primeMaxW, int primeDim)$/;"	f	class:__anon58::LtSelector
LtSelector	parma/diffMC/parma_ltSelector.cc	/^  class LtSelector : public parma::VtxSelector {$/;"	c	namespace:__anon58	file:
M	parma/diffMC/maximalIndependentSet/mersenne_twister.cc	20;"	d	file:
M	parma/diffMC/zeroOneKnapsack.c	/^    size_t **M;$/;"	m	struct:zeroOneKnapsack	file:
M	test/hierarchic.cc	/^    mth::Matrix<double> M;$/;"	m	class:__anon20::L2Projector	file:
MAGIC	phasta/phIO.c	12;"	d	file:
MATRIX	apf/apf.h	/^  MATRIX,$/;"	e	enum:apf::ValueType
MATRIX_A	parma/diffMC/maximalIndependentSet/mersenne_twister.cc	21;"	d	file:
MAX	ma/maQuality.cc	/^enum {MIN, MAX};$/;"	e	enum:ma::__anon29	file:
MAX	pcu/pcu_coll.c	16;"	d	file:
MAX_BLOCK_KEYS	phasta/phBlock.h	/^  MAX_BLOCK_KEYS = 12$/;"	e	enum:ph::__anon87
MAX_ELEM_NODES	mds/mdsANSYS.cc	11;"	d	file:
MAX_ENTITIES	mds/mds_smb.c	50;"	d	file:
MAX_ORDER	crv/crv.h	/^static unsigned const MAX_ORDER = 19;$/;"	m	namespace:crv
MAX_PARAMS	phasta/phGeomBC.cc	/^  MAX_PARAMS = 12$/;"	e	enum:ph::__anon93	file:
MAX_PEERS	mds/mds_smb.c	51;"	d	file:
MAX_SUBTYPES	gmi/agm.c	/^enum { MAX_SUBTYPES = 4 };$/;"	e	enum:__anon44	file:
MAX_TAGS	mds/mds_smb.c	52;"	d	file:
MAX_VERTS	ma/maEdgeSwap.cc	27;"	d	file:
MA_ADAPT_H	ma/maAdapt.h	11;"	d
MA_AFFINE_H	ma/maAffine.h	12;"	d
MA_BALANCE	ma/maBalance.h	2;"	d
MA_COARSEN_H	ma/maCoarsen.h	11;"	d
MA_COLLAPSE_H	ma/maCollapse.h	11;"	d
MA_CRAWLER_H	ma/maCrawler.h	2;"	d
MA_DBG_H	ma/maDBG.h	11;"	d
MA_DOUBLESPLITCOLLAPSE_H	ma/maDoubleSplitCollapse.h	11;"	d
MA_EDGESWAP_H	ma/maEdgeSwap.h	11;"	d
MA_EXTRUDE_H	ma/maExtrude.h	2;"	d
MA_FACESPLITCOLLAPSE_H	ma/maFaceSplitCollapse.h	11;"	d
MA_FACE_SPLIT_H	ma/maFaceSplit.h	11;"	d
MA_H	ma/ma.h	11;"	d
MA_INPUT_H	ma/maInput.h	11;"	d
MA_LAYER_COLLAPSE_H	ma/maLayerCollapse.h	3;"	d
MA_LAYER_H	ma/maLayer.h	2;"	d
MA_MAP_H	ma/maMap.h	12;"	d
MA_MATCHED_COLLAPSE_H	ma/maMatchedCollapse.h	11;"	d
MA_MATCHED_SNAPPER_H	ma/maMatchedSnapper.h	11;"	d
MA_MATCH_H	ma/maMatch.h	11;"	d
MA_MESH_H	ma/maMesh.h	11;"	d
MA_MODIFIER_H	ma/maOperator.h	11;"	d
MA_REFINE_H	ma/maRefine.h	11;"	d
MA_REGION_COLLAPSE_H	ma/maRegionCollapse.h	11;"	d
MA_REPOSITION_H	ma/maReposition.h	2;"	d
MA_SHAPE	ma/maShape.h	11;"	d
MA_SHAPEHANDLER_H	ma/maShapeHandler.h	2;"	d
MA_SHORTEDGEREMOVER_H	ma/maShortEdgeRemover.h	11;"	d
MA_SIZE_H	ma/maSize.h	11;"	d
MA_SNAPPER_H	ma/maSnapper.h	11;"	d
MA_SNAP_H	ma/maSnap.h	11;"	d
MA_SOLUTIONTRANSFER_H	ma/maSolutionTransfer.h	11;"	d
MA_SPLIT_H	ma/maSplits.h	11;"	d
MA_STATS_H	ma/maStats.h	11;"	d
MA_TABLES_H	ma/maTables.h	11;"	d
MA_TEMPLATES_H	ma/maTemplates.h	2;"	d
MA_TETRAHEDRONIZE_H	ma/maTetrahedronize.h	2;"	d
MA_VERTREMOVER_H	ma/maVertRemover.h	11;"	d
MDS_APF_H	mds/mds_apf.h	12;"	d
MDS_EDGE	mds/mds.h	/^  MDS_EDGE,$/;"	e	enum:__anon100
MDS_H	mds/mds.h	12;"	d
MDS_HEXAHEDRON	mds/mds.h	/^  MDS_HEXAHEDRON,$/;"	e	enum:__anon100
MDS_LINKS_INIT	mds/mds_net.h	37;"	d
MDS_LIVE	mds/mds.h	31;"	d
MDS_NET_H	mds/mds_net.h	12;"	d
MDS_NONE	mds/mds.h	30;"	d
MDS_PYRAMID	mds/mds.h	/^  MDS_PYRAMID,$/;"	e	enum:__anon100
MDS_QUADRILATERAL	mds/mds.h	/^  MDS_QUADRILATERAL,$/;"	e	enum:__anon100
MDS_TAG_H	mds/mds_tag.h	12;"	d
MDS_TETRAHEDRON	mds/mds.h	/^  MDS_TETRAHEDRON,$/;"	e	enum:__anon100
MDS_TRIANGLE	mds/mds.h	/^  MDS_TRIANGLE,$/;"	e	enum:__anon100
MDS_TYPES	mds/mds.h	/^  MDS_TYPES$/;"	e	enum:__anon100
MDS_VERTEX	mds/mds.h	/^  MDS_VERTEX,$/;"	e	enum:__anon100
MDS_WEDGE	mds/mds.h	/^  MDS_WEDGE,$/;"	e	enum:__anon100
MERSENNE_TWISTER_H	parma/diffMC/maximalIndependentSet/mersenne_twister.h	2;"	d
MILLION	phasta/phiotimer.cc	12;"	d	file:
MIN	ma/maQuality.cc	/^enum {MIN, MAX};$/;"	e	enum:ma::__anon29	file:
MIN	pcu/pcu_coll.c	15;"	d	file:
MIS	apf/apfMIS.cc	/^  MIS::MIS(Mesh* mesh, int vtx_dim_, int edge_dim_)$/;"	f	class:apf::MIS
MIS	apf/apfMIS.h	/^  class MIS {$/;"	c	namespace:apf
MIS_FAIL	parma/diffMC/maximalIndependentSet/mis.h	19;"	d
MIS_FAIL_IF	parma/diffMC/maximalIndependentSet/mis.h	22;"	d
MIS_H_	parma/diffMC/maximalIndependentSet/mis.h	2;"	d
MIS_ITERATE	parma/diffMC/maximalIndependentSet/mis.h	15;"	d
MPART_ENTITY_CONTAINER_H	pumi/mPartEntityContainer.h	11;"	d
MPASGhostBalancer	parma/diffMC/parma_ghostMPAS.cc	/^      MPASGhostBalancer(apf::Mesh* m, int l, int b, double f, int v)$/;"	f	class:__anon67::MPASGhostBalancer
MPASGhostBalancer	parma/diffMC/parma_ghostMPAS.cc	/^  class MPASGhostBalancer : public parma::Balancer {$/;"	c	namespace:__anon67	file:
MTH_AD_H	mth/mthAD.h	2;"	d
MTH_DEF_H	mth/mth_def.h	12;"	d
MTH_H	mth/mth.h	12;"	d
MTH_MATRIX_H	mth/mthMatrix.h	12;"	d
MTH_QR_H	mth/mthQR.h	2;"	d
MTH_TENSOR_H	mth/mthTensor.h	12;"	d
MTH_VECTOR_H	mth/mthVector.h	12;"	d
M_numVerticesInClosure	phasta/phInterfaceCutter.cc	/^int M_numVerticesInClosure(pMesh mesh, pGEntity model){$/;"	f	namespace:ph
Make	phasta/phConstraint.cc	/^typedef Constraint* (*Make)(double* values);$/;"	t	namespace:ph	file:
Map	phasta/phBC.h	/^  typedef std::map<std::string, FieldBCs> Map;$/;"	t	struct:ph::BCs
Map	phasta/phBlock.h	/^  typedef std::map<BlockKey, int> Map;$/;"	t	struct:ph::BlocksCommon
Map	stk/apfAlbany.h	/^  typedef std::map<apf::ModelEntity*, StkModel*> Map;$/;"	t	struct:apf::StkModels
Match	apf/apfMesh.h	/^typedef Copy Match;$/;"	t	namespace:apf
MatchedCollapse	ma/maMatchedCollapse.cc	/^MatchedCollapse::MatchedCollapse(Adapt* a):$/;"	f	class:ma::MatchedCollapse
MatchedCollapse	ma/maMatchedCollapse.h	/^struct MatchedCollapse$/;"	s	namespace:ma
MatchedEdgeCollapser	ma/maCoarsen.cc	/^    MatchedEdgeCollapser(Adapt* a, int md):$/;"	f	class:ma::MatchedEdgeCollapser
MatchedEdgeCollapser	ma/maCoarsen.cc	/^class MatchedEdgeCollapser : public Operator$/;"	c	namespace:ma	file:
MatchedSharing	apf/apfMesh.cc	/^MatchedSharing::MatchedSharing(Mesh* m):$/;"	f	class:apf::MatchedSharing
MatchedSharing	apf/apfMesh.h	/^struct MatchedSharing : public Sharing$/;"	s	namespace:apf
MatchedSnapper	ma/maMatchedSnapper.cc	/^MatchedSnapper::MatchedSnapper(Adapt* a, Tag* st, bool is)$/;"	f	class:ma::MatchedSnapper
MatchedSnapper	ma/maMatchedSnapper.h	/^class MatchedSnapper$/;"	c	namespace:ma
Matches	apf/apfMesh.h	/^typedef CopyArray Matches;$/;"	t	namespace:apf
MaterialMap	phasta/phInterfaceCutter.cc	/^typedef std::map<gmi_ent*, int> MaterialMap;$/;"	t	namespace:ph	file:
MaterialSet	phasta/phInterfaceCutter.cc	/^typedef std::set<int> MaterialSet;$/;"	t	namespace:ph	file:
Matrix	apf/apfMatrix.h	/^    Matrix() {}$/;"	f	class:apf::Matrix
Matrix	apf/apfMatrix.h	/^    Matrix(Vector<N> const* vectors)$/;"	f	class:apf::Matrix
Matrix	apf/apfMatrix.h	/^    Matrix(double const (*array)[N])$/;"	f	class:apf::Matrix
Matrix	apf/apfMatrix.h	/^class Matrix : public Array<Vector<N>,M>$/;"	c	namespace:apf
Matrix	ma/maMesh.h	/^typedef apf::Matrix3x3 Matrix;$/;"	t	namespace:ma
Matrix	ma/maSize.h	/^typedef apf::Matrix3x3 Matrix;$/;"	t	namespace:ma
Matrix	mth/mthMatrix.h	/^    Matrix() : columns(0) {}$/;"	f	class:mth::Matrix
Matrix	mth/mthMatrix.h	/^    Matrix() {}$/;"	f	class:mth::Matrix
Matrix	mth/mthMatrix.h	/^    Matrix(unsigned m, unsigned n) : columns(n), elems(m*n) {}$/;"	f	class:mth::Matrix
Matrix	mth/mthMatrix.h	/^    Matrix(unsigned m, unsigned n) { (void) m; (void) n; }$/;"	f	class:mth::Matrix
Matrix	mth/mthMatrix.h	/^class Matrix : public can::Array<Vector<T,N>,M>$/;"	c	namespace:mth
Matrix	mth/mthMatrix.h	/^class Matrix<T,0,0>$/;"	c	namespace:mth
Matrix3x3	apf/apfMatrix.h	/^    Matrix3x3() {}$/;"	f	class:apf::Matrix3x3
Matrix3x3	apf/apfMatrix.h	/^    Matrix3x3(Matrix<3,3> const& other):$/;"	f	class:apf::Matrix3x3
Matrix3x3	apf/apfMatrix.h	/^    Matrix3x3(double a11, double a12, double a13,$/;"	f	class:apf::Matrix3x3
Matrix3x3	apf/apfMatrix.h	/^class Matrix3x3 : public Matrix<3,3>$/;"	c	namespace:apf
Matrix3x3	mth/mthMatrix.h	/^    Matrix3x3($/;"	f	class:mth::Matrix3x3
Matrix3x3	mth/mthMatrix.h	/^    Matrix3x3() {}$/;"	f	class:mth::Matrix3x3
Matrix3x3	mth/mthMatrix.h	/^    Matrix3x3(Matrix<T,3,3> const& other) : Matrix<T,3,3>(other) {}$/;"	f	class:mth::Matrix3x3
Matrix3x3	mth/mthMatrix.h	/^class Matrix3x3 : public Matrix<T,3,3>$/;"	c	namespace:mth
MatrixDerivIntegrator	test/test_matrix_grad.cc	/^    MatrixDerivIntegrator(int order, apf::Field* nodal_matrix_fld, apf::Field * matrix_deriv_fld) : Integrator(order), matrix_fld(nodal_matrix_fld), matrix_deriv_fld(matrix_deriv_fld) {}$/;"	f	class:MatrixDerivIntegrator
MatrixDerivIntegrator	test/test_matrix_grad.cc	/^class MatrixDerivIntegrator : public apf::Integrator$/;"	c	file:
MatrixElement	apf/apfMatrixElement.h	/^class MatrixElement : public ElementOf<Matrix3x3>$/;"	c	namespace:apf
MatrixElement	apf/apfMatrixField.cc	/^MatrixElement::MatrixElement(MatrixField* f, MeshElement* e):$/;"	f	class:apf::MatrixElement
MatrixField	apf/apfMatrixField.h	/^class MatrixField : public FieldOf<Matrix3x3>$/;"	c	namespace:apf
Measurer	apf/apfIntegrate.cc	/^    Measurer(int order):Integrator(order),m(0) {}$/;"	f	class:apf::Measurer
Measurer	apf/apfIntegrate.cc	/^class Measurer : public Integrator$/;"	c	namespace:apf	file:
Mesh	apf/apfMesh.h	/^class Mesh$/;"	c	namespace:apf
Mesh	ma/maMesh.h	/^typedef apf::Mesh2 Mesh;$/;"	t	namespace:ma
Mesh Data Structure	mds/mds.tex	/^\\maketitle$/;"	s
Mesh2	apf/apfMesh2.h	/^class Mesh2 : public Mesh$/;"	c	namespace:apf
MeshCAP	apf_cap/apfCAP.cc	/^MeshCAP::MeshCAP(MeshDatabaseInterface* mdb, GeometryDatabaseInterface* gdb):$/;"	f	class:apf::MeshCAP
MeshCAP	apf_cap/apfCAP.h	/^class MeshCAP : public Mesh2$/;"	c	namespace:apf
MeshCurver	crv/crv.h	/^    MeshCurver(apf::Mesh2* m, int P) : m_mesh(m), m_order(P) {};$/;"	f	class:crv::MeshCurver
MeshCurver	crv/crv.h	/^class MeshCurver$/;"	c	namespace:crv
MeshElement	apf/apf.h	/^typedef VectorElement MeshElement;$/;"	t	namespace:apf
MeshInfo	test/icesheet.cc	/^struct MeshInfo {$/;"	s	file:
MeshMDS	mds/apfMDS.cc	/^    MeshMDS()$/;"	f	class:apf::MeshMDS
MeshMDS	mds/apfMDS.cc	/^    MeshMDS(gmi_model* m, Mesh* from, $/;"	f	class:apf::MeshMDS
MeshMDS	mds/apfMDS.cc	/^    MeshMDS(gmi_model* m, const char* pathname)$/;"	f	class:apf::MeshMDS
MeshMDS	mds/apfMDS.cc	/^    MeshMDS(gmi_model* m, int d, bool isMatched_)$/;"	f	class:apf::MeshMDS
MeshMDS	mds/apfMDS.cc	/^class MeshMDS : public Mesh2$/;"	c	namespace:apf	file:
MeshSIM	apf_sim/apfSIM.cc	/^MeshSIM::MeshSIM(pParMesh m):$/;"	f	class:apf::MeshSIM
MeshSIM	apf_sim/apfSIM.h	/^class MeshSIM : public Mesh2$/;"	c	namespace:apf
MetricSizeField	ma/maSize.cc	/^struct MetricSizeField : public SizeField$/;"	s	namespace:ma	file:
Mid	parma/diffMC/parma_vtxSelector.h	/^  typedef std::map<int,double> Mid;$/;"	t	namespace:parma
Midd	parma/diffMC/parma_elmLtVtxEdgeSelector.cc	/^  typedef std::map<int, dtwo> Midd;$/;"	t	namespace:__anon64	file:
Migr	parma/diffMC/parma_edgeEqVtxSelector.cc	/^      typedef std::pair<int,double> Migr;$/;"	t	class:__anon52::EdgeEqVtx	file:
Migr	parma/diffMC/parma_elmLtVtxEdgeSelector.cc	/^        Migr(int i, double v, double e) :$/;"	f	struct:__anon64::ElmLtVtxEdgeSelector::Migr
Migr	parma/diffMC/parma_elmLtVtxEdgeSelector.cc	/^      struct Migr {$/;"	s	class:__anon64::ElmLtVtxEdgeSelector	file:
Migr	parma/diffMC/parma_ltSelector.cc	/^      typedef std::pair<int,double> Migr;$/;"	t	class:__anon58::LtSelector	file:
MigrComm	parma/diffMC/parma_elmLtVtxEdgeSelector.cc	/^      typedef std::set<Migr,CompareMigr> MigrComm;$/;"	t	class:__anon64::ElmLtVtxEdgeSelector	file:
Migration	apf/apfMesh.cc	/^Migration::Migration(Mesh* m)$/;"	f	class:apf::Migration
Migration	apf/apfMesh.cc	/^Migration::Migration(Mesh* m, MeshTag* existingTag)$/;"	f	class:apf::Migration
Migration	apf/apfMesh.h	/^class Migration$/;"	c	namespace:apf
Migration	pumi/pumi.h	/^typedef apf::Migration Migration;$/;"	t
Model	ma/maMesh.h	/^typedef apf::ModelEntity Model;$/;"	t	namespace:ma
ModelEdgeTags	mds/apfMDS.cc	/^typedef std::map<std::pair<int, int>, int> ModelEdgeTags;$/;"	t	file:
ModelExtrusion	ma/maExtrude.h	/^  ModelExtrusion():$/;"	f	struct:ma::ModelExtrusion
ModelExtrusion	ma/maExtrude.h	/^  ModelExtrusion(Model* a, Model* b, Model* c):$/;"	f	struct:ma::ModelExtrusion
ModelExtrusion	ma/maExtrude.h	/^struct ModelExtrusion {$/;"	s	namespace:ma
ModelExtrusions	ma/maExtrude.h	/^typedef std::vector<ModelExtrusion> ModelExtrusions;$/;"	t	namespace:ma
ModelMatching	phasta/phFilterMatching.cc	/^typedef std::map<gmi_ent*, ModelSet> ModelMatching;$/;"	t	namespace:ph	file:
ModelSet	ma/maExtrude.cc	/^typedef std::set<Model*> ModelSet;$/;"	t	namespace:ma::__anon28	file:
ModelSet	phasta/phFilterMatching.cc	/^typedef std::set<gmi_ent*> ModelSet;$/;"	t	namespace:ph	file:
Modulo	apf/apfPartition.h	/^  Modulo(int n):by(n) {}$/;"	f	struct:apf::Modulo
Modulo	apf/apfPartition.h	/^struct Modulo : public Remap$/;"	s	namespace:apf
Multiply	apf/apfPartition.h	/^  Multiply(int n):by(n) {}$/;"	f	struct:apf::Multiply
Multiply	apf/apfPartition.h	/^struct Multiply : public Remap$/;"	s	namespace:apf
MultiplyOp	apf/apfFieldData.cc	/^    MultiplyOp(FieldDataOf<T>* ld, T d,$/;"	f	class:apf::MultiplyOp
MultiplyOp	apf/apfFieldData.cc	/^class MultiplyOp : public FieldOp$/;"	c	namespace:apf	file:
MyFunction	dsp/dspAdapters.cc	/^    MyFunction(double s):size(s) {}$/;"	f	class:dsp::UniformAdapter::MyFunction
MyFunction	dsp/dspAdapters.cc	/^  class MyFunction : public ma::IsotropicFunction {$/;"	c	class:dsp::UniformAdapter	file:
N	parma/diffMC/maximalIndependentSet/mersenne_twister.cc	19;"	d	file:
N1	apf/apfIntegrate.cc	/^    class N1 : public Integration$/;"	c	class:apf::EdgeIntegration	file:
N1	apf/apfIntegrate.cc	/^    class N1 : public Integration$/;"	c	class:apf::HexahedronIntegration	file:
N1	apf/apfIntegrate.cc	/^    class N1 : public Integration$/;"	c	class:apf::PrismIntegration	file:
N1	apf/apfIntegrate.cc	/^    class N1 : public Integration$/;"	c	class:apf::PyramidIntegration	file:
N1	apf/apfIntegrate.cc	/^    class N1 : public Integration$/;"	c	class:apf::QuadIntegration	file:
N1	apf/apfIntegrate.cc	/^    class N1 : public Integration$/;"	c	class:apf::TetrahedronIntegration	file:
N1	apf/apfIntegrate.cc	/^    class N1 : public Integration$/;"	c	class:apf::TriangleIntegration	file:
N2	apf/apfIntegrate.cc	/^    class N2 : public Integration$/;"	c	class:apf::EdgeIntegration	file:
N2	apf/apfIntegrate.cc	/^    class N2 : public Integration$/;"	c	class:apf::HexahedronIntegration	file:
N2	apf/apfIntegrate.cc	/^    class N2 : public Integration$/;"	c	class:apf::QuadIntegration	file:
N2	apf/apfIntegrate.cc	/^    class N2 : public Integration$/;"	c	class:apf::TetrahedronIntegration	file:
N2	apf/apfIntegrate.cc	/^    class N2 : public Integration$/;"	c	class:apf::TriangleIntegration	file:
N3	apf/apfIntegrate.cc	/^    class N3 : public Integration$/;"	c	class:apf::EdgeIntegration	file:
N3	apf/apfIntegrate.cc	/^    class N3 : public Integration$/;"	c	class:apf::QuadIntegration	file:
N3	apf/apfIntegrate.cc	/^    class N3 : public Integration$/;"	c	class:apf::TetrahedronIntegration	file:
N3	apf/apfIntegrate.cc	/^    class N3 : public Integration$/;"	c	class:apf::TriangleIntegration	file:
N4	apf/apfIntegrate.cc	/^    class N4 : public Integration$/;"	c	class:apf::EdgeIntegration	file:
N4	apf/apfIntegrate.cc	/^    class N4 : public Integration$/;"	c	class:apf::TetrahedronIntegration	file:
N4	apf/apfIntegrate.cc	/^    class N4 : public Integration$/;"	c	class:apf::TriangleIntegration	file:
N5	apf/apfIntegrate.cc	/^    class N5 : public Integration$/;"	c	class:apf::EdgeIntegration	file:
N5	apf/apfIntegrate.cc	/^    class N5 : public Integration$/;"	c	class:apf::TetrahedronIntegration	file:
N5	apf/apfIntegrate.cc	/^    class N5 : public Integration$/;"	c	class:apf::TriangleIntegration	file:
N6	apf/apfIntegrate.cc	/^    class N6 : public Integration$/;"	c	class:apf::EdgeIntegration	file:
N6	apf/apfIntegrate.cc	/^    class N6 : public Integration$/;"	c	class:apf::TetrahedronIntegration	file:
N6	apf/apfIntegrate.cc	/^    class N6 : public Integration$/;"	c	class:apf::TriangleIntegration	file:
N7	apf/apfIntegrate.cc	/^    class N7 : public Integration$/;"	c	class:apf::TetrahedronIntegration	file:
NINPUTS	test/eigen_test.cc	11;"	d	file:
NODES_PARAM	phasta/phIO.c	/^NODES_PARAM,$/;"	e	enum:__anon80	file:
NOTO_MALLOC	pcu/noto/noto_malloc.h	16;"	d
NOTO_MALLOC_H	pcu/noto/noto_malloc.h	11;"	d
NUM_PHASTAIO_MODES	phasta/phiotimer.h	/^  NUM_PHASTAIO_MODES$/;"	e	enum:phastaio_file
NaiveOrder	apf/apfNumbering.h	/^inline int NaiveOrder(Numbering * num) { return naiveOrder(num); }$/;"	f	namespace:apf
NewArray	apf/apfNew.h	/^    NewArray() {}$/;"	f	class:apf::NewArray
NewArray	apf/apfNew.h	/^    NewArray(std::size_t n):Base(n) {}$/;"	f	class:apf::NewArray
NewArray	apf/apfNew.h	/^class NewArray : public can::NewArray<T> {$/;"	c	namespace:apf
NewArray	can/canNewArray.h	/^    NewArray() {}$/;"	f	class:can::NewArray
NewArray	can/canNewArray.h	/^    NewArray(std::size_t n) : Array<T,0>(n) {}$/;"	f	class:can::NewArray
NewArray	can/canNewArray.h	/^class NewArray : public Array<T,0>$/;"	c	namespace:can
NewEntities	ma/maAdapt.h	/^class NewEntities : public apf::BuildCallback$/;"	c	namespace:ma
Nijk	crv/crvQuality.cc	/^static double Nijk(apf::NewArray<apf::Vector3>& nodes,$/;"	f	namespace:crv
Nijkl	crv/crvQuality.cc	/^static double Nijkl(apf::NewArray<apf::Vector3>& nodes,$/;"	f	namespace:crv
NoSharing	apf/apfNumbering.cc	/^struct NoSharing : public Sharing$/;"	s	namespace:apf	file:
NodalBridge	stk/apfSTK.cc	/^    NodalBridge(Field* f,$/;"	f	class:apf::NodalBridge
NodalBridge	stk/apfSTK.cc	/^class NodalBridge : public StkBridge$/;"	c	namespace:apf	file:
Node	apf/apfNumbering.h	/^  Node():entity(0),node(0) {}$/;"	f	struct:apf::Node
Node	apf/apfNumbering.h	/^  Node(MeshEntity* e, int n):entity(e),node(n) {}$/;"	f	struct:apf::Node
Node	apf/apfNumbering.h	/^struct Node$/;"	s	namespace:apf
Node	mds/mdsGmsh.cc	/^  Node() { entity = 0; }$/;"	f	struct:__anon96::Node
Node	mds/mdsGmsh.cc	/^struct Node {$/;"	s	namespace:__anon96	file:
NodeSet	stk/apfAlbany.h	/^typedef std::vector<apf::Node> NodeSet;$/;"	t	namespace:apf
NodeSets	stk/apfAlbany.h	/^typedef std::map<std::string, NodeSet> NodeSets;$/;"	t	namespace:apf
Nodes	mds/mdsANSYS.cc	/^typedef std::map<int, apf::Vector3> Nodes;$/;"	t	namespace:apf	file:
NormalSharing	apf/apfMesh.cc	/^NormalSharing::NormalSharing(Mesh* m):mesh(m) {}$/;"	f	class:apf::NormalSharing
NormalSharing	apf/apfMesh.h	/^struct NormalSharing : public Sharing$/;"	s	namespace:apf
Notation	apf/apf.tex	/^are included, called modules.$/;"	s
Numbering	apf/apfMesh.h	/^typedef NumberingOf<int> Numbering;$/;"	t	namespace:apf
NumberingOf	apf/apfNumbering.cc	/^NumberingOf<T>::NumberingOf()$/;"	f	class:apf::NumberingOf
NumberingOf	apf/apfNumberingClass.h	/^class NumberingOf : public FieldBase$/;"	c	namespace:apf
OK	apf/apfCavityOp.h	/^      OK,$/;"	e	enum:apf::CavityOp::Outcome
OK_QUALITY	ma/maAdapt.h	/^  OK_QUALITY    = (1<< 6),$/;"	e	enum:ma::__anon25
Omega_h	omega_h/apfOmega_h.h	/^namespace Omega_h {$/;"	n
Operator	ma/maOperator.h	/^class Operator$/;"	c	namespace:ma
Optimization	ma/adapt.tex	/^through repeated migration.$/;"	s
Outcome	apf/apfCavityOp.h	/^    enum Outcome {$/;"	g	class:apf::CavityOp
Output	phasta/phOutput.h	/^struct Output$/;"	s	namespace:ph
Overview	apf/apf.tex	/^\\maketitle$/;"	s
Overview	apf/cavity.tex	/^\\maketitle$/;"	s
Overview	ma/adapt.tex	/^\\maketitle$/;"	s
Overview	spr/spr.tex	/^\\maketitle$/;"	s
Ownership	pumi/pumi.h	/^typedef apf::Sharing Ownership;$/;"	t
P	crv/crvBezier.cc	/^static int P = 1;$/;"	m	namespace:crv	file:
P0	mds/mds.c	/^static int const P0[] = {MDS_VERTEX,MDS_VERTEX,MDS_VERTEX,MDS_VERTEX$/;"	v	file:
P01	mds/mds.c	/^static int const P01[] = {0,1,1,2$/;"	v	file:
P1	mds/mds.c	/^static int const P1[] = {MDS_EDGE,MDS_EDGE,MDS_EDGE,MDS_EDGE$/;"	v	file:
P10	mds/mds.c	/^static int const P10[] = {0,3,0,1$/;"	v	file:
P12	mds/mds.c	/^static int const P12[] = {0,1,2,3$/;"	v	file:
P2	mds/mds.c	/^static int const P2[] = {MDS_QUADRILATERAL$/;"	v	file:
P21	mds/mds.c	/^static int const P21[] = {0,1,0,2,0,3$/;"	v	file:
PACKED	apf/apf.h	/^  PACKED,$/;"	e	enum:apf::ValueType
PARMA_ASSOCIATIVE_H	parma/diffMC/parma_associative.h	2;"	d
PARMA_BALANCER_H	parma/diffMC/parma_balancer.h	2;"	d
PARMA_BDRYVTX_H_	parma/diffMC/parma_bdryVtx.h	2;"	d
PARMA_CENTROIDS_H	parma/diffMC/parma_centroids.h	2;"	d
PARMA_COMMONS_H_	parma/diffMC/parma_commons.h	2;"	d
PARMA_COMPONENTS_H_	parma/diffMC/parma_components.h	2;"	d
PARMA_CONVERT_H_	parma/diffMC/parma_convert.h	2;"	d
PARMA_DCPART_H_	parma/diffMC/parma_dcpart.h	2;"	d
PARMA_DIJKSTRA_H_	parma/diffMC/parma_dijkstra.h	2;"	d
PARMA_DISTQ_H_	parma/diffMC/parma_distQ.h	2;"	d
PARMA_ENTWEIGHTS_H	parma/diffMC/parma_entWeights.h	2;"	d
PARMA_GHOSTOWNER_H	parma/diffMC/parma_ghostOwner.h	2;"	d
PARMA_GRAPHDIST_H_	parma/diffMC/parma_graphDist.h	2;"	d
PARMA_H	parma/parma.h	9;"	d
PARMA_MESHAUX_H_	parma/diffMC/parma_meshaux.h	2;"	d
PARMA_MONITOR_H	parma/diffMC/parma_monitor.h	2;"	d
PARMA_RIB_H	parma/rib/parma_rib.h	2;"	d
PARMA_SELECTOR_H	parma/diffMC/parma_selector.h	2;"	d
PARMA_SIDES_H	parma/diffMC/parma_sides.h	2;"	d
PARMA_STEP_H	parma/diffMC/parma_step.h	2;"	d
PARMA_STOP_H	parma/diffMC/parma_stop.h	2;"	d
PARMA_TARGETS_H	parma/diffMC/parma_targets.h	2;"	d
PARMA_VTXSELECTOR_H	parma/diffMC/parma_vtxSelector.h	2;"	d
PARMA_WEIGHTS_H	parma/diffMC/parma_weights.h	2;"	d
PARMETIS	zoltan/apfZoltan.h	/^  PARMETIS,$/;"	e	enum:apf::ZoltanMethod
PARTITION	zoltan/apfZoltan.h	/^  PARTITION,$/;"	e	enum:apf::ZoltanApproach
PART_GEOM	zoltan/apfZoltan.h	/^  PART_GEOM,$/;"	e	enum:apf::ZoltanApproach
PART_GEOM_KWAY	zoltan/apfZoltan.h	/^  PART_GEOM_KWAY,$/;"	e	enum:apf::ZoltanApproach
PART_KWAY	zoltan/apfZoltan.h	/^  PART_KWAY,$/;"	e	enum:apf::ZoltanApproach
PCU_AA_H	pcu/pcu_aa.h	11;"	d
PCU_ALWAYS_ASSERT	pcu/pcu_util.h	25;"	d
PCU_ALWAYS_ASSERT_VERBOSE	pcu/pcu_util.h	35;"	d
PCU_Add_Double	pcu/pcu.c	/^double PCU_Add_Double(double x)$/;"	f
PCU_Add_Doubles	pcu/pcu.c	/^void PCU_Add_Doubles(double* p, size_t n)$/;"	f
PCU_Add_Int	pcu/pcu.c	/^int PCU_Add_Int(int x)$/;"	f
PCU_Add_Ints	pcu/pcu.c	/^void PCU_Add_Ints(int* p, size_t n)$/;"	f
PCU_Add_Long	pcu/pcu.c	/^long PCU_Add_Long(long x)$/;"	f
PCU_Add_Longs	pcu/pcu.c	/^void PCU_Add_Longs(long* p, size_t n)$/;"	f
PCU_Add_SizeT	pcu/pcu.c	/^size_t PCU_Add_SizeT(size_t x)$/;"	f
PCU_Add_SizeTs	pcu/pcu.c	/^void PCU_Add_SizeTs(size_t* p, size_t n)$/;"	f
PCU_And	pcu/pcu.c	/^int PCU_And(int c)$/;"	f
PCU_Assert_Fail	pcu/pcu_util.c	/^void PCU_Assert_Fail(const char* msg) {$/;"	f
PCU_BIG_ENDIAN	pcu/pcu_byteorder.h	/^  PCU_BIG_ENDIAN = 0x00010203ul$/;"	e	enum:__anon41
PCU_BIG_ENDIAN	pcu/pcu_io.c	243;"	d	file:
PCU_BYTEORDER_H	pcu/pcu_byteorder.h	4;"	d
PCU_Barrier	pcu/pcu.c	/^void PCU_Barrier(void)$/;"	f
PCU_COLL_H	pcu/pcu_coll.h	11;"	d
PCU_COMM_PACK	pcu/PCU.h	39;"	d
PCU_COMM_UNPACK	pcu/PCU.h	47;"	d
PCU_COMM_WRITE	pcu/PCU.h	89;"	d
PCU_Comm_Begin	pcu/pcu.c	/^void PCU_Comm_Begin(void)$/;"	f
PCU_Comm_Extract	pcu/pcu.c	/^void* PCU_Comm_Extract(size_t size)$/;"	f
PCU_Comm_Free	pcu/pcu.c	/^int PCU_Comm_Free(void)$/;"	f
PCU_Comm_From	pcu/pcu.c	/^int PCU_Comm_From(int* from_rank)$/;"	f
PCU_Comm_Init	pcu/pcu.c	/^int PCU_Comm_Init(void)$/;"	f
PCU_Comm_Initialized	pcu/pcu.c	/^bool PCU_Comm_Initialized(void)$/;"	f
PCU_Comm_Listen	pcu/pcu.c	/^bool PCU_Comm_Listen(void)$/;"	f
PCU_Comm_Order	pcu/pcu.c	/^void PCU_Comm_Order(bool on)$/;"	f
PCU_Comm_Pack	pcu/pcu.c	/^int PCU_Comm_Pack(int to_rank, const void* data, size_t size)$/;"	f
PCU_Comm_Packed	pcu/pcu.c	/^int PCU_Comm_Packed(int to_rank, size_t* size)$/;"	f
PCU_Comm_Peers	pcu/pcu.c	/^int PCU_Comm_Peers(void)$/;"	f
PCU_Comm_Rank	pcu/pcu.c	/^int PCU_Comm_Rank(int* rank)$/;"	f
PCU_Comm_Read	pcu/pcu.c	/^bool PCU_Comm_Read(int* from_rank, void** data, size_t* size)$/;"	f
PCU_Comm_Receive	pcu/pcu.c	/^bool PCU_Comm_Receive(void)$/;"	f
PCU_Comm_Received	pcu/pcu.c	/^int PCU_Comm_Received(size_t* size)$/;"	f
PCU_Comm_Self	pcu/pcu.c	/^int PCU_Comm_Self(void)$/;"	f
PCU_Comm_Send	pcu/pcu.c	/^int PCU_Comm_Send(void)$/;"	f
PCU_Comm_Sender	pcu/pcu.c	/^int PCU_Comm_Sender(void)$/;"	f
PCU_Comm_Size	pcu/pcu.c	/^int PCU_Comm_Size(int* size)$/;"	f
PCU_Comm_Start	pcu/pcu.c	/^int PCU_Comm_Start(PCU_Method method)$/;"	f
PCU_Comm_Unpack	pcu/pcu.c	/^int PCU_Comm_Unpack(void* data, size_t size)$/;"	f
PCU_Comm_Unpacked	pcu/pcu.c	/^bool PCU_Comm_Unpacked(void)$/;"	f
PCU_Comm_Write	pcu/pcu.c	/^int PCU_Comm_Write(int to_rank, const void* data, size_t size)$/;"	f
PCU_DEBUG_ASSERT	pcu/pcu_util.h	46;"	d
PCU_DEBUG_ASSERT	pcu/pcu_util.h	49;"	d
PCU_DEBUG_ASSERT_VERBOSE	pcu/pcu_util.h	47;"	d
PCU_DEBUG_ASSERT_VERBOSE	pcu/pcu_util.h	51;"	d
PCU_Debug_Open	pcu/pcu.c	/^void PCU_Debug_Open(void)$/;"	f
PCU_Debug_Print	pcu/pcu.c	/^void PCU_Debug_Print(const char* format, ...)$/;"	f
PCU_ENCODED_ENDIAN	pcu/pcu_io.c	244;"	d	file:
PCU_ENDIANNESS	pcu/pcu_io.c	242;"	d	file:
PCU_Exscan_Int	pcu/pcu.c	/^int PCU_Exscan_Int(int x)$/;"	f
PCU_Exscan_Ints	pcu/pcu.c	/^void PCU_Exscan_Ints(int* p, size_t n)$/;"	f
PCU_Exscan_Long	pcu/pcu.c	/^long PCU_Exscan_Long(long x)$/;"	f
PCU_Exscan_Longs	pcu/pcu.c	/^void PCU_Exscan_Longs(long* p, size_t n)$/;"	f
PCU_FAILURE	pcu/PCU.h	14;"	d
PCU_GLOBAL_METHOD	pcu/PCU.h	/^enum PCU_Method { PCU_GLOBAL_METHOD, PCU_LOCAL_METHOD };$/;"	e	enum:PCU_Method
PCU_GLOBAL_METHOD	pcu/PCU.h	/^typedef enum { PCU_GLOBAL_METHOD, PCU_LOCAL_METHOD } PCU_Method;$/;"	e	enum:__anon37
PCU_Get_Comm	pcu/pcu.c	/^MPI_Comm PCU_Get_Comm(void)$/;"	f
PCU_H	pcu/PCU.h	11;"	d
PCU_HOST_ORDER	pcu/pcu_byteorder.h	23;"	d
PCU_IO_H	pcu/pcu_io.h	11;"	d
PCU_LITTLE_ENDIAN	pcu/pcu_byteorder.h	/^  PCU_LITTLE_ENDIAN = 0x03020100ul,$/;"	e	enum:__anon41
PCU_LOCAL_METHOD	pcu/PCU.h	/^enum PCU_Method { PCU_GLOBAL_METHOD, PCU_LOCAL_METHOD };$/;"	e	enum:PCU_Method
PCU_LOCAL_METHOD	pcu/PCU.h	/^typedef enum { PCU_GLOBAL_METHOD, PCU_LOCAL_METHOD } PCU_Method;$/;"	e	enum:__anon37
PCU_MEMORY_H	pcu/pcu_buffer.h	11;"	d
PCU_MPI_H	pcu/pcu_mpi.h	11;"	d
PCU_MSG_H	pcu/pcu_msg.h	11;"	d
PCU_MSG_PACK	pcu/pcu_msg.h	50;"	d
PCU_MSG_UNPACK	pcu/pcu_msg.h	56;"	d
PCU_Max_Double	pcu/pcu.c	/^double PCU_Max_Double(double x)$/;"	f
PCU_Max_Doubles	pcu/pcu.c	/^void PCU_Max_Doubles(double* p, size_t n)$/;"	f
PCU_Max_Int	pcu/pcu.c	/^int PCU_Max_Int(int x)$/;"	f
PCU_Max_Ints	pcu/pcu.c	/^void PCU_Max_Ints(int* p, size_t n)$/;"	f
PCU_Max_SizeT	pcu/pcu.c	/^size_t PCU_Max_SizeT(size_t x) {$/;"	f
PCU_Max_SizeTs	pcu/pcu.c	/^void PCU_Max_SizeTs(size_t* p, size_t n) {$/;"	f
PCU_Method	pcu/PCU.h	/^enum PCU_Method { PCU_GLOBAL_METHOD, PCU_LOCAL_METHOD };$/;"	g
PCU_Method	pcu/PCU.h	/^typedef enum { PCU_GLOBAL_METHOD, PCU_LOCAL_METHOD } PCU_Method;$/;"	t	typeref:enum:__anon37
PCU_Min_Double	pcu/pcu.c	/^double PCU_Min_Double(double x)$/;"	f
PCU_Min_Doubles	pcu/pcu.c	/^void PCU_Min_Doubles(double* p, size_t n)$/;"	f
PCU_Min_Int	pcu/pcu.c	/^int PCU_Min_Int(int x)$/;"	f
PCU_Min_Ints	pcu/pcu.c	/^void PCU_Min_Ints(int* p, size_t n)$/;"	f
PCU_Min_SizeT	pcu/pcu.c	/^size_t PCU_Min_SizeT(size_t x) {$/;"	f
PCU_Min_SizeTs	pcu/pcu.c	/^void PCU_Min_SizeTs(size_t* p, size_t n) {$/;"	f
PCU_ORDER_H	pcu/pcu_order.h	11;"	d
PCU_Or	pcu/pcu.c	/^int PCU_Or(int c)$/;"	f
PCU_PMPI_H	pcu/pcu_pmpi.h	11;"	d
PCU_Proc_Peers	pcu/pcu.c	/^int PCU_Proc_Peers(void)$/;"	f
PCU_Proc_Self	pcu/pcu.c	/^int PCU_Proc_Self(void)$/;"	f
PCU_Protect	pcu/pcu.c	/^void PCU_Protect(void)$/;"	f
PCU_READ_UNSIGNED	pcu/pcu_io.h	29;"	d
PCU_SUCCESS	pcu/PCU.h	13;"	d
PCU_Switch_Comm	pcu/pcu.c	/^void PCU_Switch_Comm(MPI_Comm new_comm)$/;"	f
PCU_Time	pcu/pcu.c	/^double PCU_Time(void)$/;"	f
PCU_UTIL_H	pcu/pcu_util.h	11;"	d
PCU_WRITE_UNSIGNED	pcu/pcu_io.h	31;"	d
PERFECT_TET_QUALITY	ma/maReposition.cc	29;"	d	file:
PERFECT_TRIANGLE_QUALITY	ma/maReposition.cc	27;"	d	file:
PERIMETERFACE	test/icesheet.cc	24;"	d	file:
PERIMETERTAG	test/icesheet.cc	17;"	d	file:
PHASTAIO_CLOSETIME	phasta/phiotimer.h	41;"	d
PHASTAIO_OPENTIME	phasta/phiotimer.h	32;"	d
PHASTAIO_READTIME	phasta/phiotimer.h	12;"	d
PHASTAIO_WRITETIME	phasta/phiotimer.h	22;"	d
PHASTA_CHEF_H	phasta/phastaChef.h	2;"	d
PHGROWTHCURVES_H	phasta/phGrowthCurves.h	2;"	d
PHIOTIMER_H	phasta/phiotimer.h	2;"	d
PHSTREAM_H_	phasta/phstream.h	2;"	d
PHSTREAM_TIMERS_ON	phasta/phstream.cc	9;"	d	file:
PH_ADAPT_H	phasta/phAdapt.h	2;"	d
PH_ADJACENT_H	phasta/phAdjacent.h	2;"	d
PH_ATTRIB_H	phasta/phAttrib.h	2;"	d
PH_AXISYMMETRY_H	phasta/phAxisymmetry.h	2;"	d
PH_BC_H	phasta/phBC.h	2;"	d
PH_BLOCK_H	phasta/phBlock.h	2;"	d
PH_BUBBLE_H	phasta/phBubble.h	2;"	d
PH_FILTER_MATCHING_H	phasta/phFilterMatching.h	2;"	d
PH_H	phasta/ph.h	2;"	d
PH_INPUT_H	phasta/phInput.h	2;"	d
PH_INTERFACE_CUTTER_H	phasta/phInterfaceCutter.h	2;"	d
PH_IO_H	phasta/phIO.h	2;"	d
PH_LINE	phasta/phIO.c	11;"	d	file:
PH_LINKS_H	phasta/phLinks.h	2;"	d
PH_MODEL_GEOMETRY_H	phasta/phModelGeometry.h	2;"	d
PH_OUTPUT_H	phasta/phOutput.h	2;"	d
PH_PARTITION	phasta/phPartition.h	2;"	d
PH_RESTART_H	phasta/phRestart.h	2;"	d
PH_STRATEGIES	phasta/phAdapt.h	/^  PH_STRATEGIES = 9$/;"	e	enum:ph::__anon82
PH_STRATEGY_UR	phasta/phAdapt.h	/^  PH_STRATEGY_UR = 7,$/;"	e	enum:ph::__anon82
PI	test/visualizeAnisoSizes.cc	/^static double PI = 3.14159265359;$/;"	v	file:
PM	mds/apfPM.h	/^typedef std::set<PME> PM;$/;"	t	namespace:apf
PME	mds/apfPM.h	/^  PME(int n, Parts const& i, int o)$/;"	f	struct:apf::PME
PME	mds/apfPM.h	/^struct PME$/;"	s	namespace:apf
PRISM	apf/apfMesh.h	/^      PRISM,    \/\/6$/;"	e	enum:apf::Mesh::Type
PUMI_BAD_ARRAY_DIMENSION	pumi/pumi_errorcode.h	/^  PUMI_BAD_ARRAY_DIMENSION,$/;"	e	enum:PUMI_ErrCode
PUMI_BAD_ARRAY_SIZE	pumi/pumi_errorcode.h	/^  PUMI_BAD_ARRAY_SIZE,$/;"	e	enum:PUMI_ErrCode
PUMI_BAD_TYPE_AND_TOPO	pumi/pumi_errorcode.h	/^  PUMI_BAD_TYPE_AND_TOPO,$/;"	e	enum:PUMI_ErrCode
PUMI_BYTE	pumi/GenTag.h	/^              \/*6*\/ PUMI_STR,   \/*7*\/ PUMI_BYTE, \/*8*\/ PUMI_TAGTYPES};$/;"	e	enum:PUMI_TagType
PUMI_CB_ERROR	pumi/pumi_errorcode.h	/^  PUMI_CB_ERROR$/;"	e	enum:PUMI_ErrCode
PUMI_DBL	pumi/GenTag.h	/^enum PUMI_TagType {\/*0*\/ PUMI_DBL, \/*1*\/ PUMI_INT, \/*2*\/ PUMI_LONG,$/;"	e	enum:PUMI_TagType
PUMI_EDGE	pumi/pumi.h	/^  PUMI_EDGE,   \/\/ 1 $/;"	e	enum:PUMI_EntTopology
PUMI_ENT	pumi/GenTag.h	/^              \/*3*\/ PUMI_ENT,   \/*4*\/ PUMI_SET,  \/*5*\/ PUMI_PTR,$/;"	e	enum:PUMI_TagType
PUMI_ENTITY_ALREADY_EXISTS	pumi/pumi_errorcode.h	/^  PUMI_ENTITY_ALREADY_EXISTS,$/;"	e	enum:PUMI_ErrCode
PUMI_ENTITY_CREATION_ERROR	pumi/pumi_errorcode.h	/^  PUMI_ENTITY_CREATION_ERROR,$/;"	e	enum:PUMI_ErrCode
PUMI_ENTITY_NOT_FOUND	pumi/pumi_errorcode.h	/^  PUMI_ENTITY_NOT_FOUND,$/;"	e	enum:PUMI_ErrCode
PUMI_EntTopology	pumi/pumi.h	/^enum PUMI_EntTopology {$/;"	g
PUMI_ErrCode	pumi/pumi_errorcode.h	/^ enum PUMI_ErrCode { \/* general or common errors *\/$/;"	g
PUMI_FAILURE	pumi/pumi_errorcode.h	/^  PUMI_FAILURE, $/;"	e	enum:PUMI_ErrCode
PUMI_FILE_NOT_FOUND	pumi/pumi_errorcode.h	/^  PUMI_FILE_NOT_FOUND,$/;"	e	enum:PUMI_ErrCode
PUMI_FILE_WRITE_ERROR	pumi/pumi_errorcode.h	/^  PUMI_FILE_WRITE_ERROR,$/;"	e	enum:PUMI_ErrCode
PUMI_FieldType	pumi/pumi.h	/^enum PUMI_FieldType {$/;"	g
PUMI_GHOST_NOT_FOUND	pumi/pumi_errorcode.h	/^  PUMI_GHOST_NOT_FOUND,$/;"	e	enum:PUMI_ErrCode
PUMI_H	pumi/pumi.h	11;"	d
PUMI_HEX	pumi/pumi.h	/^  PUMI_HEX,  \/\/ 5 $/;"	e	enum:PUMI_EntTopology
PUMI_INT	pumi/GenTag.h	/^enum PUMI_TagType {\/*0*\/ PUMI_DBL, \/*1*\/ PUMI_INT, \/*2*\/ PUMI_LONG,$/;"	e	enum:PUMI_TagType
PUMI_INVALID_ARGUMENT	pumi/pumi_errorcode.h	/^  PUMI_INVALID_ARGUMENT,$/;"	e	enum:PUMI_ErrCode
PUMI_INVALID_ENTITY_COUNT	pumi/pumi_errorcode.h	/^  PUMI_INVALID_ENTITY_COUNT,$/;"	e	enum:PUMI_ErrCode
PUMI_INVALID_ENTITY_HANDLE	pumi/pumi_errorcode.h	/^  PUMI_INVALID_ENTITY_HANDLE,$/;"	e	enum:PUMI_ErrCode
PUMI_INVALID_ENTITY_TOPO	pumi/pumi_errorcode.h	/^  PUMI_INVALID_ENTITY_TOPO,$/;"	e	enum:PUMI_ErrCode
PUMI_INVALID_ENTITY_TYPE	pumi/pumi_errorcode.h	/^  PUMI_INVALID_ENTITY_TYPE,$/;"	e	enum:PUMI_ErrCode
PUMI_INVALID_GEOM_CLAS	pumi/pumi_errorcode.h	/^  PUMI_INVALID_GEOM_CLAS,$/;"	e	enum:PUMI_ErrCode
PUMI_INVALID_GEOM_MODEL	pumi/pumi_errorcode.h	/^  PUMI_INVALID_GEOM_MODEL,$/;"	e	enum:PUMI_ErrCode
PUMI_INVALID_ITERATOR	pumi/pumi_errorcode.h	/^  PUMI_INVALID_ITERATOR,$/;"	e	enum:PUMI_ErrCode
PUMI_INVALID_MATCH	pumi/pumi_errorcode.h	/^  PUMI_INVALID_MATCH,$/;"	e	enum:PUMI_ErrCode
PUMI_INVALID_MESH_INSTANCE	pumi/pumi_errorcode.h	/^  PUMI_INVALID_MESH_INSTANCE,$/;"	e	enum:PUMI_ErrCode
PUMI_INVALID_PART_HANDLE	pumi/pumi_errorcode.h	/^  PUMI_INVALID_PART_HANDLE, $/;"	e	enum:PUMI_ErrCode
PUMI_INVALID_PART_ID	pumi/pumi_errorcode.h	/^  PUMI_INVALID_PART_ID,$/;"	e	enum:PUMI_ErrCode
PUMI_INVALID_PTN_CLAS	pumi/pumi_errorcode.h	/^  PUMI_INVALID_PTN_CLAS,$/;"	e	enum:PUMI_ErrCode
PUMI_INVALID_REMOTE	pumi/pumi_errorcode.h	/^  PUMI_INVALID_REMOTE,$/;"	e	enum:PUMI_ErrCode
PUMI_INVALID_SET_HANDLE	pumi/pumi_errorcode.h	/^  PUMI_INVALID_SET_HANDLE,$/;"	e	enum:PUMI_ErrCode
PUMI_INVALID_SET_TYPE	pumi/pumi_errorcode.h	/^  PUMI_INVALID_SET_TYPE,$/;"	e	enum:PUMI_ErrCode
PUMI_INVALID_TAG_HANDLE	pumi/pumi_errorcode.h	/^  PUMI_INVALID_TAG_HANDLE,$/;"	e	enum:PUMI_ErrCode
PUMI_INVALID_TAG_TYPE	pumi/pumi_errorcode.h	/^  PUMI_INVALID_TAG_TYPE,$/;"	e	enum:PUMI_ErrCode
PUMI_LIST_H	pumi/pumi_list.h	11;"	d
PUMI_LONG	pumi/GenTag.h	/^enum PUMI_TagType {\/*0*\/ PUMI_DBL, \/*1*\/ PUMI_INT, \/*2*\/ PUMI_LONG,$/;"	e	enum:PUMI_TagType
PUMI_MATRIX	pumi/pumi.h	/^  PUMI_MATRIX, \/\/ a 3x3 matrix $/;"	e	enum:PUMI_FieldType
PUMI_MEMORY_ALLOCATION_FAILED	pumi/pumi_errorcode.h	/^  PUMI_MEMORY_ALLOCATION_FAILED,$/;"	e	enum:PUMI_ErrCode
PUMI_MESH_ALREADY_LOADED	pumi/pumi_errorcode.h	/^  PUMI_MESH_ALREADY_LOADED,$/;"	e	enum:PUMI_ErrCode
PUMI_NOT_SUPPORTED	pumi/pumi_errorcode.h	/^  PUMI_NOT_SUPPORTED,$/;"	e	enum:PUMI_ErrCode
PUMI_NULL_ARRAY	pumi/pumi_errorcode.h	/^  PUMI_NULL_ARRAY,$/;"	e	enum:PUMI_ErrCode
PUMI_PACKED	pumi/pumi.h	/^  PUMI_PACKED, \/\/ a user-defined set of components$/;"	e	enum:PUMI_FieldType
PUMI_PRISM	pumi/pumi.h	/^  PUMI_PRISM, \/\/ 6$/;"	e	enum:PUMI_EntTopology
PUMI_PTR	pumi/GenTag.h	/^              \/*3*\/ PUMI_ENT,   \/*4*\/ PUMI_SET,  \/*5*\/ PUMI_PTR,$/;"	e	enum:PUMI_TagType
PUMI_PYRAMID	pumi/pumi.h	/^  PUMI_PYRAMID, \/\/ 7$/;"	e	enum:PUMI_EntTopology
PUMI_QUAD	pumi/pumi.h	/^  PUMI_QUAD, \/\/ 3$/;"	e	enum:PUMI_EntTopology
PUMI_REMOTE_NOT_FOUND	pumi/pumi_errorcode.h	/^  PUMI_REMOTE_NOT_FOUND,$/;"	e	enum:PUMI_ErrCode
PUMI_SCALAR	pumi/pumi.h	/^  PUMI_SCALAR, \/\/  a single scalar value$/;"	e	enum:PUMI_FieldType
PUMI_SET	pumi/GenTag.h	/^              \/*3*\/ PUMI_ENT,   \/*4*\/ PUMI_SET,  \/*5*\/ PUMI_PTR,$/;"	e	enum:PUMI_TagType
PUMI_STR	pumi/GenTag.h	/^              \/*6*\/ PUMI_STR,   \/*7*\/ PUMI_BYTE, \/*8*\/ PUMI_TAGTYPES};$/;"	e	enum:PUMI_TagType
PUMI_SUCCESS	pumi/pumi_errorcode.h	/^  PUMI_SUCCESS = 0, \/\/ no error$/;"	e	enum:PUMI_ErrCode
PUMI_TAGTYPES	pumi/GenTag.h	/^              \/*6*\/ PUMI_STR,   \/*7*\/ PUMI_BYTE, \/*8*\/ PUMI_TAGTYPES};$/;"	e	enum:PUMI_TagType
PUMI_TAG_ALREADY_EXISTS	pumi/pumi_errorcode.h	/^  PUMI_TAG_ALREADY_EXISTS,$/;"	e	enum:PUMI_ErrCode
PUMI_TAG_IN_USE	pumi/pumi_errorcode.h	/^  PUMI_TAG_IN_USE, \/\/ try to delete a tag that is in use$/;"	e	enum:PUMI_ErrCode
PUMI_TAG_NOT_FOUND	pumi/pumi_errorcode.h	/^  PUMI_TAG_NOT_FOUND,$/;"	e	enum:PUMI_ErrCode
PUMI_TET	pumi/pumi.h	/^  PUMI_TET,  \/\/ 4$/;"	e	enum:PUMI_EntTopology
PUMI_TRIANGLE	pumi/pumi.h	/^  PUMI_TRIANGLE, \/\/ 2 $/;"	e	enum:PUMI_EntTopology
PUMI_TagType	pumi/GenTag.h	/^enum PUMI_TagType {\/*0*\/ PUMI_DBL, \/*1*\/ PUMI_INT, \/*2*\/ PUMI_LONG,$/;"	g
PUMI_VECTOR	pumi/pumi.h	/^  PUMI_VECTOR, \/\/ a 3D vector$/;"	e	enum:PUMI_FieldType
PUMI_VERSION_H	pumi/pumi_version.h	2;"	d
PUMI_VERTEX	pumi/pumi.h	/^  PUMI_VERTEX, \/\/ 0 $/;"	e	enum:PUMI_EntTopology
PYRAMID	apf/apfMesh.h	/^      PYRAMID,  \/\/7$/;"	e	enum:apf::Mesh::Type
PYRAMID	phasta/phBlock.h	/^  PYRAMID      = 5,$/;"	e	enum:ph::__anon86
PYRAMID_QUAD	phasta/phBlock.h	/^  PYRAMID_QUAD = 5,$/;"	e	enum:ph::__anon86
PYRAMID_TRI	phasta/phBlock.h	/^  PYRAMID_TRI  = 6,$/;"	e	enum:ph::__anon86
PackedField	apf/apfPackedField.h	/^    PackedField(int c):components(c) {}$/;"	f	class:apf::PackedField
PackedField	apf/apfPackedField.h	/^class PackedField : public Field$/;"	c	namespace:apf
Parma_BfsReorder	parma/diffMC/parma_graphDist.cc	/^apf::MeshTag* Parma_BfsReorder(apf::Mesh* m, int) {$/;"	f
Parma_GetDisconnectedStats	parma/parma.cc	/^void Parma_GetDisconnectedStats(apf::Mesh* m, int& max, double& avg, int& loc) {$/;"	f
Parma_GetEntImbalance	parma/parma.cc	/^void Parma_GetEntImbalance(apf::Mesh* mesh, double (*entImb)[4]) {$/;"	f
Parma_GetMdlBdryVtxStats	parma/parma.cc	/^void Parma_GetMdlBdryVtxStats(apf::Mesh* m, int& loc, long& tot, int& min,$/;"	f
Parma_GetNeighborStats	parma/parma.cc	/^void Parma_GetNeighborStats(apf::Mesh* m, int& max, int& numMaxParts,$/;"	f
Parma_GetOwnedBdryVtxStats	parma/parma.cc	/^void Parma_GetOwnedBdryVtxStats(apf::Mesh* m, int& loc, long& tot, int& min,$/;"	f
Parma_GetSharedBdryVtxStats	parma/parma.cc	/^void Parma_GetSharedBdryVtxStats(apf::Mesh* m, int& loc, long& tot, int& min,$/;"	f
Parma_GetSmallestSideMaxNeighborParts	parma/parma.cc	/^int Parma_GetSmallestSideMaxNeighborParts(apf::Mesh* m) {$/;"	f
Parma_GetWeightedEntImbalance	parma/parma.cc	/^double Parma_GetWeightedEntImbalance(apf::Mesh* m, apf::MeshTag* w,$/;"	f
Parma_GetWeightedEntImbalance	parma/parma.cc	/^void Parma_GetWeightedEntImbalance(apf::Mesh* mesh, apf::MeshTag* w,$/;"	f
Parma_GroupCode	parma/parma.h	/^struct Parma_GroupCode$/;"	s
Parma_MakeCentroidDiffuser	parma/diffMC/parma_centroidDiffuser.cc	/^apf::Balancer* Parma_MakeCentroidDiffuser(apf::Mesh* m,$/;"	f
Parma_MakeElmBalancer	parma/diffMC/parma_elmBalancer.cc	/^apf::Balancer* Parma_MakeElmBalancer(apf::Mesh* m,$/;"	f
Parma_MakeGhostDiffuser	parma/diffMC/parma_ghost.cc	/^apf::Balancer* Parma_MakeGhostDiffuser(apf::Mesh* m,$/;"	f
Parma_MakeGhostEdgeDiffuser	parma/diffMC/parma_ghostElement.cc	/^apf::Balancer* Parma_MakeGhostEdgeDiffuser(apf::Mesh* m,$/;"	f
Parma_MakeMPASDiffuser	parma/diffMC/parma_ghostMPAS.cc	/^apf::Balancer* Parma_MakeMPASDiffuser(apf::Mesh* m,$/;"	f
Parma_MakeRibSplitter	parma/rib/parma_mesh_rib.cc	/^apf::Splitter* Parma_MakeRibSplitter(apf::Mesh* m, bool sync)$/;"	f
Parma_MakeShapeOptimizer	parma/diffMC/parma_shapeOptimizer.cc	/^apf::Balancer* Parma_MakeShapeOptimizer(apf::Mesh* m,$/;"	f
Parma_MakeVtxBalancer	parma/diffMC/parma_vtxBalancer.cc	/^apf::Balancer* Parma_MakeVtxBalancer(apf::Mesh* m,$/;"	f
Parma_MakeVtxEdgeElmBalancer	parma/diffMC/parma_vtxEdgeElmBalancer.cc	/^apf::Balancer* Parma_MakeVtxEdgeElmBalancer(apf::Mesh* m,$/;"	f
Parma_MakeVtxElmBalancer	parma/diffMC/parma_vtxElmBalancer.cc	/^apf::Balancer* Parma_MakeVtxElmBalancer(apf::Mesh* m,$/;"	f
Parma_MisNumbering	parma/parma.cc	/^int Parma_MisNumbering(apf::Mesh* m, int d) {$/;"	f
Parma_PrintPtnStats	parma/parma.cc	/^void Parma_PrintPtnStats(apf::Mesh* m, std::string key, bool fine) {$/;"	f
Parma_PrintWeightedPtnStats	parma/parma.cc	/^void Parma_PrintWeightedPtnStats(apf::Mesh* m, apf::MeshTag* w, std::string key, bool fine) {$/;"	f
Parma_ProcessDisconnectedParts	parma/parma.cc	/^void Parma_ProcessDisconnectedParts(apf::Mesh* m) {$/;"	f
Parma_ShrinkPartition	parma/group/parma_group.cc	/^void Parma_ShrinkPartition(apf::Mesh2* m, int factor, Parma_GroupCode& toRun)$/;"	f
Parma_SplitPartition	parma/group/parma_group.cc	/^void Parma_SplitPartition(apf::Mesh2* m, int factor, Parma_GroupCode& toRun)$/;"	f
Parma_WeighByMemory	parma/parma.cc	/^apf::MeshTag* Parma_WeighByMemory(apf::Mesh* m) {$/;"	f
Parma_WriteSmallNeighbors	parma/parma.cc	/^void Parma_WriteSmallNeighbors(apf::Mesh* m, int small, const char* prefix) {$/;"	f
Parma_WriteVtxPtn	parma/diffMC/parma_vtxPtnWriter.cc	/^void Parma_WriteVtxPtn(apf::Mesh* m, const char* prefix) {$/;"	f
PartFixer	parma/diffMC/parma_dcpartFixer.cc	/^    PartFixer(apf::Mesh* mesh, unsigned verbose=0) $/;"	f	class:dcPartFixer::PartFixer
PartFixer	parma/diffMC/parma_dcpartFixer.cc	/^class dcPartFixer::PartFixer : public dcPart {$/;"	c	class:dcPartFixer	file:
PartInfo	parma/diffMC/maximalIndependentSet/mis.h	/^    typedef struct PartInfo {$/;"	s	namespace:misLuby
Parts	apf/apfMesh.h	/^typedef std::set<int> Parts;$/;"	t	namespace:apf
Parts	ma/maMesh.h	/^typedef apf::Parts Parts;$/;"	t	namespace:ma
Parts	pumi/pumi.h	/^typedef apf::Parts Parts;$/;"	t
Patch	spr/sprRecoverField.cc	/^struct Patch {$/;"	s	namespace:spr	file:
PatchOp	spr/sprRecoverField.cc	/^  PatchOp(Recovery* r):$/;"	f	class:spr::PatchOp
PatchOp	spr/sprRecoverField.cc	/^class PatchOp : public apf::CavityOp$/;"	c	namespace:spr	file:
Performance	apf/cavity.tex	/^targets are always eliminated after each migration.$/;"	s
PhastaSharing	phasta/phLinks.cc	/^  PhastaSharing(apf::Mesh* m)$/;"	f	struct:ph::PhastaSharing
PhastaSharing	phasta/phLinks.cc	/^struct PhastaSharing : public apf::Sharing {$/;"	s	namespace:ph	file:
Plane	apf/apfGeometry.cc	/^Plane::Plane(Vector3 const& n, double r):$/;"	f	class:apf::Plane
Plane	apf/apfGeometry.h	/^struct Plane {$/;"	s	namespace:apf
PlaneConstraint	phasta/phConstraint.cc	/^  PlaneConstraint(apf::Plane const& a):$/;"	f	struct:ph::PlaneConstraint
PlaneConstraint	phasta/phConstraint.cc	/^struct PlaneConstraint : public Constraint$/;"	s	namespace:ph	file:
PlaneConstraintElas	phasta/phConstraint.cc	/^  PlaneConstraintElas(apf::Plane const& a):$/;"	f	struct:ph::PlaneConstraintElas
PlaneConstraintElas	phasta/phConstraint.cc	/^struct PlaneConstraintElas : public Constraint$/;"	s	namespace:ph	file:
PointConstraint	phasta/phConstraint.cc	/^  PointConstraint():Constraint(0) {}$/;"	f	struct:ph::PointConstraint
PointConstraint	phasta/phConstraint.cc	/^struct PointConstraint : public Constraint$/;"	s	namespace:ph	file:
PointConstraintElas	phasta/phConstraint.cc	/^  PointConstraintElas():Constraint(0) {}$/;"	f	struct:ph::PointConstraintElas
PointConstraintElas	phasta/phConstraint.cc	/^struct PointConstraintElas : public Constraint$/;"	s	namespace:ph	file:
Poisson	test/poisson.cc	/^    Poisson(int d, int p, int n) {$/;"	f	class:__anon17::Poisson
Poisson	test/poisson.cc	/^class Poisson {$/;"	c	namespace:__anon17	file:
Predicate	ma/maAdapt.h	/^struct Predicate$/;"	s	namespace:ma
PreserveTargets	parma/diffMC/parma_preserveTargets.cc	/^      PreserveTargets(Sides* s, Weights* balance, Weights* preserve,$/;"	f	class:parma::PreserveTargets
PreserveTargets	parma/diffMC/parma_preserveTargets.cc	/^  class PreserveTargets : public Targets {$/;"	c	namespace:parma	file:
Prism	apf/apfShape.cc	/^    class Prism : public EntityShape$/;"	c	class:apf::Linear	file:
PrismIntegration	apf/apfIntegrate.cc	/^class PrismIntegration : public EntityIntegration$/;"	c	namespace:apf	file:
Project	apf/apfFieldOf.cc	/^    Project(FieldOf<T>* a, FieldOf<T>* b)$/;"	f	class:apf::Project
Project	apf/apfFieldOf.cc	/^class Project : public FieldOp$/;"	c	namespace:apf	file:
Projector	apf/apfHierarchic.cc	/^    Projector(Field* a, Field* b)$/;"	f	class:apf::Projector
Projector	apf/apfHierarchic.cc	/^class Projector : public FieldOp$/;"	c	namespace:apf	file:
Ptn	parma/diffMC/parma_vtxPtnWriter.cc	/^    Ptn(apf::Mesh* m) {$/;"	f	class:__anon72::Ptn
Ptn	parma/diffMC/parma_vtxPtnWriter.cc	/^  class Ptn {$/;"	c	namespace:__anon72	file:
PullRequest	apf/apfCavityOp.h	/^    struct PullRequest { MeshEntity* e; int to; };$/;"	s	class:apf::CavityOp
Pyramid	apf/apfShape.cc	/^    class Pyramid : public EntityShape$/;"	c	class:apf::Linear	file:
PyramidIntegration	apf/apfIntegrate.cc	/^class PyramidIntegration : public EntityIntegration$/;"	c	namespace:apf	file:
Q	ma/maQuality.cc	/^    Matrix Q;$/;"	m	class:ma::FixedMetricIntegrator	file:
Q	spr/sprRecoverField.cc	/^  mth::Matrix<double> Q;$/;"	m	struct:spr::QRDecomp	file:
QPBridge	stk/apfSTK.cc	/^    QPBridge(Field* f,$/;"	f	class:apf::QPBridge
QPBridge	stk/apfSTK.cc	/^class QPBridge : public StkBridge$/;"	c	namespace:apf	file:
QPDimTag	stk/apfSTK.cc	/^struct QPDimTag : public shards::ArrayDimTag {$/;"	s	namespace:apf	file:
QRDecomp	spr/sprRecoverField.cc	/^struct QRDecomp {$/;"	s	namespace:spr	file:
QUAD	apf/apfMesh.h	/^      QUAD,     \/\/3$/;"	e	enum:apf::Mesh::Type
Quad	apf/apfShape.cc	/^    class Quad : public EntityShape$/;"	c	class:apf::LagrangeQuadratic	file:
Quad	apf/apfShape.cc	/^    class Quad : public EntityShape$/;"	c	class:apf::Linear	file:
Quad	apf/apfShape.cc	/^    class Quad : public EntityShape$/;"	c	class:apf::SerendipityQuadratic	file:
QuadFlagger	ma/maTetrahedronize.cc	/^  QuadFlagger(Adapt* a):Crawler(a->mesh),adapter(a) {}$/;"	f	struct:ma::QuadFlagger
QuadFlagger	ma/maTetrahedronize.cc	/^struct QuadFlagger : public Crawler$/;"	s	namespace:ma	file:
QuadIntegration	apf/apfIntegrate.cc	/^class QuadIntegration : public EntityIntegration$/;"	c	namespace:apf	file:
QuadMarker	ma/maTetrahedronize.cc	/^  QuadMarker(Adapt* a_):$/;"	f	struct:ma::QuadMarker
QuadMarker	ma/maTetrahedronize.cc	/^struct QuadMarker : public Crawler$/;"	s	namespace:ma	file:
QuadraticBase	apf/apfShape.cc	/^class QuadraticBase : public FieldShape$/;"	c	namespace:apf	file:
QuadraticHandler	ma/maShapeHandler.cc	/^    QuadraticHandler(Adapt* a)$/;"	f	class:ma::QuadraticHandler
QuadraticHandler	ma/maShapeHandler.cc	/^class QuadraticHandler : public ShapeHandler$/;"	c	namespace:ma	file:
Quality	crv/crv.h	/^class Quality$/;"	c	namespace:crv
Quality	crv/crvQuality.cc	/^Quality::Quality(apf::Mesh* m, int algorithm_) :$/;"	f	class:crv::Quality
Quality2D	crv/crvQuality.cc	/^  Quality2D(apf::Mesh* m, int algorithm) : Quality(m,algorithm)$/;"	f	class:crv::Quality2D
Quality2D	crv/crvQuality.cc	/^class Quality2D : public Quality$/;"	c	namespace:crv	file:
Quality3D	crv/crvQuality.cc	/^  Quality3D(apf::Mesh* m, int algorithm) : Quality(m,algorithm)$/;"	f	class:crv::Quality3D
Quality3D	crv/crvQuality.cc	/^class Quality3D : public Quality$/;"	c	namespace:crv	file:
QualityImprover2D	ma/maShape.cc	/^    QualityImprover2D(Adapt* a)$/;"	f	class:ma::QualityImprover2D
QualityImprover2D	ma/maShape.cc	/^class QualityImprover2D : public Operator$/;"	c	namespace:ma	file:
Queue	mds/apfMDS.cc	/^struct Queue {$/;"	s	namespace:apf	file:
R	spr/sprRecoverField.cc	/^  mth::Matrix<double> R;$/;"	m	struct:spr::QRDecomp	file:
RBMs	phasta/phRigidBody.cc	/^std::vector<ph::rigidBodyMotion> RBMs;$/;"	v
RCB	zoltan/apfZoltan.h	/^  RCB,$/;"	e	enum:apf::ZoltanMethod
REALLOC	mds/mds.c	35;"	d	file:
REEL_H	pcu/reel/reel.h	11;"	d
REFINE	zoltan/apfZoltan.h	/^  REFINE,$/;"	e	enum:apf::ZoltanApproach
REFINE_KWAY	zoltan/apfZoltan.h	/^  REFINE_KWAY$/;"	e	enum:apf::ZoltanApproach
REPARTITION	zoltan/apfZoltan.h	/^  REPARTITION,$/;"	e	enum:apf::ZoltanApproach
REQUEST	apf/apfCavityOp.h	/^      REQUEST };$/;"	e	enum:apf::CavityOp::Outcome
RESTART_READ	phasta/phiotimer.h	/^  RESTART_READ,$/;"	e	enum:phastaio_file
RESTART_WRITE	phasta/phiotimer.h	/^  RESTART_WRITE,$/;"	e	enum:phastaio_file
RIB	zoltan/apfZoltan.h	/^  RIB,$/;"	e	enum:apf::ZoltanMethod
RStream	phasta/phstream.cc	/^  struct RStream{$/;"	s	file:
Range Markers	mds/mds.tex	/^at the end of the array.$/;"	b
Ray	ma/maSnapper.h	/^struct Ray{$/;"	s	namespace:ma
Reader	mds/mdsGmsh.cc	/^struct Reader {$/;"	s	namespace:__anon96	file:
Reader	mds/mdsUgrid.cc	/^  struct Reader {$/;"	s	namespace:__anon101	file:
Rebuild	ma/maMatchedCollapse.cc	/^Rebuild::Rebuild(Entity* a, Entity* b):$/;"	f	class:ma::Rebuild
Rebuild	ma/maMatchedCollapse.h	/^struct Rebuild {$/;"	s	namespace:ma
RebuildCallback	ma/maMesh.h	/^struct RebuildCallback {$/;"	s	namespace:ma
Rebuilds	ma/maMatchedCollapse.cc	/^Rebuilds::Rebuilds(Mesh* m):$/;"	f	class:ma::Rebuilds
Rebuilds	ma/maMatchedCollapse.h	/^struct Rebuilds : public RebuildCallback {$/;"	s	namespace:ma
RecoverGradient	apf/apfGradientByVolume.cc	/^    RecoverGradient(Field* f_in, Field* gradf_in):$/;"	f	class:apf::RecoverGradient
RecoverGradient	apf/apfGradientByVolume.cc	/^class RecoverGradient : public CavityOp$/;"	c	namespace:apf	file:
Recovery	spr/sprRecoverField.cc	/^struct Recovery {$/;"	s	namespace:spr	file:
ReductionMax	apf/apf.h	/^class ReductionMax : public ReductionOp<T>$/;"	c	namespace:apf
ReductionMin	apf/apf.h	/^class ReductionMin : public ReductionOp<T>$/;"	c	namespace:apf
ReductionOp	apf/apf.h	/^class ReductionOp$/;"	c	namespace:apf
ReductionSum	apf/apf.h	/^class ReductionSum : public ReductionOp<T>$/;"	c	namespace:apf
Reference Tetrahedron	apf/hierarchic.tex	/^\\]$/;"	s
Reference Triangle	apf/hierarchic.tex	/^\\end{align*}$/;"	s
Refine	ma/maRefine.cc	/^Refine::Refine(Adapt* a)$/;"	f	class:ma::Refine
Refine	ma/maRefine.h	/^class Refine$/;"	c	namespace:ma
RegionCollapse	ma/maRegionCollapse.h	/^class RegionCollapse$/;"	c	namespace:ma
RegionIteratorSIM	apf_sim/apfSIM.cc	/^    RegionIteratorSIM(pMesh part)$/;"	f	class:apf::RegionIteratorSIM
RegionIteratorSIM	apf_sim/apfSIM.cc	/^class RegionIteratorSIM : public IteratorSIM$/;"	c	namespace:apf	file:
Remap	apf/apfPartition.h	/^struct Remap$/;"	s	namespace:apf
Remotes	ma/maMesh.h	/^typedef apf::Copies Remotes;$/;"	t	namespace:ma
Requests	apf/apfCavityOp.h	/^    typedef std::vector<MeshEntity*> Requests;$/;"	t	class:apf::CavityOp
Requirements	apf/attach.tex	/^which affect a tetrahedron are those associated to its vertices.$/;"	s
Requirements	mds/mds.tex	/^using C++ objects.$/;"	s
Results	mds/mds.tex	/^Finally, the actual allocated size is stored in \\texttt{cap}.$/;"	s
RetreatCode	parma/group/parma_group.cc	/^  RetreatCode(GroupCode& c, apf::Mesh* m, int f)$/;"	f	struct:RetreatCode
RetreatCode	parma/group/parma_group.cc	/^struct RetreatCode : public GroupCode$/;"	s	file:
RibSplitter	parma/rib/parma_mesh_rib.cc	/^    RibSplitter(apf::Mesh* m, bool s)$/;"	f	class:parma::RibSplitter
RibSplitter	parma/rib/parma_mesh_rib.cc	/^class RibSplitter : public apf::Splitter$/;"	c	namespace:parma	file:
Round	apf/apfPartition.h	/^  Round(int n):factor(n) {}$/;"	f	struct:apf::Round
Round	apf/apfPartition.h	/^struct Round : public Remap$/;"	s	namespace:apf
SAMSZ_H	sam/samSz.h	2;"	d
SAM_ELEMENT_COUNT_H	sam/samElementCount.h	2;"	d
SAM_H	sam/sam.h	2;"	d
SCALAR	apf/apf.h	/^  SCALAR,$/;"	e	enum:apf::ValueType
SIMDataOf	apf_sim/apfSIMDataOf.h	/^  SIMDataOf()$/;"	f	class:apf::SIMDataOf
SIMDataOf	apf_sim/apfSIMDataOf.h	/^  SIMDataOf(pField fd_in)$/;"	f	class:apf::SIMDataOf
SIMDataOf	apf_sim/apfSIMDataOf.h	/^class SIMDataOf : public FieldDataOf<T>$/;"	c	namespace:apf
SIZET	phasta/phCook.cc	34;"	d	file:
SInt	spr/sprEstimateError.cc	/^    SInt(int order):$/;"	f	class:spr::SInt
SInt	spr/sprEstimateError.cc	/^class SInt : public apf::Integrator$/;"	c	namespace:spr	file:
SKIP	apf/apfCavityOp.h	/^      SKIP,$/;"	e	enum:apf::CavityOp::Outcome
SMB_DBL	mds/mds_smb.c	/^  SMB_DBL$/;"	e	enum:__anon99	file:
SMB_EDGE	mds/mds_smb.c	/^  SMB_EDGE,$/;"	e	enum:__anon98	file:
SMB_FANOUT	mds/mds_smb.c	678;"	d	file:
SMB_HEX	mds/mds_smb.c	/^  SMB_HEX,$/;"	e	enum:__anon98	file:
SMB_INT	mds/mds_smb.c	/^  SMB_INT,$/;"	e	enum:__anon99	file:
SMB_PRIS	mds/mds_smb.c	/^  SMB_PRIS,$/;"	e	enum:__anon98	file:
SMB_PYR	mds/mds_smb.c	/^  SMB_PYR,$/;"	e	enum:__anon98	file:
SMB_QUAD	mds/mds_smb.c	/^  SMB_QUAD,$/;"	e	enum:__anon98	file:
SMB_TET	mds/mds_smb.c	/^  SMB_TET,$/;"	e	enum:__anon98	file:
SMB_TRI	mds/mds_smb.c	/^  SMB_TRI,$/;"	e	enum:__anon98	file:
SMB_TYPES	mds/mds_smb.c	/^  SMB_TYPES$/;"	e	enum:__anon98	file:
SMB_VERSION	mds/mds_smb.c	/^enum { SMB_VERSION = 5 };$/;"	e	enum:__anon97	file:
SMB_VERT	mds/mds_smb.c	/^  SMB_VERT,$/;"	e	enum:__anon98	file:
SNAP	ma/maAdapt.h	/^  SNAP          = (1<< 7),$/;"	e	enum:ma::__anon25
SPLIT	ma/maAdapt.h	/^  SPLIT         = (1<< 0),$/;"	e	enum:ma::__anon25
SPLITMESHONGFACE_H_	phasta/splitMeshOnGFace.h	2;"	d
SPR_H	spr/spr.h	9;"	d
STEP_PARAM	phasta/phIO.c	/^STEP_PARAM$/;"	e	enum:__anon80	file:
Samples	spr/sprRecoverField.cc	/^  Samples():num_points(0) {}$/;"	f	struct:spr::Samples
Samples	spr/sprRecoverField.cc	/^struct Samples {$/;"	s	namespace:spr	file:
SavedMatches	phasta/phFilterMatching.cc	/^typedef std::vector<apf::Matches> SavedMatches;$/;"	t	namespace:ph	file:
ScalarElement	apf/apfScalarElement.cc	/^ScalarElement::ScalarElement(ScalarField* f, VectorElement* e):$/;"	f	class:apf::ScalarElement
ScalarElement	apf/apfScalarElement.h	/^class ScalarElement : public ElementOf<double>$/;"	c	namespace:apf
ScalarField	apf/apfScalarField.h	/^class ScalarField : public FieldOf<double>$/;"	c	namespace:apf
ScalarIntegrator	spr/sprEstimateTargetError.cc	/^    ScalarIntegrator(int order):$/;"	f	class:spr::target::ScalarIntegrator
ScalarIntegrator	spr/sprEstimateTargetError.cc	/^class ScalarIntegrator : public apf::Integrator$/;"	c	namespace:spr::target	file:
Scale	test/scale.cc	/^struct Scale {$/;"	s	namespace:__anon3	file:
Selector	parma/diffMC/parma_selector.h	/^      Selector(apf::Mesh* m, apf::MeshTag* w) : mesh(m), wtag(w) {}$/;"	f	class:parma::Selector
Selector	parma/diffMC/parma_selector.h	/^  class Selector {$/;"	c	namespace:parma
SelfProduct	spr/sprEstimateError.cc	/^    SelfProduct(Estimation* e):$/;"	f	class:spr::SelfProduct
SelfProduct	spr/sprEstimateError.cc	/^class SelfProduct : public SInt$/;"	c	namespace:spr	file:
SerendipityQuadratic	apf/apfShape.cc	/^    SerendipityQuadratic() { registerSelf(apf::SerendipityQuadratic::getName()); }$/;"	f	class:apf::SerendipityQuadratic
SerendipityQuadratic	apf/apfShape.cc	/^class SerendipityQuadratic : public QuadraticBase$/;"	c	namespace:apf	file:
Set	phasta/phBC.h	/^  typedef std::set<BC*, BCPointerLess> Set;$/;"	t	struct:ph::FieldBCs
SetEnt	parma/diffMC/parma_edgeEqVtxSelector.cc	/^  typedef std::set<apf::MeshEntity*> SetEnt;$/;"	t	namespace:__anon52	file:
SetEnt	parma/diffMC/parma_elmLtVtxEdgeSelector.cc	/^  typedef std::set<apf::MeshEntity*> SetEnt;$/;"	t	namespace:__anon64	file:
SetEnt	parma/diffMC/parma_ltSelector.cc	/^  typedef std::set<apf::MeshEntity*> SetEnt;$/;"	t	namespace:__anon58	file:
SetInt	mds/mdsUgrid.cc	/^  typedef std::set<int> SetInt;$/;"	t	namespace:__anon101	file:
SetNumberingOffset	apf/apfNumbering.h	/^inline void SetNumberingOffset(Numbering * num, int off) { setNumberingOffset(num,off); }$/;"	f	namespace:apf
SetValue	apf/apfGradientByVolume.cc	/^class SetValue<Matrix3x3>$/;"	c	namespace:apf	file:
SetValue	apf/apfGradientByVolume.cc	/^class SetValue<Vector3>$/;"	c	namespace:apf	file:
ShapeHandler	ma/maShapeHandler.h	/^class ShapeHandler : public SolutionTransfer$/;"	c	namespace:ma
ShapeHandlerFunction	ma/maInput.h	/^typedef ShapeHandler* (*ShapeHandlerFunction)(Adapt* a);$/;"	t	namespace:ma
ShapeOptimizer	parma/diffMC/parma_shapeOptimizer.cc	/^      ShapeOptimizer(apf::Mesh* m, double f, int v)$/;"	f	class:__anon47::ShapeOptimizer
ShapeOptimizer	parma/diffMC/parma_shapeOptimizer.cc	/^  class ShapeOptimizer : public parma::Balancer {$/;"	c	namespace:__anon47	file:
ShapeSelector	parma/diffMC/parma_shapeSelector.cc	/^      ShapeSelector(apf::Mesh* m, apf::MeshTag* w)$/;"	f	class:__anon57::ShapeSelector
ShapeSelector	parma/diffMC/parma_shapeSelector.cc	/^  class ShapeSelector : public parma::Selector {$/;"	c	namespace:__anon57	file:
ShapeTargets	parma/diffMC/parma_shapeTargets.cc	/^      ShapeTargets(Sides* s) {$/;"	f	class:parma::ShapeTargets
ShapeTargets	parma/diffMC/parma_shapeTargets.cc	/^  class ShapeTargets : public Targets {$/;"	c	namespace:parma	file:
Sharing	apf/apfMesh.h	/^struct Sharing$/;"	s	namespace:apf
Shock	test/capStoneSizeFields.h	/^    Shock(ma::Mesh* m)$/;"	f	class:Shock
Shock	test/capStoneSizeFields.h	/^class Shock : public ma::AnisotropicFunction$/;"	c
ShortEdgeFixer	ma/maShape.cc	/^    ShortEdgeFixer(Adapt* a):$/;"	f	class:ma::ShortEdgeFixer
ShortEdgeFixer	ma/maShape.cc	/^class ShortEdgeFixer : public Operator$/;"	c	namespace:ma	file:
ShortEdgeRemover	ma/maShortEdgeRemover.cc	/^ShortEdgeRemover::ShortEdgeRemover(Adapt* a)$/;"	f	class:ma::ShortEdgeRemover
ShortEdgeRemover	ma/maShortEdgeRemover.h	/^class ShortEdgeRemover$/;"	c	namespace:ma
ShouldCollapse	ma/maCoarsen.cc	/^  ShouldCollapse(Adapt* a_):a(a_) {}$/;"	f	struct:ma::ShouldCollapse
ShouldCollapse	ma/maCoarsen.cc	/^struct ShouldCollapse : public Predicate$/;"	s	namespace:ma	file:
ShouldSplit	ma/maRefine.cc	/^  ShouldSplit(Adapt* a_):a(a_) {}$/;"	f	struct:ma::ShouldSplit
ShouldSplit	ma/maRefine.cc	/^struct ShouldSplit : public Predicate$/;"	s	namespace:ma	file:
SideManifoldness	apf/apfVerify.cc	/^typedef std::map<ModelEntity*, bool> SideManifoldness;$/;"	t	namespace:apf	file:
SideSet	stk/apfAlbany.h	/^typedef std::vector<apf::MeshEntity*> SideSet;$/;"	t	namespace:apf
SideSets	stk/apfAlbany.h	/^typedef std::map<std::string, SideSet> SideSets;$/;"	t	namespace:apf
Sides	parma/diffMC/parma_sides.h	/^      Sides(apf::Mesh*) { totalSides = 0; }$/;"	f	class:parma::Sides
Sides	parma/diffMC/parma_sides.h	/^  class Sides : public Associative<int> {$/;"	c	namespace:parma
SimBC	phasta/phAttrib.cc	/^  SimBC(pGEntity ge)$/;"	f	struct:SimBC
SimBC	phasta/phAttrib.cc	/^struct SimBC : public ph::BC$/;"	s	file:
Simple Meshes	mds/mds.tex	/^starting with examples followed by a rigorous definition.$/;"	b
Size	stk/apfSTK.cc	/^  enum { Size = 1 };                    \/\/\/< default size$/;"	e	enum:apf::QPDimTag::__anon24	file:
Size Field	ma/adapt.tex	/^It does not accept hexahedral elements.$/;"	s
Size Field	ma/adapt2.tex	/^to be represented by one function for all cases.$/;"	s
Size Field Computation	spr/spr.tex	/^to store the field $A:A$.$/;"	s
SizeField	ma/maSize.h	/^class SizeField$/;"	c	namespace:ma
SizeFieldIntegrator	ma/maSize.cc	/^    SizeFieldIntegrator(SizeField* sF):$/;"	f	class:ma::SizeFieldIntegrator
SizeFieldIntegrator	ma/maSize.cc	/^class SizeFieldIntegrator : public apf::Integrator$/;"	c	namespace:ma	file:
SizesEval	ma/maSize.cc	/^  SizesEval()$/;"	f	struct:ma::SizesEval
SizesEval	ma/maSize.cc	/^  SizesEval(BothEval* b)$/;"	f	struct:ma::SizesEval
SizesEval	ma/maSize.cc	/^struct SizesEval : public apf::Function$/;"	s	namespace:ma	file:
Slope	parma/diffMC/parma_monitor.cc	/^  Slope::Slope() : CircBuffer(order+1) {}$/;"	f	class:parma::Slope
Slope	parma/diffMC/parma_monitor.h	/^  class Slope : public CircBuffer {$/;"	c	namespace:parma
Smoother	dsp/dspSmoothers.h	/^class Smoother {$/;"	c	namespace:dsp
SnapAll	ma/maSnap.cc	/^    SnapAll(Adapt* a, Tag* t, bool simple):$/;"	f	class:ma::SnapAll
SnapAll	ma/maSnap.cc	/^class SnapAll : public Operator$/;"	c	namespace:ma	file:
SnapAll	ma/maSnap_mohara.cc	/^    SnapAll(Adapt* a, Tag* t, bool simple):$/;"	f	class:ma::SnapAll
SnapAll	ma/maSnap_mohara.cc	/^class SnapAll : public Operator$/;"	c	namespace:ma	file:
SnapMatched	ma/maSnap.cc	/^    SnapMatched(Adapt* a, Tag* t, bool simple):$/;"	f	class:ma::SnapMatched
SnapMatched	ma/maSnap.cc	/^class SnapMatched : public Operator$/;"	c	namespace:ma	file:
SnapMatched	ma/maSnap_mohara.cc	/^    SnapMatched(Adapt* a, Tag* t, bool simple):$/;"	f	class:ma::SnapMatched
SnapMatched	ma/maSnap_mohara.cc	/^class SnapMatched : public Operator$/;"	c	namespace:ma	file:
SnapTagger	ma/maLayerSnap.cc	/^  SnapTagger(Adapt* a_, Tag* t_):$/;"	f	struct:ma::SnapTagger
SnapTagger	ma/maLayerSnap.cc	/^struct SnapTagger : public Crawler$/;"	s	namespace:ma	file:
Snapper	ma/maSnapper.cc	/^Snapper::Snapper(Adapt* a, Tag* st, bool is)$/;"	f	class:ma::Snapper
Snapper	ma/maSnapper.h	/^class Snapper$/;"	c	namespace:ma
SolutionTransfer	ma/maSolutionTransfer.h	/^class SolutionTransfer$/;"	c	namespace:ma
SolutionTransfers	ma/maSolutionTransfer.cc	/^SolutionTransfers::SolutionTransfers()$/;"	f	class:ma::SolutionTransfers
SolutionTransfers	ma/maSolutionTransfer.h	/^class SolutionTransfers : public SolutionTransfer$/;"	c	namespace:ma
SortStruct	apf/apfMatrix.cc	/^struct SortStruct$/;"	s	namespace:apf	file:
SortingStruct	test/capStoneAttachSolution.cc	/^struct SortingStruct$/;"	s	file:
SplitFunction	ma/maRefine.h	/^typedef void (*SplitFunction)(Refine* r, Entity* p, Entity** v);$/;"	t	namespace:ma
SplitPyramid_2_b2_sub	ma/maLayerTemplates.cc	/^typedef void (*SplitPyramid_2_b2_sub)(Refine* r, Entity* p, Entity** v,$/;"	t	namespace:ma	file:
SplitTagger	ma/maLayerRefine.cc	/^  SplitTagger(Adapt* a_):$/;"	f	struct:ma::SplitTagger
SplitTagger	ma/maLayerRefine.cc	/^struct SplitTagger : public Crawler$/;"	s	namespace:ma	file:
Splits	ma/maSplits.cc	/^Splits::Splits(Adapt* a):$/;"	f	class:ma::Splits
Splits	ma/maSplits.h	/^class Splits$/;"	c	namespace:ma
Splitter	apf/apfPartition.h	/^class Splitter$/;"	c	namespace:apf
Stepper	parma/diffMC/parma_step.cc	/^  Stepper::Stepper(apf::Mesh* mIn, double alphaIn,$/;"	f	class:parma::Stepper
Stepper	parma/diffMC/parma_step.h	/^  class Stepper {$/;"	c	namespace:parma
StkBridge	stk/apfSTK.cc	/^class StkBridge$/;"	c	namespace:apf	file:
StkBucket	stk/apfSTK.h	/^typedef stk::mesh::Bucket StkBucket;$/;"	t	namespace:apf
StkBulkData	stk/apfSTK.h	/^typedef stk::mesh::BulkData StkBulkData;$/;"	t	namespace:apf
StkMetaData	stk/apfSTK.h	/^typedef stk::mesh::MetaData StkMetaData;$/;"	t	namespace:apf
StkModel	stk/apfAlbany.h	/^struct StkModel {$/;"	s	namespace:apf
StkModels	stk/apfAlbany.h	/^struct StkModels {$/;"	s	namespace:apf
StkModels	stk/apfSTK.cc	/^StkModels::StkModels()$/;"	f	class:apf::StkModels
StkQPScalarField	stk/apfSTK.cc	/^typedef stk::mesh::Field<double, QPDimTag> StkQPScalarField;$/;"	t	namespace:apf	file:
StkQPTensorField	stk/apfSTK.cc	/^StkQPTensorField;$/;"	t	namespace:apf	file:
StkQPVectorField	stk/apfSTK.cc	/^StkQPVectorField;$/;"	t	namespace:apf	file:
StkScalarField	stk/apfSTK.cc	/^typedef stk::mesh::Field<double> StkScalarField;$/;"	t	namespace:apf	file:
StkTensorField	stk/apfSTK.cc	/^StkTensorField;$/;"	t	namespace:apf	file:
StkVectorField	stk/apfSTK.cc	/^typedef stk::mesh::Field<double, stk::mesh::Cartesian> StkVectorField;$/;"	t	namespace:apf	file:
Stop	parma/diffMC/parma_stop.h	/^  class Stop {$/;"	c	namespace:parma
StringMap	phasta/phInput.cc	/^typedef std::map<std::string, std::string*> StringMap;$/;"	t	namespace:ph	file:
SubdivisionFunction	crv/crvQuality.h	/^typedef void (*SubdivisionFunction)(int P,$/;"	t	namespace:crv
SwapCavity	ma/maEdgeSwap.cc	/^class SwapCavity$/;"	c	namespace:ma	file:
SwapLoop	ma/maEdgeSwap.cc	/^class SwapLoop$/;"	c	namespace:ma	file:
T0	mds/mds.c	/^static int const T0[] = {MDS_VERTEX,MDS_VERTEX,MDS_VERTEX,MDS_VERTEX};$/;"	v	file:
T01	apf_cap/apfCAP.cc	/^static int const T01[] = {0,1,1,2,2,0$/;"	m	namespace:apf	file:
T01	mds/mds.c	/^static int const T01[] = {0,1,1,2,2,0$/;"	v	file:
T1	mds/mds.c	/^static int const T1[] = {MDS_EDGE,MDS_EDGE,MDS_EDGE$/;"	v	file:
T10	apf_cap/apfCAP.cc	/^static int const T10[] = {2,0,0,1,1,2,3,4};$/;"	m	namespace:apf	file:
T10	mds/mds.c	/^static int const T10[] = {2,0,0,1,1,2,3,4};$/;"	v	file:
T12	apf_cap/apfCAP.cc	/^static int const T12[] = {0,1,2$/;"	m	namespace:apf	file:
T12	mds/mds.c	/^static int const T12[] = {0,1,2$/;"	v	file:
T2	mds/mds.c	/^static int const T2[] = {MDS_TRIANGLE,MDS_TRIANGLE,MDS_TRIANGLE,MDS_TRIANGLE};$/;"	v	file:
T21	apf_cap/apfCAP.cc	/^static int const T21[] = {0,1$/;"	m	namespace:apf	file:
T21	mds/mds.c	/^static int const T21[] = {0,1$/;"	v	file:
TEMPERING_MASK_B	parma/diffMC/maximalIndependentSet/mersenne_twister.cc	26;"	d	file:
TEMPERING_MASK_C	parma/diffMC/maximalIndependentSet/mersenne_twister.cc	27;"	d	file:
TEMPERING_SHIFT_L	parma/diffMC/maximalIndependentSet/mersenne_twister.cc	31;"	d	file:
TEMPERING_SHIFT_S	parma/diffMC/maximalIndependentSet/mersenne_twister.cc	29;"	d	file:
TEMPERING_SHIFT_T	parma/diffMC/maximalIndependentSet/mersenne_twister.cc	30;"	d	file:
TEMPERING_SHIFT_U	parma/diffMC/maximalIndependentSet/mersenne_twister.cc	28;"	d	file:
TEST_FIELD	test/pumi.cc	/^void TEST_FIELD(pMesh m)$/;"	f
TEST_GENT_DEL_TAG	test/pumi.cc	/^void TEST_GENT_DEL_TAG (pGeom g, pGeomEnt ent)$/;"	f
TEST_GENT_SETGET_TAG	test/pumi.cc	/^void TEST_GENT_SETGET_TAG (pGeom g, pGeomEnt ent)$/;"	f
TEST_GEOM_TAG	test/pumi.cc	/^void TEST_GEOM_TAG(pGeom g)$/;"	f
TEST_GHOSTING	test/pumi.cc	/^void TEST_GHOSTING(pMesh m)$/;"	f
TEST_MENT_DEL_TAG	test/pumi.cc	/^void TEST_MENT_DEL_TAG (pMesh m, pMeshEnt ent)$/;"	f
TEST_MENT_SETGET_TAG	test/pumi.cc	/^void TEST_MENT_SETGET_TAG (pMesh m, pMeshEnt ent)$/;"	f
TEST_MESH	test/pumi.cc	/^void TEST_MESH(pMesh m)$/;"	f
TEST_MESH_TAG	test/pumi.cc	/^void TEST_MESH_TAG(pMesh m)$/;"	f
TEST_NEW_MESH	test/pumi.cc	/^void TEST_NEW_MESH(pMesh m)$/;"	f
TEST_TAG	test/pumi.cc	/^void TEST_TAG (pTag tag, char const* in_name, int name_len, int in_type, int in_size)$/;"	f
TET	apf/apfMesh.h	/^      TET,      \/\/4$/;"	e	enum:apf::Mesh::Type
TETRAHEDRON	phasta/phBlock.h	/^  TETRAHEDRON  = 1,$/;"	e	enum:ph::__anon86
TOPFACE	test/icesheet.cc	22;"	d	file:
TOPTAG	test/icesheet.cc	16;"	d	file:
TOP_EDGE	test/icesheet.cc	26;"	d	file:
TOP_PERIMETERTAG	test/icesheet.cc	19;"	d	file:
TOP_VERTEX	test/icesheet.cc	29;"	d	file:
TOUCH_EDGE	test/icesheet.cc	27;"	d	file:
TO_DOUBLE	parma/diffMC/parma_convert.h	6;"	d
TO_INT	parma/diffMC/parma_convert.h	4;"	d
TO_LONG	parma/diffMC/parma_convert.h	5;"	d
TO_SIZET	parma/diffMC/parma_convert.h	7;"	d
TO_UINT	parma/diffMC/parma_convert.h	3;"	d
TRIANGLE	apf/apfMesh.h	/^      TRIANGLE, \/\/2$/;"	e	enum:apf::Mesh::Type
TYPE	mds/mds.c	293;"	d	file:
TYPES	apf/apfMesh.h	/^      TYPES };  \/\/8$/;"	e	enum:apf::Mesh::Type
TYPES	phasta/phBlock.h	/^  TYPES        = 7$/;"	e	enum:ph::__anon86
Tag	ma/maMesh.h	/^typedef apf::MeshTag Tag;$/;"	t	namespace:ma
TagCAP	apf_cap/apfCAP.cc	/^    TagCAP(MeshDatabaseInterface* m,$/;"	f	class:apf::TagCAP
TagCAP	apf_cap/apfCAP.cc	/^class TagCAP$/;"	c	namespace:apf	file:
TagData	apf/apfTagData.h	/^class TagData$/;"	c	namespace:apf
TagDataOf	apf/apfTagData.h	/^class TagDataOf : public FieldDataOf<T>$/;"	c	namespace:apf
TagHandle	pumi/GenTag.cc	/^TagHandle::TagHandle($/;"	f	class:TagHandle
TagHandle	pumi/GenTag.h	/^class TagHandle$/;"	c
TagHelper	apf/apfTagData.h	/^class TagHelper<double> : public TagMaker$/;"	c	namespace:apf
TagHelper	apf/apfTagData.h	/^class TagHelper<int> : public TagMaker$/;"	c	namespace:apf
TagHelper	apf/apfTagData.h	/^class TagHelper<long> : public TagMaker$/;"	c	namespace:apf
TagHolder	pumi/GenTag.h	/^class TagHolder$/;"	c
TagHolder_CheckTag	pumi/GenTag.cc	/^int TagHolder_CheckTag(pTagHolder holder, pTag tag, int tag_type)$/;"	f
TagHolder_ClearTag	pumi/GenTag.cc	/^void TagHolder_ClearTag (pTagHolder holder)$/;"	f
TagHolder_CreateTag	pumi/GenTag.cc	/^pTag TagHolder_CreateTag($/;"	f
TagHolder_DelTag	pumi/GenTag.cc	/^int TagHolder_DelTag (pTagHolder holder, pTag tag)$/;"	f
TagHolder_FindTag	pumi/GenTag.cc	/^int TagHolder_FindTag(pTagHolder holder, const char* tag_name, pTag& tag)$/;"	f
TagHolder_GetTag	pumi/GenTag.cc	/^void TagHolder_GetTag (pTagHolder holder, std::vector<pTag> &tags)$/;"	f
TagHolder_HasTag	pumi/GenTag.cc	/^int TagHolder_HasTag (pTagHolder holder, const pTag tag, int *exist)$/;"	f
TagMaker	apf/apfTagData.h	/^class TagMaker$/;"	c	namespace:apf
TagSIM	apf_sim/apfSIM.cc	/^    TagSIM(pParMesh m,$/;"	f	class:apf::TagSIM
TagSIM	apf_sim/apfSIM.cc	/^class TagSIM$/;"	c	namespace:apf	file:
TagType	apf/apfMesh.h	/^    enum TagType {$/;"	g	class:apf::Mesh
Tag_GetName	pumi/GenTag.cc	/^const char* Tag_GetName(pTag tag)$/;"	f
Tag_GetSize	pumi/GenTag.cc	/^int Tag_GetSize(pTag tag)$/;"	f
Tag_GetType	pumi/GenTag.cc	/^int Tag_GetType(pTag tag)$/;"	f
Taggable	pumi/GenTag.cc	/^Taggable::Taggable()$/;"	f	class:Taggable
Taggable	pumi/GenTag.h	/^class Taggable$/;"	c
Taggable_DelTag	pumi/GenTag.cc	/^void Taggable_DelTag (pTaggable obj, pTag tag)$/;"	f
Taggable_GetData	pumi/GenTag.h	/^int Taggable_GetData (pTaggable obj, pTag tag, T data[])$/;"	f
Taggable_GetTag	pumi/GenTag.cc	/^void Taggable_GetTag (pTaggable obj, std::vector<pTag>& tags)$/;"	f
Taggable_HasTag	pumi/GenTag.cc	/^bool Taggable_HasTag (pTaggable obj, pTag tag)$/;"	f
Taggable_SetData	pumi/GenTag.h	/^int Taggable_SetData (pTaggable obj, pTag tag, const T* data)$/;"	f
Tagger	ma/maCrawler.cc	/^struct Tagger$/;"	s	namespace:ma	file:
Target Size Field Computation	spr/spr.tex	/^adjacent to a vertex.$/;"	s
Targets	parma/diffMC/parma_targets.h	/^  class Targets : public Associative<double> {$/;"	c	namespace:parma
Tensor	apf/apf.tex	/^A field is defined by a independent tensor type, distribution, and domain.$/;"	s
Tensor	mth/mthTensor.h	/^    Tensor() : Matrix<T>() {}$/;"	f	class:mth::Tensor
Tensor	mth/mthTensor.h	/^    Tensor(Matrix<T> const& b) : mth::Matrix<T>() {copy(b);}$/;"	f	class:mth::Tensor
Tensor	mth/mthTensor.h	/^    Tensor(Tensor<T> const& b) : mth::Matrix<T>() {copy(b);}$/;"	f	class:mth::Tensor
Tensor	mth/mthTensor.h	/^    Tensor(unsigned d) : mth::Matrix<T>(d,d)$/;"	f	class:mth::Tensor
Tensor	mth/mthTensor.h	/^class Tensor : public Matrix<T>$/;"	c	namespace:mth
Tensor0BC	phasta/phAttrib.cc	/^  Tensor0BC(pAttribute a, pGEntity ge):SimBC(ge)$/;"	f	struct:Tensor0BC
Tensor0BC	phasta/phAttrib.cc	/^struct Tensor0BC : public SimBC$/;"	s	file:
Tensor1BC	phasta/phAttrib.cc	/^  Tensor1BC(pAttribute a, pGEntity ge):SimBC(ge)$/;"	f	struct:Tensor1BC
Tensor1BC	phasta/phAttrib.cc	/^struct Tensor1BC : public SimBC {$/;"	s	file:
TetFixerBase	ma/maShape.cc	/^class TetFixerBase$/;"	c	namespace:ma	file:
Tetrahedron	apf/apfIPShape.cc	/^    class Tetrahedron : public EntityShape$/;"	c	class:apf::ConstantIPFit	file:
Tetrahedron	apf/apfIPShape.cc	/^    class Tetrahedron : public EntityShape$/;"	c	class:apf::LinearIPFit	file:
Tetrahedron	apf/apfShape.cc	/^    class Tetrahedron : public EntityShape$/;"	c	class:apf::LagrangeCubic	file:
Tetrahedron	apf/apfShape.cc	/^    class Tetrahedron : public EntityShape$/;"	c	class:apf::Linear	file:
Tetrahedron	apf/apfShape.cc	/^    class Tetrahedron : public EntityShape$/;"	c	class:apf::QuadraticBase	file:
Tetrahedron	crv/crvBezier.cc	/^  class Tetrahedron : public apf::EntityShape$/;"	c	class:crv::Bezier	file:
Tetrahedron	crv/crvBezier.cc	/^  class Tetrahedron : public apf::EntityShape$/;"	c	class:crv::GregorySurface4	file:
TetrahedronIntegration	apf/apfIntegrate.cc	/^class TetrahedronIntegration : public EntityIntegration$/;"	c	namespace:apf	file:
The Interface	design.tex	/^\\maketitle$/;"	s
Theory	apf/stitch.tex	/^\\maketitle$/;"	s
Thickness Adjustment	ma/layer.tex	/^layers.$/;"	s
TopFlagger	ma/maCrawler.cc	/^  TopFlagger(Adapt* a_, Tag* t_):$/;"	f	struct:ma::TopFlagger
TopFlagger	ma/maCrawler.cc	/^struct TopFlagger : public apf::CavityOp$/;"	s	namespace:ma	file:
TotalMetricVolumeIso	sam/samElementCount.cc	/^  TotalMetricVolumeIso(apf::Field* iso_field_):$/;"	f	class:sam::TotalMetricVolumeIso
TotalMetricVolumeIso	sam/samElementCount.cc	/^class TotalMetricVolumeIso : public apf::Integrator {$/;"	c	namespace:sam	file:
Transfers	ma/maSolutionTransfer.h	/^    typedef std::vector<SolutionTransfer*> Transfers;$/;"	t	class:ma::SolutionTransfers
Triangle	apf/apfIPShape.cc	/^    class Triangle : public EntityShape$/;"	c	class:apf::ConstantIPFit	file:
Triangle	apf/apfIPShape.cc	/^    class Triangle : public EntityShape$/;"	c	class:apf::LinearIPFit	file:
Triangle	apf/apfShape.cc	/^    class Triangle : public EntityShape$/;"	c	class:apf::LagrangeCubic	file:
Triangle	apf/apfShape.cc	/^    class Triangle : public EntityShape$/;"	c	class:apf::Linear	file:
Triangle	apf/apfShape.cc	/^    class Triangle : public EntityShape$/;"	c	class:apf::QuadraticBase	file:
Triangle	crv/crvBezier.cc	/^  class Triangle : public apf::EntityShape$/;"	c	class:crv::Bezier	file:
Triangle	crv/crvBezier.cc	/^  class Triangle : public apf::EntityShape$/;"	c	class:crv::GregorySurface4	file:
TriangleIntegration	apf/apfIntegrate.cc	/^class TriangleIntegration : public EntityIntegration$/;"	c	namespace:apf	file:
Type	apf/apfMesh.h	/^    enum Type {$/;"	g	class:apf::Mesh
UPPER_MASK	parma/diffMC/maximalIndependentSet/mersenne_twister.cc	22;"	d	file:
UintArr	parma/diffMC/parma_shapeSelector.cc	/^  struct UintArr {$/;"	s	namespace:__anon57	file:
UintArr	parma/diffMC/parma_vtxSelector.cc	/^  struct UintArr {$/;"	s	namespace:__anon59	file:
Uniform	test/capStoneSizeFields.h	/^    Uniform(ma::Mesh* m, double inFactor)$/;"	f	class:Uniform
Uniform	test/capStoneSizeFields.h	/^class Uniform : public ma::IsotropicFunction$/;"	c
UniformAdapter	dsp/dspAdapters.cc	/^  UniformAdapter(double s):myFunction(s) {}$/;"	f	class:dsp::UniformAdapter
UniformAdapter	dsp/dspAdapters.cc	/^class UniformAdapter : public Adapter {$/;"	c	namespace:dsp	file:
UniformAniso	test/capStoneSizeFields.h	/^    UniformAniso(ma::Mesh* m)$/;"	f	class:UniformAniso
UniformAniso	test/capStoneSizeFields.h	/^class UniformAniso : public ma::AnisotropicFunction$/;"	c
UniformRefiner	ma/maSize.h	/^  UniformRefiner(Mesh* m):$/;"	f	struct:ma::UniformRefiner
UniformRefiner	ma/maSize.h	/^struct UniformRefiner : public IdentitySizeField$/;"	s	namespace:ma
Unmodulo	apf/apfPartition.h	/^  Unmodulo(int original, int factor)$/;"	f	struct:apf::Unmodulo
Unmodulo	apf/apfPartition.h	/^struct Unmodulo : public Remap$/;"	s	namespace:apf
UnsafePrismOverride	ma/maTetrahedronize.cc	/^  UnsafePrismOverride(Adapt* a_):$/;"	f	struct:ma::UnsafePrismOverride
UnsafePrismOverride	ma/maTetrahedronize.cc	/^struct UnsafePrismOverride : public apf::CavityOp$/;"	s	namespace:ma	file:
UnsafePyramidOverride	ma/maTetrahedronize.cc	/^  UnsafePyramidOverride(Adapt* a_):$/;"	f	struct:ma::UnsafePyramidOverride
UnsafePyramidOverride	ma/maTetrahedronize.cc	/^struct UnsafePyramidOverride : public apf::CavityOp$/;"	s	namespace:ma	file:
UnsnapChecker	ma/maLayerSnap.cc	/^  UnsnapChecker(Adapt* a_, Tag* t_):$/;"	f	struct:ma::UnsnapChecker
UnsnapChecker	ma/maLayerSnap.cc	/^struct UnsnapChecker : public Crawler$/;"	s	namespace:ma	file:
Unsnapper	ma/maLayerSnap.cc	/^  Unsnapper(Adapt* a_, Tag* t_):$/;"	f	struct:ma::Unsnapper
Unsnapper	ma/maLayerSnap.cc	/^struct Unsnapper : public Crawler$/;"	s	namespace:ma	file:
Up	apf/apfMesh.h	/^struct Up$/;"	s	namespace:apf
Upward	ma/maMesh.h	/^typedef EntityArray Upward;$/;"	t	namespace:ma
UpwardCounts	apf/apfVerify.cc	/^typedef std::map<ModelEntity*, int> UpwardCounts;$/;"	t	namespace:apf	file:
UserData	apf/apfUserData.cc	/^UserData::UserData(Function* f)$/;"	f	class:apf::UserData
UserData	apf/apfUserData.h	/^struct UserData : public FieldDataOf<double>$/;"	s	namespace:apf
V	test/eigen_test.cc	/^  double V[3][3];$/;"	m	struct:Input	file:
VALUE_TYPES	apf/apf.h	/^  VALUE_TYPES$/;"	e	enum:apf::ValueType
VARS_PARAM	phasta/phIO.c	/^VARS_PARAM,$/;"	e	enum:__anon80	file:
VECTOR	apf/apf.h	/^  VECTOR,$/;"	e	enum:apf::ValueType
VERTEX	apf/apfMesh.h	/^      VERTEX,   \/\/0$/;"	e	enum:apf::Mesh::Type
ValueType	apf/apf.h	/^enum ValueType {$/;"	g	namespace:apf
Vector	apf/apfVector.h	/^    Vector() {}$/;"	f	class:apf::Vector
Vector	apf/apfVector.h	/^    Vector(double const* v)$/;"	f	class:apf::Vector
Vector	apf/apfVector.h	/^class Vector : public Array<double,N>$/;"	c	namespace:apf
Vector	ma/maMesh.h	/^typedef apf::Vector3 Vector;$/;"	t	namespace:ma
Vector	mth/mthVector.h	/^    Vector() {}$/;"	f	class:mth::Vector
Vector	mth/mthVector.h	/^    Vector(T const* v)$/;"	f	class:mth::Vector
Vector	mth/mthVector.h	/^    Vector(unsigned n) : can::Array<T>(n) {}$/;"	f	class:mth::Vector
Vector	mth/mthVector.h	/^    Vector(unsigned n) {(void)n;}$/;"	f	class:mth::Vector
Vector	mth/mthVector.h	/^class Vector : public can::Array<T,N>$/;"	c	namespace:mth
Vector	mth/mthVector.h	/^class Vector<T,0> : public can::Array<T,0>$/;"	c	namespace:mth
Vector	stk/apfAlbany.h	/^  typedef std::vector<StkModel*> Vector;$/;"	t	struct:apf::StkModels
Vector	stk/apfAlbany.h	/^  typedef std::vector<apf::ModelEntity*> Vector;$/;"	t	struct:apf::StkModel
Vector3	apf/apfVector.h	/^    Vector3() {}$/;"	f	class:apf::Vector3
Vector3	apf/apfVector.h	/^    Vector3(Vector<3> const& other):$/;"	f	class:apf::Vector3
Vector3	apf/apfVector.h	/^    Vector3(double a, double b, double c)$/;"	f	class:apf::Vector3
Vector3	apf/apfVector.h	/^    Vector3(double const* abc)$/;"	f	class:apf::Vector3
Vector3	apf/apfVector.h	/^class Vector3 : public Vector<3>$/;"	c	namespace:apf
Vector3	mth/mthVector.h	/^    Vector3() {}$/;"	f	class:mth::Vector3
Vector3	mth/mthVector.h	/^    Vector3(T const& a, T const& b, T const& c)$/;"	f	class:mth::Vector3
Vector3	mth/mthVector.h	/^    Vector3(T const* abc)$/;"	f	class:mth::Vector3
Vector3	mth/mthVector.h	/^    Vector3(Vector<T,3> const& other) : Vector<T,3>(other) {};$/;"	f	class:mth::Vector3
Vector3	mth/mthVector.h	/^class Vector3 : public Vector<T,3>$/;"	c	namespace:mth
Vector3	pumi/pumi.h	/^typedef apf::Vector3 Vector3; \/\/ 3d vector$/;"	t
VectorElement	apf/apfVectorElement.cc	/^VectorElement::VectorElement(VectorField* f, MeshEntity* e):$/;"	f	class:apf::VectorElement
VectorElement	apf/apfVectorElement.cc	/^VectorElement::VectorElement(VectorField* f, VectorElement* p):$/;"	f	class:apf::VectorElement
VectorElement	apf/apfVectorElement.h	/^class VectorElement : public ElementOf<Vector3>$/;"	c	namespace:apf
VectorField	apf/apfVectorField.h	/^class VectorField : public FieldOf<Vector3>$/;"	c	namespace:apf
VectorLess	test/eigen_test.cc	/^struct VectorLess {$/;"	s	file:
VertId	test/nektar_align.cc	/^  VertId(apf::MeshEntity* a, long b):$/;"	f	struct:VertId
VertId	test/nektar_align.cc	/^struct VertId {$/;"	s	file:
VertIdArray	test/nektar_align.cc	/^typedef std::vector<VertId> VertIdArray;$/;"	t	file:
VertRemover	ma/maVertRemover.h	/^class VertRemover$/;"	c	namespace:ma
Vertex	apf/apfShape.cc	/^    class Vertex : public EntityShape$/;"	c	class:apf::LagrangeCubic	file:
Vertex	apf/apfShape.cc	/^    class Vertex : public EntityShape$/;"	c	class:apf::Linear	file:
Vertex	crv/crvBezier.cc	/^  class Vertex : public apf::EntityShape$/;"	c	class:crv::Bezier	file:
Vertex shape functions	apf/hierarchic.tex	/^\\end{align*}$/;"	b
VertexIteratorSIM	apf_sim/apfSIM.cc	/^    VertexIteratorSIM(pMesh part)$/;"	f	class:apf::VertexIteratorSIM
VertexIteratorSIM	apf_sim/apfSIM.cc	/^class VertexIteratorSIM : public IteratorSIM$/;"	c	namespace:apf	file:
Vertices	mds/mdsANSYS.cc	/^typedef std::map<int, MeshEntity*> Vertices;$/;"	t	namespace:apf	file:
VoronoiShape	apf/apfIPShape.cc	/^    VoronoiShape(int d, int o) :$/;"	f	class:apf::VoronoiShape
VoronoiShape	apf/apfIPShape.cc	/^class VoronoiShape : public IPBase$/;"	c	namespace:apf	file:
Vortex	test/fusion.cc	/^    Vortex(ma::Mesh* m)$/;"	f	class:Vortex
Vortex	test/fusion.cc	/^class Vortex : public ma::AnisotropicFunction$/;"	c	file:
Vortex	test/fusion3.cc	/^    Vortex(ma::Mesh* m, double center[3], double len)$/;"	f	class:Vortex
Vortex	test/fusion3.cc	/^class Vortex : public ma::AnisotropicFunction$/;"	c	file:
VtxBalancer	parma/diffMC/parma_vtxBalancer.cc	/^      VtxBalancer(apf::Mesh* m, double f, int v)$/;"	f	class:__anon55::VtxBalancer
VtxBalancer	parma/diffMC/parma_vtxBalancer.cc	/^  class VtxBalancer : public parma::Balancer {$/;"	c	namespace:__anon55	file:
VtxEdgeBalancer	parma/diffMC/parma_vtxEdgeElmBalancer.cc	/^      VtxEdgeBalancer(apf::Mesh* m, double f, double maxV, int v)$/;"	f	class:__anon46::VtxEdgeBalancer
VtxEdgeBalancer	parma/diffMC/parma_vtxEdgeElmBalancer.cc	/^  class VtxEdgeBalancer : public parma::Balancer {$/;"	c	namespace:__anon46	file:
VtxEdgeElmBalancer	parma/diffMC/parma_vtxEdgeElmBalancer.cc	/^      VtxEdgeElmBalancer(apf::Mesh* m, double f, int v)$/;"	f	class:__anon46::VtxEdgeElmBalancer
VtxEdgeElmBalancer	parma/diffMC/parma_vtxEdgeElmBalancer.cc	/^  class VtxEdgeElmBalancer : public parma::Balancer {$/;"	c	namespace:__anon46	file:
VtxEdgeTargets	parma/diffMC/parma_vtxEdgeTargets.cc	/^      VtxEdgeTargets(Sides* s, Weights* w[2], int sideTol, double vtxTol,$/;"	f	class:parma::VtxEdgeTargets
VtxEdgeTargets	parma/diffMC/parma_vtxEdgeTargets.cc	/^  class VtxEdgeTargets : public Targets {$/;"	c	namespace:parma	file:
VtxElmBalancer	parma/diffMC/parma_vtxElmBalancer.cc	/^    VtxElmBalancer(apf::Mesh* m, double f, int v)$/;"	f	class:VtxElmBalancer
VtxElmBalancer	parma/diffMC/parma_vtxElmBalancer.cc	/^class VtxElmBalancer : public parma::Balancer {$/;"	c	file:
VtxGhostFinder	parma/diffMC/parma_ghostWeights.cc	/^      VtxGhostFinder(apf::Mesh* m, apf::MeshTag* w, int l)$/;"	f	class:parma::VtxGhostFinder
VtxGhostFinder	parma/diffMC/parma_ghostWeights.cc	/^  class VtxGhostFinder : public GhostFinder {$/;"	c	namespace:parma	file:
VtxLtSelector	parma/diffMC/parma_ltSelector.cc	/^      VtxLtSelector(apf::Mesh* m, apf::MeshTag* w, double primeMaxW, int primeDim)$/;"	f	class:__anon58::VtxLtSelector
VtxLtSelector	parma/diffMC/parma_ltSelector.cc	/^  class VtxLtSelector : public LtSelector {$/;"	c	namespace:__anon58	file:
VtxSelector	parma/diffMC/parma_vtxSelector.cc	/^  VtxSelector::VtxSelector(apf::Mesh* m, apf::MeshTag* w)$/;"	f	class:parma::VtxSelector
VtxSelector	parma/diffMC/parma_vtxSelector.h	/^  class VtxSelector : public Selector {$/;"	c	namespace:parma
VtxSides	parma/diffMC/parma_vtxSides.cc	/^      VtxSides(apf::Mesh* m) : Sides(m) {$/;"	f	class:parma::VtxSides
VtxSides	parma/diffMC/parma_vtxSides.cc	/^  class VtxSides : public Sides {$/;"	c	namespace:parma	file:
W0	mds/mds.c	/^static int const W0[] = {MDS_VERTEX,MDS_VERTEX,MDS_VERTEX$/;"	v	file:
W01	mds/mds.c	/^static int const W01[] = {0,1,1,2,2,0$/;"	v	file:
W1	mds/mds.c	/^static int const W1[] = {MDS_EDGE,MDS_EDGE,MDS_EDGE$/;"	v	file:
W10	mds/mds.c	/^static int const W10[] = {0,2,0,1,1,2$/;"	v	file:
W12	mds/mds.c	/^static int const W12[] = {0,1,2$/;"	v	file:
W2	mds/mds.c	/^static int const W2[] = {MDS_TRIANGLE$/;"	v	file:
W21	mds/mds.c	/^static int const W21[] = {0,1,0,2,0,3$/;"	v	file:
WEDGE	phasta/phBlock.h	/^  WEDGE        = 3,$/;"	e	enum:ph::__anon86
WEDGE_QUAD	phasta/phBlock.h	/^  WEDGE_QUAD   = 4,$/;"	e	enum:ph::__anon86
WEDGE_TRI	phasta/phBlock.h	/^  WEDGE_TRI    = 3,$/;"	e	enum:ph::__anon86
WeightSideTargets	parma/diffMC/parma_weightSideTargets.cc	/^      WeightSideTargets(Sides* s, Weights* w, int sideTol, double alpha) {$/;"	f	class:parma::WeightSideTargets
WeightSideTargets	parma/diffMC/parma_weightSideTargets.cc	/^  class WeightSideTargets : public Targets {$/;"	c	namespace:parma	file:
WeightTargets	parma/diffMC/parma_weightTargets.cc	/^      WeightTargets(Sides* s, Weights* w, double alpha) {$/;"	f	class:parma::WeightTargets
WeightTargets	parma/diffMC/parma_weightTargets.cc	/^  class WeightTargets : public Targets {$/;"	c	namespace:parma	file:
Weights	parma/diffMC/parma_weights.h	/^      Weights(apf::Mesh*, apf::MeshTag*, Sides*) {}$/;"	f	class:parma::Weights
Weights	parma/diffMC/parma_weights.h	/^  class Weights : public Associative<double> {$/;"	c	namespace:parma
WingShock	test/capStoneAnisoAdaptWing.cc	/^    WingShock(ma::Mesh* m, double inFactor)$/;"	f	class:WingShock
WingShock	test/capStoneAnisoAdaptWing.cc	/^class WingShock : public ma::AnisotropicFunction$/;"	c	file:
WingShock	test/capStoneSizeFields.h	/^    WingShock(ma::Mesh* m, double inFactor)$/;"	f	class:WingShock
WingShock	test/capStoneSizeFields.h	/^class WingShock : public ma::AnisotropicFunction$/;"	c
Workers	design.tex	/^one of many possible states of each element.$/;"	s
WriteIPField	apf/apfVtk.cc	/^class WriteIPField : public FieldOp$/;"	c	namespace:apf	file:
ZDataGetter	ma/maExtrude.cc	/^  ZDataGetter(apf::Mesh* m):mesh(m) {}$/;"	f	struct:ma::__anon28::ZDataGetter
ZDataGetter	ma/maExtrude.cc	/^struct ZDataGetter : public DataGetter {$/;"	s	namespace:ma::__anon28	file:
ZDataSetter	ma/maExtrude.cc	/^  ZDataSetter(Mesh* m):mesh(m) {}$/;"	f	struct:ma::__anon28::ZDataSetter
ZDataSetter	ma/maExtrude.cc	/^struct ZDataSetter : public DataSetter {$/;"	s	namespace:ma::__anon28	file:
ZERO	mds/mds.c	36;"	d	file:
ZeroOp	apf/apfField.cc	/^  ZeroOp(Field* f)$/;"	f	struct:apf::ZeroOp
ZeroOp	apf/apfField.cc	/^struct ZeroOp : public FieldOp$/;"	s	namespace:apf	file:
ZoltanApproach	zoltan/apfZoltan.h	/^enum ZoltanApproach {$/;"	g	namespace:apf
ZoltanBalancer	zoltan/apfZoltan.cc	/^    ZoltanBalancer(Mesh* m, int method, int approach, bool debug):$/;"	f	class:apf::ZoltanBalancer
ZoltanBalancer	zoltan/apfZoltan.cc	/^class ZoltanBalancer : public Balancer$/;"	c	namespace:apf	file:
ZoltanData	zoltan/apfZoltanCallbacks.cc	/^ZoltanData::ZoltanData(ZoltanMesh* zb_) : zb(zb_)$/;"	f	class:apf::ZoltanData
ZoltanData	zoltan/apfZoltanCallbacks.h	/^class ZoltanData {$/;"	c	namespace:apf
ZoltanMesh	zoltan/apfZoltanMesh.cc	/^ZoltanMesh::ZoltanMesh(Mesh* mesh_, bool isLocal_, int method_, int approach_,$/;"	f	class:apf::ZoltanMesh
ZoltanMesh	zoltan/apfZoltanMesh.h	/^class ZoltanMesh$/;"	c	namespace:apf
ZoltanMethod	zoltan/apfZoltan.h	/^enum ZoltanMethod {$/;"	g	namespace:apf
ZoltanSplitter	zoltan/apfZoltan.cc	/^    ZoltanSplitter(Mesh* m, int method, int approach,$/;"	f	class:apf::ZoltanSplitter
ZoltanSplitter	zoltan/apfZoltan.cc	/^class ZoltanSplitter : public Splitter$/;"	c	namespace:apf	file:
_DIMS_	pumi/mPartEntityContainer.h	/^    enum { _DIMS_ = 4 };$/;"	e	enum:mPartEntityContainer::__anon76
_GENERIC_ITERATOR_H_	pumi/GenIterator.h	11;"	d
_POSIX_C_SOURCE	gmi/gmi_file.c	2;"	d	file:
_PUMI_ERROR_CODE_H_	pumi/pumi_errorcode.h	11;"	d
_PUMI_ITERATOR_H_	pumi/pumi_iter.h	11;"	d
__APF_MIS__	apf/apfMIS.h	2;"	d
__init__	parma/extractParmaResults.py	/^  def __init__(self,name):$/;"	m	class:metric
_instance	pumi/pumi.h	/^  static pumi* _instance;$/;"	m	class:pumi
_instance	pumi/pumi_mesh.cc	/^pumi* pumi::_instance=NULL;$/;"	m	class:pumi	file:
_zero_	mth/mthAD.h	/^    const static double _zero_;$/;"	m	class:mth::AD
_zero_	mth/mthAD.h	/^const double mth::AD<T, 0>::_zero_ = 0.;$/;"	m	class:mth::mth::AD
a	apf/apfFieldOf.cc	/^    double a;$/;"	m	class:apf::Axpy	file:
a	crv/crvShape.cc	/^  Adapt* a;$/;"	m	struct:crv::IsBadCrvQuality	file:
a	ma/maCoarsen.cc	/^  Adapt* a;$/;"	m	struct:ma::ShouldCollapse	file:
a	ma/maCrawler.cc	/^  Adapt* a;$/;"	m	struct:ma::LayerNumberer	file:
a	ma/maCrawler.cc	/^  Adapt* a;$/;"	m	struct:ma::TopFlagger	file:
a	ma/maLayerCoarsen.cc	/^  Adapt* a;$/;"	m	struct:ma::CurveLocalizer	file:
a	ma/maLayerCollapse.h	/^  Adapt* a;$/;"	m	struct:ma::LayerCollapse
a	ma/maLayerRefine.cc	/^  Adapt* a;$/;"	m	struct:ma::Disambiguator	file:
a	ma/maLayerRefine.cc	/^  Adapt* a;$/;"	m	struct:ma::SplitTagger	file:
a	ma/maLayerSnap.cc	/^  Adapt* a;$/;"	m	struct:ma::BaseTopLinker	file:
a	ma/maLayerSnap.cc	/^  Adapt* a;$/;"	m	struct:ma::LayerSnapper	file:
a	ma/maLayerSnap.cc	/^  Adapt* a;$/;"	m	struct:ma::SnapTagger	file:
a	ma/maLayerSnap.cc	/^  Adapt* a;$/;"	m	struct:ma::UnsnapChecker	file:
a	ma/maLayerSnap.cc	/^  Adapt* a;$/;"	m	struct:ma::Unsnapper	file:
a	ma/maRefine.cc	/^  Adapt* a;$/;"	m	struct:ma::ShouldSplit	file:
a	ma/maShape.cc	/^  Adapt* a;$/;"	m	struct:ma::IsBadQuality	file:
a	ma/maTetrahedronize.cc	/^  Adapt* a;$/;"	m	struct:ma::QuadMarker	file:
a	ma/maTetrahedronize.cc	/^  Adapt* a;$/;"	m	struct:ma::UnsafePrismOverride	file:
a	ma/maTetrahedronize.cc	/^  Adapt* a;$/;"	m	struct:ma::UnsafePyramidOverride	file:
a	parma/diffMC/parma_elmLtVtxEdgeSelector.cc	/^    double a;$/;"	m	struct:__anon64::dtwo	file:
a_data	test/bezierMisc.cc	/^static double const a_data[35][35] = {{1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},$/;"	v	file:
a_data	test/qr.cc	/^static double const a_data[16][10] = {$/;"	v	file:
a_invdata	test/bezierMisc.cc	/^static double const a_invdata[35][35] = {{1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},$/;"	v	file:
a_param	test/fusion.cc	/^double const a_param = 0.2;$/;"	v
abs	mth/mthAD.h	/^AD<T, N> abs(AD<T, N> const& A)$/;"	f	namespace:mth
accept	ma/maDoubleSplitCollapse.cc	/^void DoubleSplitCollapse::accept()$/;"	f	class:ma::DoubleSplitCollapse
accept	ma/maFaceSplitCollapse.cc	/^  void FaceSplitCollapse::accept()$/;"	f	class:ma::FaceSplitCollapse
acceptChanges	apf_cap/apfCAP.h	/^    void acceptChanges() {}$/;"	f	class:apf::MeshCAP
acceptChanges	apf_sim/apfSIM.h	/^    void acceptChanges() {}$/;"	f	class:apf::MeshSIM
acceptChanges	mds/apfMDS.cc	/^    void acceptChanges()$/;"	f	class:apf::MeshMDS
acceptTriangle	ma/maEdgeSwap.cc	/^    void acceptTriangle(int unique_i, int local_i)$/;"	f	class:ma::SwapCavity
acceptTriangulation	ma/maEdgeSwap.cc	/^    void acceptTriangulation()$/;"	f	class:ma::SwapCavity
accountForTets	ma/maBalance.cc	/^static double accountForTets(Adapt* a, int type, double weight)$/;"	f	namespace:ma
accumulate	apf/apf.cc	/^void accumulate(Field* f, Sharing* shr, bool delete_shr)$/;"	f	namespace:apf
acisExt	test/simTranslate.cc	/^static std::string acisExt = ".sat";$/;"	v	file:
action	pcu/pcu_coll.h	/^  int (*action)(int bit); \/\/return action enum for this step$/;"	m	struct:__anon39
active	parma/diffMC/parma_components.cc	/^      bool active;$/;"	m	class:parma::dcComponents::BdryItr	file:
adapt	crv/crvAdapt.cc	/^void adapt(ma::Input* in)$/;"	f	namespace:crv
adapt	crv/crvShapeHandler.cc	/^    ma::Adapt* adapt;$/;"	m	class:crv::BezierHandler	file:
adapt	crv/crvShapeHandler.cc	/^    ma::Adapt* adapt;$/;"	m	class:crv::BezierTransfer	file:
adapt	dsp/dspAdapters.cc	/^  virtual void adapt(apf::Mesh2* m)$/;"	f	class:dsp::EmptyAdapter
adapt	dsp/dspAdapters.cc	/^  virtual void adapt(apf::Mesh2* m)$/;"	f	class:dsp::UniformAdapter
adapt	ma/ma.cc	/^void adapt(Input* in)$/;"	f	namespace:ma
adapt	ma/ma.cc	/^void adapt(Mesh* m, AnisotropicFunction* f, SolutionTransfer* s)$/;"	f	namespace:ma
adapt	ma/ma.cc	/^void adapt(Mesh* m, IsotropicFunction* f, SolutionTransfer* s)$/;"	f	namespace:ma
adapt	ma/maAdapt.h	/^    Adapt* adapt;$/;"	m	class:ma::DeleteCallback
adapt	ma/maCoarsen.cc	/^    Adapt* adapt;$/;"	m	class:ma::IndependentSetFinder	file:
adapt	ma/maCollapse.h	/^    Adapt* adapt;$/;"	m	class:ma::Collapse
adapt	ma/maMatchedCollapse.h	/^  Adapt* adapt;$/;"	m	struct:ma::MatchedCollapse
adapt	ma/maRefine.h	/^    Adapt* adapt;$/;"	m	class:ma::Refine
adapt	ma/maRegionCollapse.h	/^    Adapt* adapt;$/;"	m	class:ma::RegionCollapse
adapt	phasta/phAdapt.cc	/^  void adapt(apf::Mesh2* m, apf::Field* szFld) {$/;"	f	namespace:chef
adapt	phasta/phAdapt.cc	/^  void adapt(apf::Mesh2* m, apf::Field* szFld, ph::Input& in) {$/;"	f	namespace:chef
adapt	phasta/phAdapt.cc	/^void adapt(Input& in, apf::Mesh2* m)$/;"	f	namespace:ph
adaptErrorFieldIndex	phasta/phInput.h	/^    int adaptErrorFieldIndex;$/;"	m	class:ph::Input
adaptErrorFieldName	phasta/phInput.h	/^    std::string adaptErrorFieldName;$/;"	m	class:ph::Input
adaptErrorThreshold	phasta/phInput.h	/^    double adaptErrorThreshold;$/;"	m	class:ph::Input
adaptFlag	phasta/phInput.h	/^    int adaptFlag;$/;"	m	class:ph::Input
adaptLevelSet	phasta/phAdapt.cc	/^  void adaptLevelSet(ph::Input& in, apf::Mesh2* m)$/;"	f	namespace:chef
adaptMatching	ma/ma.cc	/^void adaptMatching(Mesh* m, int n, SolutionTransfer* s)$/;"	f	namespace:ma
adaptShrinkLimit	phasta/phInput.h	/^    double adaptShrinkLimit;$/;"	m	class:ph::Input
adaptShrunken	phasta/phAdapt.cc	/^void adaptShrunken(apf::Mesh2* m, double minPartDensity,$/;"	f	namespace:ph
adaptStrategy	phasta/phInput.h	/^    int adaptStrategy;$/;"	m	class:ph::Input
adaptVerbose	ma/ma.cc	/^void adaptVerbose(Input* in, bool verbose)$/;"	f	namespace:ma
adapter	crv/crvShape.cc	/^  Adapt* adapter;$/;"	m	class:crv::EdgeReshaper	file:
adapter	crv/crvShape.cc	/^  Adapt* adapter;$/;"	m	class:crv::EdgeSwapper	file:
adapter	crv/crvShapeFixer.h	/^    Adapt* adapter;$/;"	m	class:crv::CrvEdgeEdgeFixer
adapter	crv/crvShapeFixer.h	/^    Adapt* adapter;$/;"	m	class:crv::CrvLargeAngleTetFixer
adapter	crv/crvShapeFixer.h	/^    Adapt* adapter;$/;"	m	class:crv::CrvLargeAngleTriFixer
adapter	crv/crvShapeFixer.h	/^    Adapt* adapter;$/;"	m	class:crv::CrvShortEdgeFixer
adapter	ma/maAdapt.h	/^    Adapt* adapter;$/;"	m	class:ma::Cavity
adapter	ma/maAdapt.h	/^  Adapt* adapter;$/;"	m	struct:ma::HasFlag
adapter	ma/maEdgeSwap.cc	/^    Adapt* adapter;$/;"	m	class:ma::EdgeSwap2D	file:
adapter	ma/maEdgeSwap.cc	/^    Adapt* adapter;$/;"	m	class:ma::EdgeSwap3D	file:
adapter	ma/maEdgeSwap.cc	/^    Adapt* adapter;$/;"	m	class:ma::SwapCavity	file:
adapter	ma/maFaceSplit.h	/^    Adapt* adapter;$/;"	m	class:ma::FaceSplit
adapter	ma/maMatchedSnapper.h	/^    Adapt* adapter;$/;"	m	class:ma::MatchedSnapper
adapter	ma/maShape.cc	/^    Adapt* adapter;$/;"	m	class:ma::FixBySwap	file:
adapter	ma/maShape.cc	/^    Adapt* adapter;$/;"	m	class:ma::LargeAngleTetAligner	file:
adapter	ma/maShape.cc	/^    Adapt* adapter;$/;"	m	class:ma::LargeAngleTetFixer	file:
adapter	ma/maShape.cc	/^    Adapt* adapter;$/;"	m	class:ma::LargeAngleTriFixer	file:
adapter	ma/maShape.cc	/^    Adapt* adapter;$/;"	m	class:ma::QualityImprover2D	file:
adapter	ma/maShape.cc	/^    Adapt* adapter;$/;"	m	class:ma::ShortEdgeFixer	file:
adapter	ma/maShortEdgeRemover.h	/^    Adapt* adapter;$/;"	m	class:ma::ShortEdgeRemover
adapter	ma/maSnap.cc	/^    Adapt* adapter;$/;"	m	class:ma::SnapAll	file:
adapter	ma/maSnap.cc	/^    Adapt* adapter;$/;"	m	class:ma::SnapMatched	file:
adapter	ma/maSnap_mohara.cc	/^    Adapt* adapter;$/;"	m	class:ma::SnapAll	file:
adapter	ma/maSnap_mohara.cc	/^    Adapt* adapter;$/;"	m	class:ma::SnapMatched	file:
adapter	ma/maSnapper.h	/^    Adapt* adapter;$/;"	m	class:ma::FirstProblemPlane
adapter	ma/maSnapper.h	/^    Adapt* adapter;$/;"	m	class:ma::Snapper
adapter	ma/maTetrahedronize.cc	/^  Adapt* adapter;$/;"	m	struct:ma::QuadFlagger	file:
adapter	ma/maVertRemover.h	/^    Adapt* adapter;$/;"	m	class:ma::VertRemover
add	ma/maSolutionTransfer.cc	/^void SolutionTransfers::add(SolutionTransfer* t)$/;"	f	class:ma::SolutionTransfers
add	parma/diffMC/parma_edgeEqVtxSelector.cc	/^      virtual double add(apf::MeshEntity*, apf::Up& cavity, const int destPid,$/;"	f	class:__anon52::EdgeEqVtx
add	parma/diffMC/parma_elmLtVtxEdgeSelector.cc	/^      virtual double add(apf::MeshEntity*, apf::Up& cavity,$/;"	f	class:__anon64::ElmLtVtxEdgeSelector
add	parma/diffMC/parma_elmSelector.cc	/^      virtual double add(apf::MeshEntity*, apf::Up& cavity, const int destPid,$/;"	f	class:__anon56::ElmSelector
add	parma/diffMC/parma_ltSelector.cc	/^      double add(apf::MeshEntity* v, apf::Up& cavity, const int destPid,$/;"	f	class:__anon58::VtxLtSelector
add	parma/diffMC/parma_ltSelector.cc	/^      double add(apf::MeshEntity*, apf::Up& cavity, const int destPid,$/;"	f	class:__anon58::ElmLtSelector
add	parma/diffMC/parma_shapeSelector.cc	/^  void add(apf::Up& cavity, const int destPid,$/;"	f	namespace:__anon57
add	parma/diffMC/parma_vtxSelector.cc	/^  double VtxSelector::add(apf::MeshEntity* v, apf::Up& cavity, const int destPid,$/;"	f	class:parma::VtxSelector
add	pumi/mPartEntityContainer.cc	/^void mPartEntityContainer::add(int d, gEntity* e)$/;"	f	class:mPartEntityContainer
add	pumi/pumi.h	/^  void add (int d, gEntity *ge) {allEntities.add(d, ge);}$/;"	f	class:gModel
addAllLayerElements	ma/maTetrahedronize.cc	/^static void addAllLayerElements(Refine* r)$/;"	f	namespace:ma
addAllMarkedEdges	ma/maRefine.cc	/^void addAllMarkedEdges(Refine* r)$/;"	f	namespace:ma
addAttribute	phasta/phAttrib.cc	/^static void addAttribute(BCFactories& fs, pAttribute a, pGEntity ge,$/;"	f	file:
addAttributes	phasta/phAttrib.cc	/^static void addAttributes(BCFactories& fs, pPList as, pGEntity ge,$/;"	f	file:
addCavityEdge	parma/diffMC/parma_edgeEqVtxSelector.cc	/^      void addCavityEdge(apf::MeshEntity* e, SetEnt& s) {$/;"	f	class:__anon52::EdgeEqVtx
addEdgePostAllocation	ma/maRefine.cc	/^void addEdgePostAllocation(Refine* refiner, Entity* e, int counts[4])$/;"	f	namespace:ma
addEdgePreAllocation	ma/maRefine.cc	/^void addEdgePreAllocation(Refine* r, Entity* e, int counts[4])$/;"	f	namespace:ma
addElementToPatch	spr/sprRecoverField.cc	/^static void addElementToPatch(Patch* p, apf::MeshEntity* e)$/;"	f	namespace:spr
addElementsThatShare	spr/sprRecoverField.cc	/^static bool addElementsThatShare(Patch* p, int dim,$/;"	f	namespace:spr
addElementsToPatch	spr/sprRecoverField.cc	/^static void addElementsToPatch(Patch* p, apf::DynamicArray<apf::MeshEntity*>& es)$/;"	f	namespace:spr
addElmVtxToBdry	parma/diffMC/parma_components.cc	/^  void DCC::addElmVtxToBdry(apf::Downward& verts, const int nv, unsigned compId) {$/;"	f	class:parma::DCC
addEntity	ma/maAdapt.cc	/^void NewEntities::addEntity(Entity* e)$/;"	f	class:ma::NewEntities
addEntry	pumi/GenTag.cc	/^static Entry* addEntry($/;"	f	file:
addField	apf/apfMesh.cc	/^void Mesh::addField(Field* f)$/;"	f	class:apf::Mesh
addFieldData	apf/apfFieldData.cc	/^void addFieldData(FieldDataOf<T>* from1, FieldDataOf<T>* from2, FieldDataOf<T>* to)$/;"	f	namespace:apf
addFields	test/runSimxAnisoAdapt.cc	/^void addFields(apf::Mesh2* m,$/;"	f
addGhost	apf_cap/apfCAP.h	/^    void addGhost(MeshEntity*, int, MeshEntity*) {}$/;"	f	class:apf::MeshCAP
addGhost	apf_sim/apfSIM.h	/^    void addGhost(MeshEntity*, int, MeshEntity*) {}$/;"	f	class:apf::MeshSIM
addGhost	mds/apfMDS.cc	/^    void addGhost(MeshEntity* e, int p, MeshEntity* r)$/;"	f	class:apf::MeshMDS
addGlobalNumbering	apf/apfMesh.cc	/^void Mesh::addGlobalNumbering(GlobalNumbering* n)$/;"	f	class:apf::Mesh
addIslandPyramids	ma/maTetrahedronize.cc	/^static void addIslandPyramids(Refine* r)$/;"	f	namespace:ma
addMatch	apf_cap/apfCAP.h	/^    void addMatch(MeshEntity*, int, MeshEntity*) {}$/;"	f	class:apf::MeshCAP
addMatch	apf_sim/apfSIM.h	/^    void addMatch(MeshEntity*, int, MeshEntity* ) {}$/;"	f	class:apf::MeshSIM
addMatch	mds/apfMDS.cc	/^    void addMatch(MeshEntity* e, int peer, MeshEntity* match)$/;"	f	class:apf::MeshMDS
addMatch	phasta/phFilterMatching.cc	/^static void addMatch(gmi_ent* a, gmi_ent* b, ModelMatching& mm)$/;"	f	namespace:ph
addModelUse	mds/apfBox.cc	/^void BoxBuilder::addModelUse(gmi_base* gb, agm_bdry ab, Indices di)$/;"	f	class:apf::BoxBuilder
addNetNeighbors	parma/diffMC/maximalIndependentSet/misLuby.cc	/^void partInfo::addNetNeighbors(vector<adjPart>& nbNet) {$/;"	f	class:partInfo
addNumbering	apf/apfMesh.cc	/^void Mesh::addNumbering(Numbering* n)$/;"	f	class:apf::Mesh
addOneTri	test/fusion2.cc	/^static void addOneTri(apf::Mesh2* m)$/;"	f	file:
addParamCoords	ma/maDBG.cc	/^void addParamCoords(ma::Adapt* a,$/;"	f	namespace:ma_dbg
addRemote	apf_cap/apfCAP.h	/^    void addRemote(MeshEntity*, int, MeshEntity*) {}$/;"	f	class:apf::MeshCAP
addRemote	apf_sim/apfSIM.h	/^    void addRemote(MeshEntity*, int, MeshEntity*) {}$/;"	f	class:apf::MeshSIM
addRemote	mds/apfMDS.cc	/^    void addRemote(MeshEntity* e, int p, MeshEntity* r)$/;"	f	class:apf::MeshMDS
addScalarField	test/capStoneAttachSolution.cc	/^apf::Field* addScalarField(apf::Mesh2* m, const std::vector<row> t, const char* name, int col, int strandSize)$/;"	f
addSizesToSimxMesh	test/runSimxAnisoAdapt.cc	/^pMSAdapt addSizesToSimxMesh($/;"	f
addTargetLocation	ma/maDBG.cc	/^void addTargetLocation(ma::Adapt* a,$/;"	f	namespace:ma_dbg
addVector3Field	test/capStoneAttachSolution.cc	/^apf::Field* addVector3Field(apf::Mesh2* m, const std::vector<row> t, const char* name,$/;"	f
add_adj	test/bezierElevation.cc	/^agm_use add_adj(gmi_model* m, agm_bdry b, int tag)$/;"	f
add_adj	test/bezierMesh.cc	/^agm_use add_adj(gmi_model* m, agm_bdry b, int tag)$/;"	f
add_adj	test/bezierRefine.cc	/^agm_use add_adj(gmi_model* m, agm_bdry b, int tag)$/;"	f
add_adj	test/bezierSubdivision.cc	/^agm_use add_adj(gmi_model* m, agm_bdry b, int tag)$/;"	f
add_adj	test/bezierValidity.cc	/^agm_use add_adj(gmi_model* m, agm_bdry b, int tag)$/;"	f
add_adj	test/fusion.cc	/^agm_use add_adj(gmi_model* m, agm_bdry b, int tag)$/;"	f
add_adj	test/fusion3.cc	/^agm_use add_adj(gmi_model* m, agm_bdry b, int tag)$/;"	f
add_bdry	test/bezierElevation.cc	/^agm_bdry add_bdry(gmi_model* m, gmi_ent* e)$/;"	f
add_bdry	test/bezierMesh.cc	/^agm_bdry add_bdry(gmi_model* m, gmi_ent* e)$/;"	f
add_bdry	test/bezierRefine.cc	/^agm_bdry add_bdry(gmi_model* m, gmi_ent* e)$/;"	f
add_bdry	test/bezierSubdivision.cc	/^agm_bdry add_bdry(gmi_model* m, gmi_ent* e)$/;"	f
add_bdry	test/bezierValidity.cc	/^agm_bdry add_bdry(gmi_model* m, gmi_ent* e)$/;"	f
add_bdry	test/fusion3.cc	/^agm_bdry add_bdry(gmi_model* m, gmi_ent* e)$/;"	f
add_ent	mds/mds.c	/^static mds_id add_ent(struct mds* m, int t, mds_id* from)$/;"	f	file:
adjPart	parma/diffMC/maximalIndependentSet/mis.h	/^    } adjPart;$/;"	t	namespace:misLuby	typeref:struct:misLuby::AdjPart
adjPartIds	parma/diffMC/maximalIndependentSet/mis.h	/^        std::vector<int> adjPartIds;$/;"	m	struct:misLuby::PartInfo
adjReorder	apf/apfAdjReorder.cc	/^  int adjReorder(Numbering * num, Sharing * shr)$/;"	f	namespace:apf
adjacent	gmi/gmi.h	/^  struct gmi_set* (*adjacent)(struct gmi_model* m, struct gmi_ent* e, int dim);$/;"	m	struct:gmi_model_ops	typeref:struct:gmi_model_ops::adjacent
adjacent	gmi_cap/gmi_cap.cc	/^static gmi_set* adjacent(gmi_model* m, gmi_ent* e, int dim)$/;"	f	file:
adjacent	gmi_sim/gmi_sim.cc	/^static gmi_set* adjacent(gmi_model* m, gmi_ent* e, int dim)$/;"	f	file:
adjacentCount	apf/apfMesh.cc	/^int const Mesh::adjacentCount[TYPES][4] = $/;"	m	class:apf::Mesh	file:
adjacentCount	apf/apfMesh.h	/^    static int const adjacentCount[TYPES][4];$/;"	m	class:apf::Mesh
afterBuilding	ma/maAdapt.cc	/^void Cavity::afterBuilding()$/;"	f	class:ma::Cavity
afterTrying	ma/maAdapt.cc	/^void Cavity::afterTrying()$/;"	f	class:ma::Cavity
agm	gmi/agm.c	/^struct agm {$/;"	s	file:
agm_add_bdry	gmi/agm.c	/^struct agm_bdry agm_add_bdry(struct agm* m, struct agm_ent e)$/;"	f
agm_add_ent	gmi/agm.c	/^struct agm_ent agm_add_ent(struct agm* m, enum agm_ent_type t)$/;"	f
agm_add_use	gmi/agm.c	/^struct agm_use agm_add_use(struct agm* m, struct agm_bdry b, struct agm_ent of)$/;"	f
agm_bdry	gmi/agm.h	/^struct agm_bdry {$/;"	s
agm_bdry_count	gmi/agm.c	/^int agm_bdry_count(struct agm* m, enum agm_bdry_type t)$/;"	f
agm_bdry_count_of	gmi/agm.c	/^int agm_bdry_count_of(struct agm* m, struct agm_ent e)$/;"	f
agm_bdry_eq	gmi/agm.c	/^int agm_bdry_eq(struct agm_bdry a, struct agm_bdry b)$/;"	f
agm_bdry_null	gmi/agm.c	/^int agm_bdry_null(struct agm_bdry b)$/;"	f
agm_bdry_type	gmi/agm.h	/^enum agm_bdry_type {$/;"	g
agm_bounds	gmi/agm.c	/^struct agm_ent agm_bounds(struct agm* m, struct agm_bdry b)$/;"	f
agm_dim_from_type	gmi/agm.c	/^int agm_dim_from_type(enum agm_ent_type t)$/;"	f
agm_down_count	gmi/agm.c	/^int agm_down_count(struct agm* m, struct agm_ent e)$/;"	f
agm_ent	gmi/agm.h	/^struct agm_ent {$/;"	s
agm_ent_count	gmi/agm.c	/^int agm_ent_count(struct agm* m, enum agm_ent_type t)$/;"	f
agm_ent_eq	gmi/agm.c	/^int agm_ent_eq(struct agm_ent a, struct agm_ent b)$/;"	f
agm_ent_null	gmi/agm.c	/^int agm_ent_null(struct agm_ent e)$/;"	f
agm_ent_type	gmi/agm.h	/^enum agm_ent_type {$/;"	g
agm_find_path	gmi/agm.c	/^int agm_find_path(struct agm* m, struct agm_ent from, struct agm_ent to,$/;"	f
agm_find_use_by_bdry	gmi/agm.c	/^struct agm_use agm_find_use_by_bdry(struct agm* m, struct agm_ent of,$/;"	f
agm_find_use_by_ent	gmi/agm.c	/^struct agm_use agm_find_use_by_ent(struct agm* m, struct agm_ent of,$/;"	f
agm_first_bdry_of	gmi/agm.c	/^struct agm_bdry agm_first_bdry_of(struct agm* m, struct agm_ent e)$/;"	f
agm_first_ent	gmi/agm.c	/^struct agm_ent agm_first_ent(struct agm* m, enum agm_ent_type t)$/;"	f
agm_first_use_by	gmi/agm.c	/^struct agm_use agm_first_use_by(struct agm* m, struct agm_bdry b)$/;"	f
agm_first_use_of	gmi/agm.c	/^struct agm_use agm_first_use_of(struct agm* m, struct agm_ent e)$/;"	f
agm_free	gmi/agm.c	/^void agm_free(struct agm* m)$/;"	f
agm_free_tags	gmi/agm.c	/^void agm_free_tags(struct agm* m)$/;"	f
agm_from_gmi	gmi/gmi_base.c	/^struct agm_ent agm_from_gmi(struct gmi_ent* e)$/;"	f
agm_new	gmi/agm.c	/^struct agm* agm_new(void)$/;"	f
agm_new_tag	gmi/agm.c	/^struct agm_tag* agm_new_tag(struct agm* m, int bytes)$/;"	f
agm_next_bdry_of	gmi/agm.c	/^struct agm_bdry agm_next_bdry_of(struct agm* m, struct agm_bdry b)$/;"	f
agm_next_ent	gmi/agm.c	/^struct agm_ent agm_next_ent(struct agm* m, struct agm_ent e)$/;"	f
agm_next_use_by	gmi/agm.c	/^struct agm_use agm_next_use_by(struct agm* m, struct agm_use u)$/;"	f
agm_next_use_of	gmi/agm.c	/^struct agm_use agm_next_use_of(struct agm* m, struct agm_use u)$/;"	f
agm_obj_type	gmi/agm.h	/^enum agm_obj_type {$/;"	g
agm_reserve	gmi/agm.c	/^void agm_reserve(struct agm* m, enum agm_ent_type t, int n)$/;"	f
agm_tag	gmi/agm.c	/^struct agm_tag {$/;"	s	file:
agm_tag_at	gmi/agm.c	/^void* agm_tag_at(struct agm_tag* t, enum agm_obj_type o,$/;"	f
agm_tags	gmi/agm.c	/^struct agm_tags {$/;"	s	file:
agm_type_from_dim	gmi/agm.c	/^enum agm_ent_type agm_type_from_dim(int dim)$/;"	f
agm_use	gmi/agm.h	/^struct agm_use {$/;"	s
agm_use_count	gmi/agm.c	/^int agm_use_count(struct agm* m, enum agm_use_type t)$/;"	f
agm_use_count_by	gmi/agm.c	/^int agm_use_count_by(struct agm* m, struct agm_bdry b)$/;"	f
agm_use_count_of	gmi/agm.c	/^int agm_use_count_of(struct agm* m, struct agm_ent e)$/;"	f
agm_use_eq	gmi/agm.c	/^int agm_use_eq(struct agm_use a, struct agm_use b)$/;"	f
agm_use_null	gmi/agm.c	/^int agm_use_null(struct agm_use u)$/;"	f
agm_use_type	gmi/agm.h	/^enum agm_use_type {$/;"	g
agm_used	gmi/agm.c	/^struct agm_ent agm_used(struct agm* m, struct agm_use u)$/;"	f
agm_user	gmi/agm.c	/^struct agm_bdry agm_user(struct agm* m, struct agm_use u)$/;"	f
algorithm	crv/crv.h	/^  int algorithm;$/;"	m	class:crv::Quality
alignEdgeWithTri	crv/crvBezier.cc	/^static void alignEdgeWithTri(apf::Mesh* m, apf::MeshEntity* elem,$/;"	f	namespace:crv
alignElements	ma/maShape.cc	/^void alignElements(Adapt* a)$/;"	f	namespace:ma
alignForNektar	test/nektar_align.cc	/^static void alignForNektar(apf::Mesh2* m)$/;"	f	file:
alignLargeAngleTets	ma/maShape.cc	/^static void alignLargeAngleTets(Adapt* a)$/;"	f	namespace:ma
alignLargeAngleTris	ma/maShape.cc	/^static void alignLargeAngleTris(Adapt* a)$/;"	f	namespace:ma
alignLargeAngles	ma/maShape.cc	/^static void alignLargeAngles(Adapt* a)$/;"	f	namespace:ma
alignMdsMatches	mds/apfMDS.cc	/^bool alignMdsMatches(Mesh2* in)$/;"	f	namespace:apf
alignMdsRemotes	mds/apfMDS.cc	/^bool alignMdsRemotes(Mesh2* in)$/;"	f	namespace:apf
alignSharedNodes	apf/apfHierarchic.cc	/^    void alignSharedNodes(Mesh*, MeshEntity*, MeshEntity*, int order[])$/;"	f	class:apf::HTriangle3
alignSharedNodes	apf/apfShape.cc	/^        void alignSharedNodes(Mesh* m, MeshEntity* elem,$/;"	f	class:apf::LagrangeCubic::Tetrahedron
alignSharedNodes	apf/apfShape.cc	/^        void alignSharedNodes(Mesh* m, MeshEntity* elem,$/;"	f	class:apf::LagrangeCubic::Triangle
alignSharedNodes	apf/apfShape.cc	/^void EntityShape::alignSharedNodes(Mesh* m,$/;"	f	class:apf::EntityShape
alignSharedNodes	crv/crvBezier.cc	/^    void alignSharedNodes(apf::Mesh* m,$/;"	f	class:crv::Bezier::Tetrahedron
alignSharedNodes	crv/crvBezier.cc	/^    void alignSharedNodes(apf::Mesh* m,$/;"	f	class:crv::Bezier::Triangle
alignSharedNodes	crv/crvBezier.cc	/^    void alignSharedNodes(apf::Mesh* m,$/;"	f	class:crv::GregorySurface4::Tetrahedron
alignSharedNodes	crv/crvBezier.cc	/^    void alignSharedNodes(apf::Mesh* m,$/;"	f	class:crv::GregorySurface4::Triangle
alignSharedNodes	crv/crvBezier.cc	/^    void alignSharedNodes(apf::Mesh*,$/;"	f	class:crv::Bezier::Edge
alignSharedNodes	crv/crvBezier.cc	/^    void alignSharedNodes(apf::Mesh*,$/;"	f	class:crv::Bezier::Vertex
alignTet	test/nektar_align.cc	/^static void alignTet(apf::Mesh2* m, apf::GlobalNumbering* n, apf::MeshEntity* tet)$/;"	f	file:
alignTri	test/nektar_align.cc	/^static void alignTri(apf::Mesh2* m, apf::GlobalNumbering* n, apf::MeshEntity* tri)$/;"	f	file:
align_copies	mds/mds_apf.c	/^static int align_copies(struct mds_net* net, struct mds* m)$/;"	f	file:
align_quad	ma/maTetrahedronize.cc	/^static int align_quad(apf::Mesh* mesh, Entity* quad, Entity* canonical_0_vert)$/;"	f	namespace:ma
allEntities	pumi/pumi.h	/^  mPartEntityContainer allEntities;$/;"	m	class:gModel
all_templates	ma/maRefine.cc	/^static SplitFunction* all_templates[apf::Mesh::TYPES] =$/;"	m	namespace:ma	file:
alloc_adjacency	mds/mds.c	/^static void alloc_adjacency(struct mds* m, int from_dim, int to_dim)$/;"	f	file:
alloc_ent	mds/mds.c	/^static mds_id alloc_ent(struct mds* m, int t)$/;"	f	file:
alloc_links	mds/mds_net.c	/^static void alloc_links(struct mds_links* ln)$/;"	f	file:
allocate	apf_cap/apfCAP.cc	/^    virtual void* allocate()$/;"	f	class:apf::DoubleTagCAP
allocate	apf_cap/apfCAP.cc	/^    virtual void* allocate()$/;"	f	class:apf::IntTagCAP
allocate	apf_sim/apfSIM.cc	/^    virtual void* allocate()$/;"	f	class:apf::DoubleTagSIM
allocate	apf_sim/apfSIM.cc	/^    virtual void* allocate()$/;"	f	class:apf::IntTagSIM
allocate	apf_sim/apfSIM.cc	/^    virtual void* allocate()$/;"	f	class:apf::LongTagSIM
allocate	can/canNewArray.h	/^    void allocate(std::size_t n) {this->resize(n);}$/;"	f	class:can::NewArray
allocate	spr/sprRecoverField.cc	/^  void allocate(int np, int nc)$/;"	f	struct:spr::Samples
allocateRefine	ma/maRefine.cc	/^void allocateRefine(Refine* r, int counts[4])$/;"	f	namespace:ma
allocated	can/canNewArray.h	/^    bool allocated() const {return this->elems;}$/;"	f	class:can::NewArray
allocated	pcu/noto/noto_malloc.c	/^static size_t allocated = 0;$/;"	v	file:
allocated_mutex	pcu/noto/noto_malloc.c	/^static pthread_mutex_t allocated_mutex = PTHREAD_MUTEX_INITIALIZER;$/;"	v	file:
allowBaseToSplit	ma/maLayerRefine.cc	/^static void allowBaseToSplit(Adapt* a)$/;"	f	namespace:ma
allowLayerToCollapse	ma/maLayerCoarsen.cc	/^static void allowLayerToCollapse(Adapt* a)$/;"	f	namespace:ma
allowSplitCollapseOutsideLayer	ma/maLayer.cc	/^void allowSplitCollapseOutsideLayer(Adapt* a)$/;"	f	namespace:ma
allowSplitInLayer	ma/maLayer.cc	/^void allowSplitInLayer(Adapt* a)$/;"	f	namespace:ma
alpha	parma/diffMC/parma_step.h	/^      double alpha;$/;"	m	class:parma::Stepper
alpha	spr/sprEstimateTargetError.cc	/^  double alpha;$/;"	m	struct:spr::target::Estimation	file:
alphaDist	phasta/phInput.h	/^    double alphaDist;$/;"	m	class:ph::Input
alphaSize	phasta/phInput.h	/^    double alphaSize;$/;"	m	class:ph::Input
ansys2apf	mds/mdsANSYS.cc	/^static void ansys2apf(int ansysType, int& apfType, apf::FieldShape*& shape)$/;"	f	namespace:apf
apf	apf/apf.cc	/^namespace apf {$/;"	n	file:
apf	apf/apf.h	/^namespace apf {$/;"	n
apf	apf/apf2mth.h	/^namespace apf {$/;"	n
apf	apf/apfAdjReorder.cc	/^namespace apf {$/;"	n	file:
apf	apf/apfArray.h	/^namespace apf {$/;"	n
apf	apf/apfArrayData.cc	/^namespace apf {$/;"	n	file:
apf	apf/apfArrayData.h	/^namespace apf {$/;"	n
apf	apf/apfBoundaryToElementXi.cc	/^namespace apf {$/;"	n	file:
apf	apf/apfCavityOp.cc	/^namespace apf {$/;"	n	file:
apf	apf/apfCavityOp.h	/^namespace apf {$/;"	n
apf	apf/apfConstruct.cc	/^namespace apf {$/;"	n	file:
apf	apf/apfConvert.cc	/^namespace apf {$/;"	n	file:
apf	apf/apfConvert.h	/^namespace apf {$/;"	n
apf	apf/apfCoordData.cc	/^namespace apf {$/;"	n	file:
apf	apf/apfCoordData.h	/^namespace apf {$/;"	n
apf	apf/apfDynamicArray.h	/^namespace apf {$/;"	n
apf	apf/apfDynamicMatrix.h	/^namespace apf {$/;"	n
apf	apf/apfDynamicVector.h	/^namespace apf {$/;"	n
apf	apf/apfElement.cc	/^namespace apf {$/;"	n	file:
apf	apf/apfElement.h	/^namespace apf {$/;"	n
apf	apf/apfElementOf.h	/^namespace apf {$/;"	n
apf	apf/apfField.cc	/^namespace apf {$/;"	n	file:
apf	apf/apfField.h	/^namespace apf {$/;"	n
apf	apf/apfFieldData.cc	/^namespace apf {$/;"	n	file:
apf	apf/apfFieldData.h	/^namespace apf {$/;"	n
apf	apf/apfFieldOf.cc	/^namespace apf {$/;"	n	file:
apf	apf/apfFieldOf.h	/^namespace apf {$/;"	n
apf	apf/apfFile.cc	/^namespace apf {$/;"	n	file:
apf	apf/apfFile.h	/^namespace apf {$/;"	n
apf	apf/apfGeometry.cc	/^namespace apf {$/;"	n	file:
apf	apf/apfGeometry.h	/^namespace apf {$/;"	n
apf	apf/apfGradientByVolume.cc	/^namespace apf {$/;"	n	file:
apf	apf/apfHierarchic.cc	/^namespace apf {$/;"	n	file:
apf	apf/apfIPShape.cc	/^namespace apf {$/;"	n	file:
apf	apf/apfIntegrate.cc	/^namespace apf {$/;"	n	file:
apf	apf/apfIntegrate.h	/^namespace apf {$/;"	n
apf	apf/apfMIS.cc	/^namespace apf {    $/;"	n	file:
apf	apf/apfMIS.h	/^namespace apf{  $/;"	n
apf	apf/apfMatrix.cc	/^namespace apf {$/;"	n	file:
apf	apf/apfMatrix.h	/^namespace apf {$/;"	n
apf	apf/apfMatrixElement.cc	/^namespace apf {$/;"	n	file:
apf	apf/apfMatrixElement.h	/^namespace apf {$/;"	n
apf	apf/apfMatrixField.cc	/^namespace apf {$/;"	n	file:
apf	apf/apfMatrixField.h	/^namespace apf {$/;"	n
apf	apf/apfMesh.cc	/^namespace apf {$/;"	n	file:
apf	apf/apfMesh.h	/^namespace apf {$/;"	n
apf	apf/apfMesh2.cc	/^namespace apf$/;"	n	file:
apf	apf/apfMesh2.h	/^namespace apf {$/;"	n
apf	apf/apfMigrate.cc	/^namespace apf {$/;"	n	file:
apf	apf/apfMixedNumbering.cc	/^namespace apf {$/;"	n	file:
apf	apf/apfMixedNumbering.h	/^namespace apf {$/;"	n
apf	apf/apfNew.h	/^namespace apf {$/;"	n
apf	apf/apfNumbering.cc	/^namespace apf {$/;"	n	file:
apf	apf/apfNumbering.h	/^namespace apf {$/;"	n
apf	apf/apfNumberingClass.h	/^namespace apf {$/;"	n
apf	apf/apfPackedField.cc	/^namespace apf {$/;"	n	file:
apf	apf/apfPackedField.h	/^namespace apf {$/;"	n
apf	apf/apfPartition.cc	/^namespace apf {$/;"	n	file:
apf	apf/apfPartition.h	/^namespace apf {$/;"	n
apf	apf/apfScalarElement.cc	/^namespace apf {$/;"	n	file:
apf	apf/apfScalarElement.h	/^namespace apf {$/;"	n
apf	apf/apfScalarField.cc	/^namespace apf {$/;"	n	file:
apf	apf/apfScalarField.h	/^namespace apf {$/;"	n
apf	apf/apfShape.cc	/^namespace apf {$/;"	n	file:
apf	apf/apfShape.h	/^namespace apf {$/;"	n
apf	apf/apfSimplexAngleCalcs.cc	/^namespace apf {$/;"	n	file:
apf	apf/apfTagData.cc	/^namespace apf {$/;"	n	file:
apf	apf/apfTagData.h	/^namespace apf {$/;"	n
apf	apf/apfUserData.cc	/^namespace apf {$/;"	n	file:
apf	apf/apfUserData.h	/^namespace apf {$/;"	n
apf	apf/apfVector.cc	/^namespace apf {$/;"	n	file:
apf	apf/apfVector.h	/^namespace apf {$/;"	n
apf	apf/apfVectorElement.cc	/^namespace apf {$/;"	n	file:
apf	apf/apfVectorElement.h	/^namespace apf {$/;"	n
apf	apf/apfVectorField.cc	/^namespace apf {$/;"	n	file:
apf	apf/apfVectorField.h	/^namespace apf {$/;"	n
apf	apf/apfVerify.cc	/^namespace apf {$/;"	n	file:
apf	apf/apfVtk.cc	/^namespace apf {$/;"	n	file:
apf	apf/apfVtk.h	/^namespace apf {$/;"	n
apf	apf_cap/apfCAP.cc	/^namespace apf {$/;"	n	file:
apf	apf_cap/apfCAP.h	/^namespace apf {$/;"	n
apf	apf_sim/apfSIM.cc	/^namespace apf {$/;"	n	file:
apf	apf_sim/apfSIM.h	/^namespace apf {$/;"	n
apf	apf_sim/apfSIMDataOf.h	/^namespace apf {$/;"	n
apf	ma/maCollapse.h	/^namespace apf {$/;"	n
apf	ma/maMatchedSnapper.h	/^namespace apf {$/;"	n
apf	ma/maRegionCollapse.h	/^namespace apf {$/;"	n
apf	ma/maSnapper.h	/^namespace apf {$/;"	n
apf	mds/apfBox.cc	/^namespace apf {$/;"	n	file:
apf	mds/apfBox.h	/^namespace apf {$/;"	n
apf	mds/apfMDS.cc	/^namespace apf {$/;"	n	file:
apf	mds/apfMDS.h	/^namespace apf {$/;"	n
apf	mds/apfPM.cc	/^namespace apf {$/;"	n	file:
apf	mds/apfPM.h	/^namespace apf {$/;"	n
apf	mds/mdsANSYS.cc	/^namespace apf {$/;"	n	file:
apf	mds/mdsGmsh.cc	/^namespace apf {$/;"	n	file:
apf	mds/mdsUgrid.cc	/^namespace apf {$/;"	n	file:
apf	omega_h/apfOmega_h.cc	/^namespace apf {$/;"	n	file:
apf	omega_h/apfOmega_h.h	/^namespace apf {$/;"	n
apf	phasta/phAdapt.h	/^namespace apf {$/;"	n
apf	phasta/phBC.h	/^namespace apf {$/;"	n
apf	phasta/phBubble.h	/^namespace apf {$/;"	n
apf	phasta/phInterfaceCutter.cc	/^namespace apf {$/;"	n	file:
apf	phasta/phOutput.h	/^namespace apf {$/;"	n
apf	phasta/phPartition.h	/^namespace apf {$/;"	n
apf	sam/samElementCount.h	/^namespace apf {$/;"	n
apf	sam/samSz.h	/^namespace apf {$/;"	n
apf	stk/apfAlbany.h	/^namespace apf {$/;"	n
apf	stk/apfExodusOutput.cc	/^namespace apf {$/;"	n	file:
apf	stk/apfMeshSTK.cc	/^namespace apf {$/;"	n	file:
apf	stk/apfSTK.cc	/^namespace apf {$/;"	n	file:
apf	stk/apfSTK.h	/^namespace apf {$/;"	n
apf	test/nektar_align.cc	/^namespace apf {$/;"	n	file:
apf	zoltan/apfInterElement.cc	/^namespace apf {$/;"	n	file:
apf	zoltan/apfZoltan.cc	/^namespace apf {$/;"	n	file:
apf	zoltan/apfZoltan.h	/^namespace apf {$/;"	n
apf	zoltan/apfZoltanCallbacks.cc	/^namespace apf {$/;"	n	file:
apf	zoltan/apfZoltanCallbacks.h	/^namespace apf {$/;"	n
apf	zoltan/apfZoltanEmpty.cc	/^namespace apf {$/;"	n	file:
apf	zoltan/apfZoltanMesh.cc	/^namespace apf {$/;"	n	file:
apf	zoltan/apfZoltanMesh.h	/^namespace apf {$/;"	n
apf2mds	mds/apfMDS.cc	/^static int apf2mds(int t_apf)$/;"	f	namespace:apf
apfField	stk/apfSTK.cc	/^    Field* apfField;$/;"	m	class:apf::StkBridge	file:
apfFromGmsh	mds/mdsGmsh.cc	/^int apfFromGmsh(int gmshType)$/;"	f	namespace:__anon96
append	apf/apfDynamicArray.h	/^    void append(DynamicArray<T> const& other)$/;"	f	class:apf::DynamicArray
append	apf/apfDynamicArray.h	/^    void append(T const& v)$/;"	f	class:apf::DynamicArray
append	mds/mds_smb.c	/^static void append(char* s, size_t size, const char* format, ...)$/;"	f	file:
append	pcu/pcu.c	/^static void append(char* s, size_t size, const char* format, ...)$/;"	f	file:
apply	apf/apf.h	/^  T apply(T val1, T val2) const { return ( (val1 < val2) ? val1 : val2 ); };$/;"	f	class:apf::ReductionMin
apply	apf/apf.h	/^  T apply(T val1, T val2) const { return ( (val1 < val2) ? val2 : val1 ); };$/;"	f	class:apf::ReductionMax
apply	apf/apf.h	/^  T apply(T val1, T val2) const { return val1 + val2; };$/;"	f	class:apf::ReductionSum
apply	apf/apfField.cc	/^void FieldOp::apply(FieldBase* f)$/;"	f	class:apf::FieldOp
apply	apf/apfGradientByVolume.cc	/^    virtual void apply()$/;"	f	class:apf::RecoverGradient
apply	apf/apfMesh.cc	/^    virtual MeshEntity* apply(int type, MeshEntity** down)$/;"	f	class:apf::ElementFinder
apply	apf/apfMesh2.cc	/^    virtual MeshEntity* apply(int type, MeshEntity** down)$/;"	f	class:apf::ElementBuilder
apply	crv/crvShape.cc	/^  virtual void apply()$/;"	f	class:crv::EdgeReshaper
apply	crv/crvShape.cc	/^  virtual void apply()$/;"	f	class:crv::EdgeSwapper
apply	crv/crvShapeFixer.cc	/^void CrvLargeAngleTetFixer::apply()$/;"	f	class:crv::CrvLargeAngleTetFixer
apply	crv/crvShapeFixer.cc	/^void CrvLargeAngleTriFixer::apply()$/;"	f	class:crv::CrvLargeAngleTriFixer
apply	crv/crvShapeFixer.cc	/^void CrvShortEdgeFixer::apply()$/;"	f	class:crv::CrvShortEdgeFixer
apply	ma/maCoarsen.cc	/^    virtual void apply()$/;"	f	class:ma::AllEdgeCollapser
apply	ma/maCoarsen.cc	/^    virtual void apply()$/;"	f	class:ma::CollapseChecker
apply	ma/maCoarsen.cc	/^    virtual void apply()$/;"	f	class:ma::IndependentSetFinder
apply	ma/maCoarsen.cc	/^    virtual void apply()$/;"	f	class:ma::MatchedEdgeCollapser
apply	ma/maCrawler.cc	/^  void apply()$/;"	f	struct:ma::TopFlagger
apply	ma/maLayerCollapse.cc	/^bool LayerCollapse::apply(double qualityToBeat)$/;"	f	class:ma::LayerCollapse
apply	ma/maOperator.cc	/^    void apply()$/;"	f	class:ma::CollectiveOperation
apply	ma/maRegionCollapse.cc	/^void RegionCollapse::apply()$/;"	f	class:ma::RegionCollapse
apply	ma/maShape.cc	/^    virtual void apply()$/;"	f	class:ma::LargeAngleTetAligner
apply	ma/maShape.cc	/^    virtual void apply()$/;"	f	class:ma::LargeAngleTetFixer
apply	ma/maShape.cc	/^    virtual void apply()$/;"	f	class:ma::LargeAngleTriFixer
apply	ma/maShape.cc	/^    virtual void apply()$/;"	f	class:ma::QualityImprover2D
apply	ma/maShape.cc	/^    virtual void apply()$/;"	f	class:ma::ShortEdgeFixer
apply	ma/maSnap.cc	/^    void apply()$/;"	f	class:ma::SnapAll
apply	ma/maSnap.cc	/^    void apply()$/;"	f	class:ma::SnapMatched
apply	ma/maSnap_mohara.cc	/^    void apply()$/;"	f	class:ma::SnapAll
apply	ma/maSnap_mohara.cc	/^    void apply()$/;"	f	class:ma::SnapMatched
apply	ma/maTetrahedronize.cc	/^  void apply()$/;"	f	struct:ma::UnsafePrismOverride
apply	ma/maTetrahedronize.cc	/^  void apply()$/;"	f	struct:ma::UnsafePyramidOverride
apply	phasta/phBC.cc	/^  void (*apply)(double* values, int* bits,$/;"	m	struct:ph::KnownBC	file:
apply	spr/sprEstimateError.cc	/^    virtual void apply()$/;"	f	class:spr::AverageOp
apply	spr/sprEstimateTargetError.cc	/^    virtual void apply()$/;"	f	class:spr::target::AverageOp
apply	spr/sprRecoverField.cc	/^  virtual void apply()$/;"	f	class:spr::PatchOp
applyBC	phasta/phBC.cc	/^static bool applyBC(gmi_model* gm, gmi_ent* ge,$/;"	f	namespace:ph
applyBCs	phasta/phBC.cc	/^static bool applyBCs(gmi_model* gm, gmi_ent* ge,$/;"	f	namespace:ph
applyBit	phasta/phBC.cc	/^static void applyBit(double*, int* bits,$/;"	f	namespace:ph
applyBit2	phasta/phBC.cc	/^static bool applyBit2(int* bits, int bit)$/;"	f	namespace:ph
applyElasticConstaints	phasta/phConstraint.cc	/^bool applyElasticConstaints(gmi_model* gm, BCs& bcs, gmi_ent* e,$/;"	f	namespace:ph
applyEssentialBCs	phasta/phBC.cc	/^bool applyEssentialBCs(gmi_model* gm, gmi_ent* ge,$/;"	f	namespace:ph
applyExtrudedData	ma/maExtrude.cc	/^void applyExtrudedData(DataSetter const& setter,$/;"	f	namespace:ma::__anon28
applyExtrudedFields	ma/maExtrude.cc	/^void applyExtrudedFields(Mesh* m, Fields const& base_fields,$/;"	f	namespace:ma::__anon28
applyFlatField	ma/maExtrude.cc	/^void applyFlatField(Mesh* m, std::string const& extruded_name,$/;"	f	namespace:ma::__anon28
applyFlatFields	ma/maExtrude.cc	/^void applyFlatFields(Mesh* m, Fields const& extruded_fields,$/;"	f	namespace:ma::__anon28
applyFun3dWeight	test/ghost.cc	/^  apf::MeshTag* applyFun3dWeight(apf::Mesh* m) {$/;"	f	namespace:__anon11
applyLocallyWithModification	apf/apfCavityOp.cc	/^void CavityOp::applyLocallyWithModification(int d)$/;"	f	class:apf::CavityOp
applyLocallyWithoutModification	apf/apfCavityOp.cc	/^void CavityOp::applyLocallyWithoutModification(int d)$/;"	f	class:apf::CavityOp
applyNaturalBCs	phasta/phBC.cc	/^bool applyNaturalBCs(gmi_model* gm, gmi_ent* ge,$/;"	f	namespace:ph
applyOperator	ma/maOperator.cc	/^void applyOperator(Adapt* a, Operator* o)$/;"	f	namespace:ma
applyRigidMotion	dsp/dsp.cc	/^apf::Field* applyRigidMotion(apf::Mesh* m, Boundary& moving,$/;"	f	namespace:dsp
applyScalar	phasta/phBC.cc	/^static void applyScalar(double* outval, int* bits,$/;"	f	namespace:ph
applyScalar2	phasta/phBC.cc	/^static void applyScalar2(double* values, int* bits,$/;"	f	namespace:ph
applySolutionBCs	phasta/phBC.cc	/^bool applySolutionBCs(gmi_model* gm, gmi_ent* ge,$/;"	f	namespace:ph
applySurfID	phasta/phBC.cc	/^static void applySurfID(double*, int* bits,$/;"	f	namespace:ph
applyToDimension	apf/apfCavityOp.cc	/^void CavityOp::applyToDimension(int d)$/;"	f	class:apf::CavityOp
applyTriQuadHack	phasta/phBlock.cc	/^static void applyTriQuadHack(BlockKey& k)$/;"	f	namespace:ph
applyTriQuadHackElement	phasta/phBlock.cc	/^static void applyTriQuadHackElement$/;"	f	namespace:ph
applyTriQuadHackInterface	phasta/phBlock.cc	/^void applyTriQuadHackInterface$/;"	f	namespace:ph
applyUnitWeight	test/ghostEdge.cc	/^  apf::MeshTag* applyUnitWeight(apf::Mesh* m) {$/;"	f	namespace:__anon12
applyUnitWeight	test/ghostMPAS.cc	/^  apf::MeshTag* applyUnitWeight(apf::Mesh* m) {$/;"	f	namespace:__anon9
applyVector	phasta/phBC.cc	/^static void applyVector(double* outval, int* bits,$/;"	f	namespace:ph
applyVector2	phasta/phBC.cc	/^static void applyVector2(double* values, int* bits,$/;"	f	namespace:ph
applyVelocityConstaints	phasta/phConstraint.cc	/^bool applyVelocityConstaints(gmi_model* gm, BCs& bcs, gmi_ent* e,$/;"	f	namespace:ph
apply_	ma/maLayerCollapse.cc	/^bool LayerCollapse::apply_(double qualityToBeat)$/;"	f	class:ma::LayerCollapse
approach	test/ptnParma.cc	/^const char* approach = 0;$/;"	m	namespace:__anon10	file:
approach	zoltan/apfZoltanMesh.h	/^    int approach;$/;"	m	class:apf::ZoltanMesh
areClose	apf/apfGeometry.cc	/^bool areClose(Line const& a, Plane const& b, double tol)$/;"	f	namespace:apf
areClose	apf/apfGeometry.cc	/^bool areClose(Plane const& a, Plane const& b, double tol)$/;"	f	namespace:apf
areClose	apf/apfGeometry.cc	/^bool areClose(Vector3 const& a, Plane const& b, double tol)$/;"	f	namespace:apf
areClose	apf/apfGeometry.cc	/^bool areClose(Vector3 const& a, Vector3 const& b,$/;"	f	namespace:apf
areClose	apf/apfGeometry.cc	/^bool areClose(double a, double b, double tol)$/;"	f	namespace:apf
areDiagonalsAllowed	ma/maTetrahedronize.cc	/^  bool areDiagonalsAllowed(int diagonals, int allowed_diagonals)$/;"	f	struct:ma::UnsafePrismOverride
areOrthogonal	apf/apfGeometry.cc	/^bool areOrthogonal(Vector3 const& a, Vector3 const& b, double tol)$/;"	f	namespace:apf
areParallel	apf/apfGeometry.cc	/^bool areParallel(Line const& a, Plane const& b, double tol)$/;"	f	namespace:apf
areParallel	apf/apfGeometry.cc	/^bool areParallel(Plane const& a, Plane const& b, double tol)$/;"	f	namespace:apf
areParallel	apf/apfGeometry.cc	/^bool areParallel(Vector3 const& a, Vector3 const& b, double tol)$/;"	f	namespace:apf
areTetsValid	ma/maQuality.cc	/^bool areTetsValid(Mesh* m, EntityArray& tets)$/;"	f	namespace:ma
array	pcu/pcu_order.c	/^  struct message** array;$/;"	m	struct:pcu_order_struct	typeref:struct:pcu_order_struct::message	file:
arraySize	apf/apfArrayData.cc	/^    int arraySize;$/;"	m	class:apf::ArrayDataOf	file:
arrays	phasta/phOutput.h	/^  EnsaArrays arrays;$/;"	m	struct:ph::Output
at	pcu/pcu_order.c	/^  int at;$/;"	m	struct:pcu_order_struct	file:
atNode	apf/apfField.cc	/^  void atNode(int n)$/;"	f	struct:apf::ZeroOp
atNode	apf/apfField.cc	/^void FieldOp::atNode(int)$/;"	f	class:apf::FieldOp
atNode	apf/apfFieldOf.cc	/^    void atNode(int n)$/;"	f	class:apf::Axpy
atNode	apf/apfFieldOf.cc	/^    void atNode(int n)$/;"	f	class:apf::Project
atNode	apf/apfHierarchic.cc	/^    void atNode(int n)$/;"	f	class:apf::Projector
atNode	apf/apfVtk.cc	/^    virtual void atNode(int node)$/;"	f	class:apf::WriteIPField
atPoint	apf/apfGradientByVolume.cc	/^    virtual void atPoint(Vector3 const& p, double w, double dV)$/;"	f	class:apf::GradientIntegrator
atPoint	apf/apfIntegrate.cc	/^    void atPoint(Vector3 const&, double w, double dV)$/;"	f	class:apf::Measurer
atPoint	ma/maQuality.cc	/^    virtual void atPoint(Vector const& p, double w, double)$/;"	f	class:ma::FixedMetricIntegrator
atPoint	ma/maSize.cc	/^    void atPoint(Vector const& p , double w, double )$/;"	f	class:ma::SizeFieldIntegrator
atPoint	sam/samElementCount.cc	/^  virtual void atPoint(apf::Vector3 const& xi, double w, double dV) {$/;"	f	class:sam::TotalMetricVolumeIso
atPoint	spr/sprEstimateError.cc	/^    void atPoint(apf::Vector3 const& p, double w, double dV)$/;"	f	class:spr::SelfProduct
atPoint	spr/sprEstimateError.cc	/^    void atPoint(apf::Vector3 const& xi, double w, double dV)$/;"	f	class:spr::ElementError
atPoint	spr/sprEstimateTargetError.cc	/^    void atPoint(apf::Vector3 const& xi, double w, double dv)$/;"	f	class:spr::target::ElementError
atPoint	test/test_integrator.cc	/^    void atPoint(apf::Vector3 const& , double , double ) {$/;"	f	class:CountIntegrator
atPoint	test/test_matrix_grad.cc	/^    virtual void atPoint(apf::Vector3 const& p, double, double)$/;"	f	class:CheckMatrixDerivIntegrator
atPoint	test/test_matrix_grad.cc	/^    virtual void atPoint(apf::Vector3 const& p, double, double)$/;"	f	class:MatrixDerivIntegrator
at_id	mds/mds.c	/^static mds_id* at_id(mds_id* a[MDS_TYPES], mds_id x)$/;"	f	file:
attach	test/hierarchic.cc	/^void L2Projector::attach() {$/;"	f	class:__anon20::L2Projector
attachAllAngleBCs	phasta/phAxisymmetry.cc	/^void attachAllAngleBCs(gmi_model* gm, BCs& bcs)$/;"	f	namespace:ph
attachAngleBC	phasta/phAxisymmetry.cc	/^static void attachAngleBC(BCs& bcs, gmi_model* gm, gmi_ent* f, double angle)$/;"	f	namespace:ph
attachCellField	phasta/phRestart.cc	/^void attachCellField($/;"	f	namespace:ph
attachField	phasta/phRestart.cc	/^void attachField($/;"	f	namespace:ph
attachOrder	phasta/ph_convert.cc	/^static void attachOrder(apf::Mesh* m)$/;"	f	file:
attachOrder	test/convert.cc	/^static void attachOrder(apf::Mesh* m)$/;"	f	file:
attachRStream	phasta/phstream.cc	/^void attachRStream(GRStream* grs, RStream* rs) {$/;"	f
attachRandField	phasta/phRestart.cc	/^bool attachRandField($/;"	f	namespace:ph
attachSIMSizeField	phasta/phMeshQuality.cc	/^void attachSIMSizeField(apf::Mesh2* m, apf::Field* sf_mag) {$/;"	f	namespace:ph
attachSIMSizeField	phasta/phMeshQuality.cc	/^void attachSIMSizeField(apf::Mesh2* m, apf::Field* sf_mag, apf::Field* sf_dir) {$/;"	f	namespace:ph
attachVtxField	test/icesheet.cc	/^void attachVtxField(apf::Mesh2* mesh, const char* fname,$/;"	f
attachVtxTag	test/icesheet.cc	/^apf::MeshTag* attachVtxTag(apf::Mesh2* mesh, const char* fname,$/;"	f
attachZeroSolution	phasta/phRestart.cc	/^void attachZeroSolution(Input& in, apf::Mesh* m)$/;"	f	namespace:ph
attach_mid_solution	test/poisson.cc	/^    void attach_mid_solution() {$/;"	f	class:__anon17::Poisson	file:
attach_nodal_solution	test/poisson.cc	/^    void attach_nodal_solution() {$/;"	f	class:__anon17::Poisson	file:
attach_vtx_solution	test/poisson.cc	/^    void attach_vtx_solution() {$/;"	f	class:__anon17::Poisson	file:
attribFile	phasta/migrate_interface.cc	/^  char const* attribFile = 0;$/;"	m	namespace:__anon78	file:
attribFilename	test/simDiscrete.cc	/^const char* attribFilename;$/;"	v
attribFilename	test/sim_countBL.cc	/^const char* attribFilename;$/;"	v
attribFilename	test/sim_part.cc	/^const char* attribFilename;$/;"	v
attribfile	phasta/cut_interface.cc	/^char const* attribfile;$/;"	v
attribute	phasta/phAttrib.cc	/^  pAttributeInt attribute;$/;"	m	struct:IntBC	file:
attribute	phasta/phAttrib.cc	/^  pAttributeTensor0 attribute;$/;"	m	struct:Tensor0BC	file:
attribute	phasta/phAttrib.cc	/^  pAttributeTensor1 attribute;$/;"	m	struct:Tensor1BC	file:
attributeFileName	phasta/phInput.h	/^    std::string attributeFileName;$/;"	m	class:ph::Input
average	test/aniso_ma_test.cc	/^    double average;$/;"	m	class:AnIso	file:
average	test/capStoneSizeFields.h	/^    double average;$/;"	m	class:GeomB737
average	test/capStoneSizeFields.h	/^    double average;$/;"	m	class:GeomRobin
average	test/capStoneSizeFields.h	/^    double average;$/;"	m	class:Linear1
average	test/capStoneSizeFields.h	/^    double average;$/;"	m	class:Linear2
average	test/capStoneSizeFields.h	/^    double average;$/;"	m	class:Linear3
average	test/capStoneSizeFields.h	/^    double average;$/;"	m	class:Uniform
average	test/curvetest.cc	/^    double average;$/;"	m	class:Linear	file:
average	test/dg_ma_test.cc	/^    double average;$/;"	m	class:Linear	file:
average	test/fusion.cc	/^    double average;$/;"	m	class:Vortex	file:
average	test/fusion3.cc	/^    double average;$/;"	m	class:Vortex	file:
average	test/ma_test.cc	/^    double average;$/;"	m	class:Linear	file:
average	test/torus_ma_test.cc	/^    double average;$/;"	m	class:CylindricalShock	file:
averageSizeField	spr/sprEstimateError.cc	/^void averageSizeField(Estimation* e)$/;"	f	namespace:spr
averageSizeField	spr/sprEstimateTargetError.cc	/^static void averageSizeField(Estimation* e)$/;"	f	namespace:spr::target
averageToVertex	spr/sprEstimateError.cc	/^void averageToVertex(apf::Field* ef, apf::Field* vf, apf::MeshEntity* ent)$/;"	f	namespace:spr
avg	parma/diffMC/parma_monitor.cc	/^  double Average::avg() {$/;"	f	class:parma::Average
avgQuality	test/quality.cc	/^double avgQuality = 0.0;$/;"	m	namespace:__anon21	file:
avgQualityBelowTol	test/quality.cc	/^double avgQualityBelowTol = 0.0;$/;"	m	namespace:__anon21	file:
avgSharedSides	parma/diffMC/parma_sides.cc	/^double parma::avgSharedSides(parma::Sides* s) {$/;"	f	class:parma
avgToVtx	spr/sprEstimateTargetError.cc	/^static void avgToVtx(apf::Field* ef, apf::Field* vf, apf::MeshEntity* ent)$/;"	f	namespace:spr::target
axisymmetry	phasta/phInput.h	/^    int axisymmetry;$/;"	m	class:ph::Input
axpy	apf/apf.cc	/^void axpy(double a, Field* x, Field* y)$/;"	f	namespace:apf
axpy	apf/apfFieldOf.cc	/^void axpy(double a, FieldOf<T>* x, FieldOf<T>* y)$/;"	f	namespace:apf
axpy	apf/apfFieldOf.h	/^    void axpy(double a, Field* x)$/;"	f	class:apf::FieldOf
axpy	apf/apfPackedField.cc	/^void PackedField::axpy(double, Field*)$/;"	f	class:apf::PackedField
b	ma/maAffine.h	/^    apf::Vector3 b;$/;"	m	class:ma::Affine
b	parma/diffMC/parma_elmLtVtxEdgeSelector.cc	/^    double b;$/;"	m	struct:__anon64::dtwo	file:
b	test/hierarchic.cc	/^    mth::Vector<double> b;$/;"	m	class:__anon20::L2Projector	file:
b2	crv/crvTables.cc	/^unsigned const* const* const b2[11] =$/;"	m	namespace:crv	file:
b2_0	crv/crvTables.cc	/^static unsigned const* const b2_0[1] = {b2_0_0};$/;"	m	namespace:crv	file:
b2_0_0	crv/crvTables.cc	/^static unsigned const b2_0_0[1] = {2};$/;"	m	namespace:crv	file:
b2_1	crv/crvTables.cc	/^static unsigned const* const b2_1[2] = {b2_1_0,b2_1_1};$/;"	m	namespace:crv	file:
b2_10	crv/crvTables.cc	/^static unsigned const* const b2_10[11] =$/;"	m	namespace:crv	file:
b2_10_0	crv/crvTables.cc	/^static unsigned const b2_10_0[11] = {2,20,19,18,17,16,15,14,13,12,1};$/;"	m	namespace:crv	file:
b2_10_1	crv/crvTables.cc	/^static unsigned const b2_10_1[10] = {21,65,64,62,59,55,50,44,37,11};$/;"	m	namespace:crv	file:
b2_10_10	crv/crvTables.cc	/^static unsigned const b2_10_10[1] = {0};$/;"	m	namespace:crv	file:
b2_10_2	crv/crvTables.cc	/^static unsigned const b2_10_2[9] = {22,63,61,58,54,49,43,36,10};$/;"	m	namespace:crv	file:
b2_10_3	crv/crvTables.cc	/^static unsigned const b2_10_3[8] = {23,60,57,53,48,42,35,9};$/;"	m	namespace:crv	file:
b2_10_4	crv/crvTables.cc	/^static unsigned const b2_10_4[7] = {24,56,52,47,41,34,8};$/;"	m	namespace:crv	file:
b2_10_5	crv/crvTables.cc	/^static unsigned const b2_10_5[6] = {25,51,46,40,33,7};$/;"	m	namespace:crv	file:
b2_10_6	crv/crvTables.cc	/^static unsigned const b2_10_6[5] = {26,45,39,32,6};$/;"	m	namespace:crv	file:
b2_10_7	crv/crvTables.cc	/^static unsigned const b2_10_7[4] = {27,38,31,5};$/;"	m	namespace:crv	file:
b2_10_8	crv/crvTables.cc	/^static unsigned const b2_10_8[3] = {28,30,4};$/;"	m	namespace:crv	file:
b2_10_9	crv/crvTables.cc	/^static unsigned const b2_10_9[2] = {29,3};$/;"	m	namespace:crv	file:
b2_1_0	crv/crvTables.cc	/^static unsigned const b2_1_0[2] = {2,1};$/;"	m	namespace:crv	file:
b2_1_1	crv/crvTables.cc	/^static unsigned const b2_1_1[1] = {0};$/;"	m	namespace:crv	file:
b2_2	crv/crvTables.cc	/^static unsigned const* const b2_2[3] = {b2_2_0,b2_2_1,b2_2_2};$/;"	m	namespace:crv	file:
b2_2_0	crv/crvTables.cc	/^static unsigned const b2_2_0[3] = {2,4,1};$/;"	m	namespace:crv	file:
b2_2_1	crv/crvTables.cc	/^static unsigned const b2_2_1[2] = {5,3};$/;"	m	namespace:crv	file:
b2_2_2	crv/crvTables.cc	/^static unsigned const b2_2_2[1] = {0};$/;"	m	namespace:crv	file:
b2_3	crv/crvTables.cc	/^static unsigned const* const b2_3[4] = {b2_3_0,b2_3_1,b2_3_2,b2_3_3};$/;"	m	namespace:crv	file:
b2_3_0	crv/crvTables.cc	/^static unsigned const b2_3_0[4] = {2,6,5,1};$/;"	m	namespace:crv	file:
b2_3_1	crv/crvTables.cc	/^static unsigned const b2_3_1[3] = {7,9,4};$/;"	m	namespace:crv	file:
b2_3_2	crv/crvTables.cc	/^static unsigned const b2_3_2[2] = {8,3};$/;"	m	namespace:crv	file:
b2_3_3	crv/crvTables.cc	/^static unsigned const b2_3_3[1] = {0};$/;"	m	namespace:crv	file:
b2_4	crv/crvTables.cc	/^static unsigned const* const b2_4[5] = {b2_4_0,b2_4_1,b2_4_2,b2_4_3,b2_4_4};$/;"	m	namespace:crv	file:
b2_4_0	crv/crvTables.cc	/^static unsigned const b2_4_0[5] = {2,8,7,6,1};$/;"	m	namespace:crv	file:
b2_4_1	crv/crvTables.cc	/^static unsigned const b2_4_1[4] = {9,14,13,5};$/;"	m	namespace:crv	file:
b2_4_2	crv/crvTables.cc	/^static unsigned const b2_4_2[3] = {10,12,4};$/;"	m	namespace:crv	file:
b2_4_3	crv/crvTables.cc	/^static unsigned const b2_4_3[2] = {11,3};$/;"	m	namespace:crv	file:
b2_4_4	crv/crvTables.cc	/^static unsigned const b2_4_4[1] = {0};$/;"	m	namespace:crv	file:
b2_5	crv/crvTables.cc	/^static unsigned const* const b2_5[6] =$/;"	m	namespace:crv	file:
b2_5_0	crv/crvTables.cc	/^static unsigned const b2_5_0[6] = {2,10,9,8,7,1};$/;"	m	namespace:crv	file:
b2_5_1	crv/crvTables.cc	/^static unsigned const b2_5_1[5] = {11,20,19,17,6};$/;"	m	namespace:crv	file:
b2_5_2	crv/crvTables.cc	/^static unsigned const b2_5_2[4] = {12,18,16,5};$/;"	m	namespace:crv	file:
b2_5_3	crv/crvTables.cc	/^static unsigned const b2_5_3[3] = {13,15,4};$/;"	m	namespace:crv	file:
b2_5_4	crv/crvTables.cc	/^static unsigned const b2_5_4[2] = {14,3};$/;"	m	namespace:crv	file:
b2_5_5	crv/crvTables.cc	/^static unsigned const b2_5_5[1] = {0};$/;"	m	namespace:crv	file:
b2_6	crv/crvTables.cc	/^static unsigned const* const b2_6[7] =$/;"	m	namespace:crv	file:
b2_6_0	crv/crvTables.cc	/^static unsigned const b2_6_0[7] = {2,12,11,10,9,8,1};$/;"	m	namespace:crv	file:
b2_6_1	crv/crvTables.cc	/^static unsigned const b2_6_1[6] = {13,27,26,24,21,7};$/;"	m	namespace:crv	file:
b2_6_2	crv/crvTables.cc	/^static unsigned const b2_6_2[5] = {14,25,23,20,6};$/;"	m	namespace:crv	file:
b2_6_3	crv/crvTables.cc	/^static unsigned const b2_6_3[4] = {15,22,19,5};$/;"	m	namespace:crv	file:
b2_6_4	crv/crvTables.cc	/^static unsigned const b2_6_4[3] = {16,18,4};$/;"	m	namespace:crv	file:
b2_6_5	crv/crvTables.cc	/^static unsigned const b2_6_5[2] = {17,3};$/;"	m	namespace:crv	file:
b2_6_6	crv/crvTables.cc	/^static unsigned const b2_6_6[1] = {0};$/;"	m	namespace:crv	file:
b2_7	crv/crvTables.cc	/^static unsigned const* const b2_7[8] =$/;"	m	namespace:crv	file:
b2_7_0	crv/crvTables.cc	/^static unsigned const b2_7_0[8] = {2,14,13,12,11,10,9,1};$/;"	m	namespace:crv	file:
b2_7_1	crv/crvTables.cc	/^static unsigned const b2_7_1[7] = {15,35,34,32,29,25,8};$/;"	m	namespace:crv	file:
b2_7_2	crv/crvTables.cc	/^static unsigned const b2_7_2[6] = {16,33,31,28,24,7};$/;"	m	namespace:crv	file:
b2_7_3	crv/crvTables.cc	/^static unsigned const b2_7_3[5] = {17,30,27,23,6};$/;"	m	namespace:crv	file:
b2_7_4	crv/crvTables.cc	/^static unsigned const b2_7_4[4] = {18,26,22,5};$/;"	m	namespace:crv	file:
b2_7_5	crv/crvTables.cc	/^static unsigned const b2_7_5[3] = {19,21,4};$/;"	m	namespace:crv	file:
b2_7_6	crv/crvTables.cc	/^static unsigned const b2_7_6[2] = {20,3};$/;"	m	namespace:crv	file:
b2_7_7	crv/crvTables.cc	/^static unsigned const b2_7_7[1] = {0};$/;"	m	namespace:crv	file:
b2_8	crv/crvTables.cc	/^static unsigned const* const b2_8[9] =$/;"	m	namespace:crv	file:
b2_8_0	crv/crvTables.cc	/^static unsigned const b2_8_0[9] = {2,16,15,14,13,12,11,10,1};$/;"	m	namespace:crv	file:
b2_8_1	crv/crvTables.cc	/^static unsigned const b2_8_1[8] = {17,44,43,41,38,34,29,9};$/;"	m	namespace:crv	file:
b2_8_2	crv/crvTables.cc	/^static unsigned const b2_8_2[7] = {18,42,40,37,33,28,8};$/;"	m	namespace:crv	file:
b2_8_3	crv/crvTables.cc	/^static unsigned const b2_8_3[6] = {19,39,36,32,27,7};$/;"	m	namespace:crv	file:
b2_8_4	crv/crvTables.cc	/^static unsigned const b2_8_4[5] = {20,35,31,26,6};$/;"	m	namespace:crv	file:
b2_8_5	crv/crvTables.cc	/^static unsigned const b2_8_5[4] = {21,30,25,5};$/;"	m	namespace:crv	file:
b2_8_6	crv/crvTables.cc	/^static unsigned const b2_8_6[3] = {22,24,4};$/;"	m	namespace:crv	file:
b2_8_7	crv/crvTables.cc	/^static unsigned const b2_8_7[2] = {23,3};$/;"	m	namespace:crv	file:
b2_8_8	crv/crvTables.cc	/^static unsigned const b2_8_8[1] = {0};$/;"	m	namespace:crv	file:
b2_9	crv/crvTables.cc	/^static unsigned const* const b2_9[10] =$/;"	m	namespace:crv	file:
b2_9_0	crv/crvTables.cc	/^static unsigned const b2_9_0[10] = {2,18,17,16,15,14,13,12,11,1};$/;"	m	namespace:crv	file:
b2_9_1	crv/crvTables.cc	/^static unsigned const b2_9_1[9] = {19,54,53,51,48,44,39,33,10};$/;"	m	namespace:crv	file:
b2_9_2	crv/crvTables.cc	/^static unsigned const b2_9_2[8] = {20,52,50,47,43,38,32,9};$/;"	m	namespace:crv	file:
b2_9_3	crv/crvTables.cc	/^static unsigned const b2_9_3[7] = {21,49,46,42,37,31,8};$/;"	m	namespace:crv	file:
b2_9_4	crv/crvTables.cc	/^static unsigned const b2_9_4[6] = {22,45,41,36,30,7};$/;"	m	namespace:crv	file:
b2_9_5	crv/crvTables.cc	/^static unsigned const b2_9_5[5] = {23,40,35,29,6};$/;"	m	namespace:crv	file:
b2_9_6	crv/crvTables.cc	/^static unsigned const b2_9_6[4] = {24,34,28,5};$/;"	m	namespace:crv	file:
b2_9_7	crv/crvTables.cc	/^static unsigned const b2_9_7[3] = {25,27,4};$/;"	m	namespace:crv	file:
b2_9_8	crv/crvTables.cc	/^static unsigned const b2_9_8[2] = {26,3};$/;"	m	namespace:crv	file:
b2_9_9	crv/crvTables.cc	/^static unsigned const b2_9_9[1] = {0};$/;"	m	namespace:crv	file:
b3	crv/crvTables.cc	/^unsigned const* const* const* const b3[5] =$/;"	m	namespace:crv	file:
b3_0	crv/crvTables.cc	/^static unsigned const* const* const b3_0[1] = {b3_0_0};$/;"	m	namespace:crv	file:
b3_0_0	crv/crvTables.cc	/^static unsigned const* const b3_0_0[1] = {b3_0_00};$/;"	m	namespace:crv	file:
b3_0_00	crv/crvTables.cc	/^static unsigned const b3_0_00[1] = {3};$/;"	m	namespace:crv	file:
b3_1	crv/crvTables.cc	/^static unsigned const* const* const b3_1[2] = {b3_1_0,b3_1_1};$/;"	m	namespace:crv	file:
b3_1_0	crv/crvTables.cc	/^static unsigned const* const b3_1_0[2] = {b3_1_00,b3_1_01};$/;"	m	namespace:crv	file:
b3_1_00	crv/crvTables.cc	/^static unsigned const b3_1_00[2] = {3,2};$/;"	m	namespace:crv	file:
b3_1_01	crv/crvTables.cc	/^static unsigned const b3_1_01[1] = {1};$/;"	m	namespace:crv	file:
b3_1_1	crv/crvTables.cc	/^static unsigned const* const b3_1_1[1] = {b3_1_10};$/;"	m	namespace:crv	file:
b3_1_10	crv/crvTables.cc	/^static unsigned const b3_1_10[1] = {0};$/;"	m	namespace:crv	file:
b3_2	crv/crvTables.cc	/^static unsigned const* const* const b3_2[3] = {b3_2_0,b3_2_1,b3_2_2};$/;"	m	namespace:crv	file:
b3_2_0	crv/crvTables.cc	/^static unsigned const* const b3_2_0[3] = {b3_2_00,b3_2_01,b3_2_02};$/;"	m	namespace:crv	file:
b3_2_00	crv/crvTables.cc	/^static unsigned const b3_2_00[3] = {3,9,2};$/;"	m	namespace:crv	file:
b3_2_01	crv/crvTables.cc	/^static unsigned const b3_2_01[2] = {8,5};$/;"	m	namespace:crv	file:
b3_2_02	crv/crvTables.cc	/^static unsigned const b3_2_02[1] = {1};$/;"	m	namespace:crv	file:
b3_2_1	crv/crvTables.cc	/^static unsigned const* const b3_2_1[2] = {b3_2_10,b3_2_11};$/;"	m	namespace:crv	file:
b3_2_10	crv/crvTables.cc	/^static unsigned const b3_2_10[2] = {7,6};$/;"	m	namespace:crv	file:
b3_2_11	crv/crvTables.cc	/^static unsigned const b3_2_11[1] = {4};$/;"	m	namespace:crv	file:
b3_2_2	crv/crvTables.cc	/^static unsigned const* const b3_2_2[1] = {b3_2_20};$/;"	m	namespace:crv	file:
b3_2_20	crv/crvTables.cc	/^static unsigned const b3_2_20[1] = {0};$/;"	m	namespace:crv	file:
b3_3	crv/crvTables.cc	/^static unsigned const* const* const b3_3[4] =$/;"	m	namespace:crv	file:
b3_3_0	crv/crvTables.cc	/^static unsigned const* const b3_3_0[4] = {b3_3_00,b3_3_01,b3_3_02,b3_3_03};$/;"	m	namespace:crv	file:
b3_3_00	crv/crvTables.cc	/^static unsigned const b3_3_00[4] = {3,15,14,2};$/;"	m	namespace:crv	file:
b3_3_01	crv/crvTables.cc	/^static unsigned const b3_3_01[3] = {13,18,7};$/;"	m	namespace:crv	file:
b3_3_02	crv/crvTables.cc	/^static unsigned const b3_3_02[2] = {12,6};$/;"	m	namespace:crv	file:
b3_3_03	crv/crvTables.cc	/^static unsigned const b3_3_03[1] = {1};$/;"	m	namespace:crv	file:
b3_3_1	crv/crvTables.cc	/^static unsigned const* const b3_3_1[3] = {b3_3_10,b3_3_11,b3_3_12};$/;"	m	namespace:crv	file:
b3_3_10	crv/crvTables.cc	/^static unsigned const b3_3_10[3] = {11,19,8};$/;"	m	namespace:crv	file:
b3_3_11	crv/crvTables.cc	/^static unsigned const b3_3_11[2] = {17,16};$/;"	m	namespace:crv	file:
b3_3_12	crv/crvTables.cc	/^static unsigned const b3_3_12[1] = {5};$/;"	m	namespace:crv	file:
b3_3_2	crv/crvTables.cc	/^static unsigned const* const b3_3_2[2] = {b3_3_20,b3_3_21};$/;"	m	namespace:crv	file:
b3_3_20	crv/crvTables.cc	/^static unsigned const b3_3_20[2] = {10,9};$/;"	m	namespace:crv	file:
b3_3_21	crv/crvTables.cc	/^static unsigned const b3_3_21[1] = {4};$/;"	m	namespace:crv	file:
b3_3_3	crv/crvTables.cc	/^static unsigned const* const b3_3_3[1] = {b3_3_30};$/;"	m	namespace:crv	file:
b3_3_30	crv/crvTables.cc	/^static unsigned const b3_3_30[1] = {0};$/;"	m	namespace:crv	file:
b3_4	crv/crvTables.cc	/^static unsigned const* const* const b3_4[5] =$/;"	m	namespace:crv	file:
b3_4_0	crv/crvTables.cc	/^static unsigned const* const b3_4_0[5] =$/;"	m	namespace:crv	file:
b3_4_00	crv/crvTables.cc	/^static unsigned const b3_4_00[5] = {3,21,20,19,2};$/;"	m	namespace:crv	file:
b3_4_01	crv/crvTables.cc	/^static unsigned const b3_4_01[4] = {18,30,29,9};$/;"	m	namespace:crv	file:
b3_4_02	crv/crvTables.cc	/^static unsigned const b3_4_02[3] = {17,28,8};$/;"	m	namespace:crv	file:
b3_4_03	crv/crvTables.cc	/^static unsigned const b3_4_03[2] = {16,7};$/;"	m	namespace:crv	file:
b3_4_04	crv/crvTables.cc	/^static unsigned const b3_4_04[1] = {1};$/;"	m	namespace:crv	file:
b3_4_1	crv/crvTables.cc	/^static unsigned const* const b3_4_1[4] = {b3_4_10,b3_4_11,b3_4_12,b3_4_13};$/;"	m	namespace:crv	file:
b3_4_10	crv/crvTables.cc	/^static unsigned const b3_4_10[4] = {15,33,32,10};$/;"	m	namespace:crv	file:
b3_4_11	crv/crvTables.cc	/^static unsigned const b3_4_11[3] = {27,34,24};$/;"	m	namespace:crv	file:
b3_4_12	crv/crvTables.cc	/^static unsigned const b3_4_12[2] = {26,23};$/;"	m	namespace:crv	file:
b3_4_13	crv/crvTables.cc	/^static unsigned const b3_4_13[1] = {6};$/;"	m	namespace:crv	file:
b3_4_2	crv/crvTables.cc	/^static unsigned const* const b3_4_2[3] = {b3_4_20,b3_4_21,b3_4_22};$/;"	m	namespace:crv	file:
b3_4_20	crv/crvTables.cc	/^static unsigned const b3_4_20[3] = {14,31,11};$/;"	m	namespace:crv	file:
b3_4_21	crv/crvTables.cc	/^static unsigned const b3_4_21[2] = {25,22};$/;"	m	namespace:crv	file:
b3_4_22	crv/crvTables.cc	/^static unsigned const b3_4_22[1] = {5};$/;"	m	namespace:crv	file:
b3_4_3	crv/crvTables.cc	/^static unsigned const* const b3_4_3[2] = {b3_4_30,b3_4_31};$/;"	m	namespace:crv	file:
b3_4_30	crv/crvTables.cc	/^static unsigned const b3_4_30[2] = {13,12};$/;"	m	namespace:crv	file:
b3_4_31	crv/crvTables.cc	/^static unsigned const b3_4_31[1] = {4};$/;"	m	namespace:crv	file:
b3_4_4	crv/crvTables.cc	/^static unsigned const* const b3_4_4[1] = {b3_4_40};$/;"	m	namespace:crv	file:
b3_4_40	crv/crvTables.cc	/^static unsigned const b3_4_40[1] = {0};$/;"	m	namespace:crv	file:
bCurver	test/crack_test.cc	/^void bCurver(const char* modelFile, const char* meshFile,$/;"	f
bItr	parma/diffMC/parma_dcpart.h	/^      BdryItr* bItr;$/;"	m	class:parma::dcComponents
b_param	test/fusion.cc	/^double const b_param = 1.0;$/;"	v
backToTags	test/fusion2.cc	/^static void backToTags(apf::Mesh2* m)$/;"	f	file:
backsubUT	mth/mthQR.cc	/^void backsubUT($/;"	f	namespace:mth
bake	phasta/phCook.cc	/^  void bake(gmi_model*& g, apf::Mesh2*& m,$/;"	f	namespace:chef
bal	parma/extractParmaResults.py	/^bal = metric("balancedIn")$/;"	v
balAll	parma/extractParmaResults.py	/^balAll = []$/;"	v
balance	parma/diffMC/parma_balancer.cc	/^  void Balancer::balance(apf::MeshTag* wtag, double tolerance) {$/;"	f	class:parma::Balancer
balance	parma/diffMC/parma_ghost.cc	/^    void balance(apf::MeshTag* wtag, double tolerance) {$/;"	f	class:GhostElmGtVtxBalancer
balance	parma/diffMC/parma_vtxEdgeElmBalancer.cc	/^      void balance(apf::MeshTag* wtag, double tolerance) {$/;"	f	class:__anon46::VtxEdgeElmBalancer
balance	parma/diffMC/parma_vtxElmBalancer.cc	/^    void balance(apf::MeshTag* wtag, double tolerance) {$/;"	f	class:VtxElmBalancer
balance	phasta/phCook.cc	/^  void balance(ph::Input& ctrl, apf::Mesh2* m) {$/;"	f	namespace:chef
balance	phasta/phPartition.cc	/^void balance(Input& in, apf::Mesh2* m)$/;"	f	namespace:ph
balance	test/repartition.cc	/^void balance(apf::Mesh2* m)$/;"	f	namespace:__anon22
balance	zoltan/apfZoltan.cc	/^    virtual void balance(MeshTag* weights, double tolerance)$/;"	f	class:apf::ZoltanBalancer
balanceAndReorder	phasta/phCook.cc	/^  void balanceAndReorder(apf::Mesh2* m, ph::Input& in, int numMasters) {$/;"	f	namespace:ph
balanceAndReorder	phasta/phCook.cc	/^  void balanceAndReorder(ph::Input& ctrl, apf::Mesh2* m) {$/;"	f	namespace:chef
base	gmi/gmi_analytic.c	/^  struct gmi_base base;$/;"	m	struct:gmi_analytic	typeref:struct:gmi_analytic::gmi_base	file:
base	ma/maLayerSnap.cc	/^  Layer base;$/;"	m	struct:ma::BaseTopLinker	file:
base	parma/extractParmaResults.py	/^class base(): pass #HACCCCCCCKKKKK$/;"	c
base64	proteushash.py	/^import base64$/;"	i
base64Decode	lion/lionBase64.cc	/^std::string base64Decode (std::string encoded)$/;"	f	namespace:lion
base64Decode4Bytes	lion/lionBase64.cc	/^std::string base64Decode4Bytes (char* bytes)$/;"	f	namespace:lion
base64DecodeTable	lion/lionBase64.cc	/^static const unsigned char base64DecodeTable[256] =$/;"	m	namespace:lion	file:
base64Encode	lion/lionBase64.cc	/^std::string base64Encode (const char* input, const unsigned long len )$/;"	f	namespace:lion
base64Encode1Byte	lion/lionBase64.cc	/^std::string base64Encode1Byte (char byte)$/;"	f	namespace:lion
base64Encode2Bytes	lion/lionBase64.cc	/^std::string base64Encode2Bytes (char* bytes)$/;"	f	namespace:lion
base64Encode3Bytes	lion/lionBase64.cc	/^std::string base64Encode3Bytes (char* bytes)$/;"	f	namespace:lion
base64EncodeTable	lion/lionBase64.cc	/^static const unsigned char base64EncodeTable[65] =  $/;"	m	namespace:lion	file:
bc	phasta/phOutput.h	/^  double** bc;$/;"	m	struct:ph::EnsaArrays
bcast	pcu/pcu_coll.c	/^static pcu_pattern bcast =$/;"	v	file:
bcastMatching	apf/apfMigrate.cc	/^static void bcastMatching($/;"	f	namespace:apf
bcastRemotes	apf/apfMigrate.cc	/^static void bcastRemotes($/;"	f	namespace:apf
bcast_action	pcu/pcu_coll.c	/^static int bcast_action(int bit)$/;"	f	file:
bcast_begin_bit	pcu/pcu_coll.c	/^static int bcast_begin_bit(void)$/;"	f	file:
bcast_end_bit	pcu/pcu_coll.c	/^static bool bcast_end_bit(int bit)$/;"	f	file:
bcast_peer	pcu/pcu_coll.c	/^static int bcast_peer(int bit)$/;"	f	file:
bcast_shift	pcu/pcu_coll.c	/^static int bcast_shift(int bit)$/;"	f	file:
bcb	phasta/phOutput.h	/^  double*** bcb;$/;"	m	struct:ph::EnsaArrays
bcs	phasta/phBC.h	/^  Set bcs;$/;"	m	struct:ph::FieldBCs
bdry	parma/diffMC/parma_components.h	/^      Level* bdry;$/;"	m	class:parma::dcComponents::Components
bdryHas	parma/diffMC/parma_components.cc	/^  bool dcComponents::bdryHas(unsigned i, apf::MeshEntity* e) {$/;"	f	class:parma::dcComponents
bdryHas	parma/diffMC/parma_graphDist.cc	/^      bool bdryHas(apf::MeshEntity* e) {$/;"	f	class:__anon74::CompContains
bdryHas	parma/diffMC/parma_graphDist.cc	/^      bool bdryHas(apf::MeshEntity*) {$/;"	f	class:__anon74::CompUpdateContains
bdry_ent_types	gmi/agm.c	/^static enum agm_ent_type const bdry_ent_types[AGM_BDRY_TYPES] = {$/;"	v	file:
bdry_use_types	gmi/agm.c	/^static enum agm_use_type const bdry_use_types[AGM_BDRY_TYPES] = {$/;"	v	file:
bdrys	gmi/agm.c	/^  struct bdrys bdrys;$/;"	m	struct:agm	typeref:struct:agm::bdrys	file:
bdrys	gmi/agm.c	/^struct bdrys {$/;"	s	file:
beforeBuilding	ma/maAdapt.cc	/^void Cavity::beforeBuilding()$/;"	f	class:ma::Cavity
beforeTrying	ma/maAdapt.cc	/^void Cavity::beforeTrying()$/;"	f	class:ma::Cavity
begin	apf_cap/apfCAP.cc	/^MeshIterator* MeshCAP::begin(int dimension)$/;"	f	class:apf::MeshCAP
begin	apf_sim/apfSIM.cc	/^MeshIterator* MeshSIM::begin(int dimension)$/;"	f	class:apf::MeshSIM
begin	can/canArray.h	/^    T const* begin() const {return elems;}$/;"	f	class:can::Array
begin	can/canArray.h	/^    T* begin() {return elems;}$/;"	f	class:can::Array
begin	gmi/gmi.h	/^  struct gmi_iter* (*begin)(struct gmi_model* m, int dim);$/;"	m	struct:gmi_model_ops	typeref:struct:gmi_model_ops::begin
begin	gmi_cap/gmi_cap.cc	/^static gmi_iter* begin(gmi_model* m, int dim)$/;"	f	file:
begin	gmi_sim/gmi_sim.cc	/^static gmi_iter* begin(gmi_model* m, int dim)$/;"	f	file:
begin	ma/maCrawler.cc	/^  void begin(Layer& first)$/;"	f	struct:ma::LayerNumberer
begin	ma/maLayerCoarsen.cc	/^  void begin(Layer& first)$/;"	f	struct:ma::CurveLocalizer
begin	ma/maLayerRefine.cc	/^  void begin(Layer& first)$/;"	f	struct:ma::Disambiguator
begin	ma/maLayerRefine.cc	/^  void begin(Layer& first)$/;"	f	struct:ma::SplitTagger
begin	ma/maLayerSnap.cc	/^  void begin(Layer& first)$/;"	f	struct:ma::BaseTopLinker
begin	ma/maLayerSnap.cc	/^  void begin(Layer& first)$/;"	f	struct:ma::LayerSnapper
begin	ma/maLayerSnap.cc	/^  void begin(Layer& first)$/;"	f	struct:ma::SnapTagger
begin	ma/maLayerSnap.cc	/^  void begin(Layer& first)$/;"	f	struct:ma::UnsnapChecker
begin	ma/maLayerSnap.cc	/^  void begin(Layer& first)$/;"	f	struct:ma::Unsnapper
begin	ma/maTetrahedronize.cc	/^  void begin(Layer& first)$/;"	f	struct:ma::QuadFlagger
begin	ma/maTetrahedronize.cc	/^  void begin(Layer& first)$/;"	f	struct:ma::QuadMarker
begin	mds/apfMDS.cc	/^    MeshIterator* begin(int dimension)$/;"	f	class:apf::MeshMDS
begin	parma/diffMC/parma_associative.h	/^      void begin() {$/;"	f	class:parma::Associative
begin	parma/diffMC/parma_components.cc	/^      void begin(Level* l) {$/;"	f	class:parma::dcComponents::BdryItr
begin	pumi/mPartEntityContainer.cc	/^mPartEntityContainer::iter mPartEntityContainer::begin(int what)$/;"	f	class:mPartEntityContainer
begin	pumi/pumi.h	/^  iterall begin(int d) {return allEntities.begin(d);}$/;"	f	class:gModel
begin	pumi/pumi_list.h	/^    ListIterator<T> begin() {return ListIterator<T>(head.next);}$/;"	f	class:List
beginBdry	parma/diffMC/parma_components.cc	/^  void dcComponents::beginBdry(unsigned i) { bItr->begin(c->getBdry(i)); }$/;"	f	class:parma::dcComponents
begin_bit	pcu/pcu_coll.h	/^  int (*begin_bit)(void); \/\/initialize state bit$/;"	m	struct:__anon39
begin_coll_step	pcu/pcu_coll.c	/^static void begin_coll_step(pcu_coll* c)$/;"	f	file:
beta	spr/sprEstimateTargetError.cc	/^  double beta;$/;"	m	struct:spr::target::Estimation	file:
betaDist	phasta/phInput.h	/^    double betaDist;$/;"	m	class:ph::Input
betaSize	phasta/phInput.h	/^    double betaSize;$/;"	m	class:ph::Input
bezier	crv/crvBezierShapes.cc	/^const bezierShape bezier[apf::Mesh::TYPES] =$/;"	m	namespace:crv	file:
bezierCurve	crv/crvBezierShapes.cc	/^static void bezierCurve(int P, apf::Vector3 const& xi,$/;"	f	namespace:crv
bezierCurveGrads	crv/crvBezierShapes.cc	/^static void bezierCurveGrads(int P, apf::Vector3 const& xi,$/;"	f	namespace:crv
bezierGrads	crv/crvBezierShapes.cc	/^const bezierShapeGrads bezierGrads[apf::Mesh::TYPES] =$/;"	m	namespace:crv	file:
bezierShape	crv/crvBezierShapes.h	/^typedef void (*bezierShape)(int P,$/;"	t	namespace:crv
bezierShapeGrads	crv/crvBezierShapes.h	/^typedef void (*bezierShapeGrads)(int P,$/;"	t	namespace:crv
bezierTet	crv/crvBezierShapes.cc	/^static void bezierTet(int P, apf::Vector3 const& xi,$/;"	f	namespace:crv
bezierTetGrads	crv/crvBezierShapes.cc	/^static void bezierTetGrads(int P, apf::Vector3 const& xi,$/;"	f	namespace:crv
bezierTriangle	crv/crvBezierShapes.cc	/^static void bezierTriangle(int P, apf::Vector3 const& xi,$/;"	f	namespace:crv
bezierTriangleGrads	crv/crvBezierShapes.cc	/^static void bezierTriangleGrads(int P, apf::Vector3 const& xi,$/;"	f	namespace:crv
bfs	parma/diffMC/parma_graphDist.cc	/^  int bfs(apf::Mesh* m, parma::DijkstraContains* c,$/;"	f	namespace:parma_ordering
binomial	crv/crvMath.cc	/^int binomial(int n, int i)$/;"	f	namespace:crv
bisect	parma/rib/parma_rib.cc	/^void bisect(Bodies* all, Bodies* left, Bodies* right)$/;"	f	namespace:parma
bit	pcu/pcu_coll.h	/^  int bit; \/\/pattern's state bit$/;"	m	struct:__anon40
bit	phasta/phBC.cc	/^  int bit;$/;"	m	struct:ph::KnownBC	file:
blendingCoeffs	crv/crvQuality.cc	/^  apf::NewArray<double> blendingCoeffs;$/;"	m	class:crv::Quality2D	file:
blendingOrder	crv/crvQuality.cc	/^  int blendingOrder;$/;"	m	class:crv::Quality2D	file:
blendingTol	crv/crvBlended.cc	/^static double const blendingTol = 1.e-12;$/;"	m	namespace:crv	file:
blocks	phasta/phOutput.h	/^  AllBlocks blocks;$/;"	m	struct:ph::Output
body	parma/rib/parma_rib.h	/^  Body** body;$/;"	m	struct:parma::Bodies
both	ma/maSize.cc	/^  BothEval* both;$/;"	m	struct:ma::FrameEval	file:
both	ma/maSize.cc	/^  BothEval* both;$/;"	m	struct:ma::SizesEval	file:
bothEval	ma/maSize.cc	/^  BothEval bothEval;$/;"	m	struct:ma::AnisoSizeField	file:
bottom	ma/maExtrude.h	/^  Model* bottom;$/;"	m	struct:ma::ModelExtrusion
boundary	phasta/phBlock.h	/^  Blocks boundary;$/;"	m	struct:ph::AllBlocks
boundaryToElementXi	apf/apfBoundaryToElementXi.cc	/^Vector3 boundaryToElementXi($/;"	f	namespace:apf
bounds	gmi/agm.c	/^  int* bounds[AGM_BDRY_TYPES];$/;"	m	struct:bdrys	file:
bridge	parma/diffMC/parma_ghostMPAS.cc	/^      int bridge;$/;"	m	class:__anon67::MPASGhostBalancer	file:
bridge	parma/diffMC/parma_ghostMPASWeights.cc	/^      int bridge;$/;"	m	class:parma::GhostElementFinder	file:
bridge	zoltan/apfZoltan.cc	/^    ZoltanMesh bridge;$/;"	m	class:apf::ZoltanBalancer	file:
bridge	zoltan/apfZoltan.cc	/^    ZoltanMesh bridge;$/;"	m	class:apf::ZoltanSplitter	file:
broadcastInt	parma/diffMC/maximalIndependentSet/test/testMIS.cc	/^int broadcastInt(int val) {$/;"	f
bt	crv/crvShapeHandler.cc	/^    BezierTransfer* bt;$/;"	m	class:crv::BezierHandler	file:
bubbleFileName	phasta/phInput.h	/^    std::string bubbleFileName;$/;"	m	class:ph::Input
buf	pcu/pcu_order.c	/^  pcu_buffer buf;$/;"	m	struct:message	file:
buf	phasta/phAttrib.cc	/^  double buf;$/;"	m	struct:IntBC	file:
buf	phasta/phAttrib.cc	/^  double buf;$/;"	m	struct:Tensor0BC	file:
buf	phasta/phAttrib.cc	/^  double buf[3];$/;"	m	struct:Tensor1BC	file:
buf	phasta/phAttrib.cc	/^  double buf[4];$/;"	m	struct:CompBC	file:
buffer	pcu/pcu_mpi.h	/^  pcu_buffer buffer;$/;"	m	struct:__anon33
buildBottomTet	ma/maEdgeSwap.cc	/^    Entity* buildBottomTet(Entity* triv[3])$/;"	f	class:ma::SwapCavity
buildCallback	ma/maAdapt.h	/^    apf::BuildCallback* buildCallback;$/;"	m	class:ma::Adapt
buildCell	mds/apfBox.cc	/^void BoxBuilder::buildCell(int i, int d)$/;"	f	class:apf::BoxBuilder
buildCellEdges	mds/apfBox.cc	/^void BoxBuilder::buildCellEdges(int i)$/;"	f	class:apf::BoxBuilder
buildCellFaces	mds/apfBox.cc	/^void BoxBuilder::buildCellFaces(int i)$/;"	f	class:apf::BoxBuilder
buildCellRegion	mds/apfBox.cc	/^void BoxBuilder::buildCellRegion(int i)$/;"	f	class:apf::BoxBuilder
buildCellVert	mds/apfBox.cc	/^void BoxBuilder::buildCellVert(int i)$/;"	f	class:apf::BoxBuilder
buildDimension	mds/apfBox.cc	/^void BoxBuilder::buildDimension(int d)$/;"	f	class:apf::BoxBuilder
buildElement	apf/apfMesh2.cc	/^MeshEntity* buildElement($/;"	f	namespace:apf
buildElement	ma/maAdapt.cc	/^Entity* buildElement($/;"	f	namespace:ma
buildElements	stk/apfMeshSTK.cc	/^static void buildElements($/;"	f	namespace:apf
buildFace	mds/apfBox.cc	/^void BoxBuilder::buildFace(MeshEntity* fv[4], ModelEntity* me)$/;"	f	class:apf::BoxBuilder
buildGeomBCFileName	phasta/phGeomBC.cc	/^static std::string buildGeomBCFileName(std::string timestep_or_dat)$/;"	f	namespace:ph
buildHex	mds/apfBox.cc	/^void BoxBuilder::buildHex(MeshEntity* rv[8], ModelEntity* me)$/;"	f	class:apf::BoxBuilder
buildLayer	ma/maExtrude.cc	/^FullLayer buildLayer(Mesh* m, FullLayer const& prev_layer,$/;"	f	namespace:ma::__anon28
buildLayers	ma/maExtrude.cc	/^Layers buildLayers(Mesh* m, ModelExtrusions const& extrusions, size_t nlayers,$/;"	f	namespace:ma::__anon28
buildMapping	phasta/phInput.h	/^    int buildMapping;$/;"	m	class:ph::Input
buildMapping	phasta/phRestart.cc	/^void buildMapping(apf::Mesh* m)$/;"	f	namespace:ph
buildMappingPartId	phasta/phRestart.cc	/^static double* buildMappingPartId(apf::Mesh* m)$/;"	f	namespace:ph
buildMappingVtxId	phasta/phRestart.cc	/^static double* buildMappingVtxId(apf::Mesh* m)$/;"	f	namespace:ph
buildMeshAndModel	mds/apfBox.cc	/^void BoxBuilder::buildMeshAndModel()$/;"	f	class:apf::BoxBuilder
buildModel	mds/apfBox.cc	/^gmi_model* BoxBuilder::buildModel()$/;"	f	class:apf::BoxBuilder
buildNodes	stk/apfMeshSTK.cc	/^static void buildNodes($/;"	f	namespace:apf
buildOneElement	apf/apfMesh2.cc	/^MeshEntity* buildOneElement($/;"	f	namespace:apf
buildPatch	spr/sprRecoverField.cc	/^static bool buildPatch(Patch* p, apf::CavityOp* o)$/;"	f	namespace:spr
buildPyramid	ma/maLayerTemplates.cc	/^static void buildPyramid(Refine* r, Entity* p, Entity** v)$/;"	f	namespace:ma
buildRegion	mds/apfBox.cc	/^void BoxBuilder::buildRegion(MeshEntity* rv[8], ModelEntity* me)$/;"	f	class:apf::BoxBuilder
buildRestartFileName	phasta/phRestart.cc	/^static std::string buildRestartFileName(std::string prefix, int step)$/;"	f	namespace:ph
buildSides	stk/apfMeshSTK.cc	/^static void buildSides($/;"	f	namespace:apf
buildSplitElement	ma/maRefine.cc	/^Entity* buildSplitElement($/;"	f	namespace:ma
buildTets	mds/apfBox.cc	/^void BoxBuilder::buildTets(MeshEntity* rv[8], ModelEntity* me)$/;"	f	class:apf::BoxBuilder
buildTopTet	ma/maEdgeSwap.cc	/^    Entity* buildTopTet(Entity* triv[3])$/;"	f	class:ma::SwapCavity
buildTriangles	mds/apfBox.cc	/^void BoxBuilder::buildTriangles(MeshEntity* fv[4], ModelEntity* me)$/;"	f	class:apf::BoxBuilder
buildVertex	ma/maAdapt.cc	/^Entity* buildVertex($/;"	f	namespace:ma
by	apf/apfPartition.h	/^  int by;$/;"	m	struct:apf::Divide
by	apf/apfPartition.h	/^  int by;$/;"	m	struct:apf::Modulo
by	apf/apfPartition.h	/^  int by;$/;"	m	struct:apf::Multiply
bytes	gmi/agm.c	/^  int bytes;$/;"	m	struct:agm_tag	file:
bytes	mds/mds_tag.h	/^  int bytes;$/;"	m	struct:mds_tag
bytes	pcu/pcu_byteorder.h	/^  unsigned char bytes[4];$/;"	m	union:__anon42
bytes	pumi/GenTag.h	/^    size_t bytes;$/;"	m	class:TagHandle
bzf	pcu/pcu_io.c	/^  BZFILE* bzf;$/;"	m	struct:pcu_file	file:
c	gmi/gmi.c	/^  struct creator c[1];$/;"	m	struct:creators	typeref:struct:creators::creator	file:
c	mds/mds_net.h	/^  struct mds_copy c[1];$/;"	m	struct:mds_copies	typeref:struct:mds_copies::mds_copy
c	parma/diffMC/parma_associative.h	/^      Container c;$/;"	m	class:parma::Associative
c	parma/diffMC/parma_centroidSelector.cc	/^      parma::Centroids* c;$/;"	m	class:__anon49::Distance	file:
c	parma/diffMC/parma_dcpart.h	/^      Components* c;$/;"	m	class:parma::dcComponents
c	parma/diffMC/parma_graphDist.cc	/^      parma::dcComponents& c;$/;"	m	class:__anon74::CompContains	file:
c	parma/diffMC/parma_monitor.cc	/^  const double c[]={-3.\/2, 2., -1.\/2}; \/\/ 2nd order$/;"	m	namespace:__anon73	file:
c	parma/diffMC/parma_vtxPtnWriter.cc	/^    int c;$/;"	m	class:__anon72::Ptn	file:
c0	apf/apfHierarchic.cc	/^static const double c0 = -2.449489742783178;$/;"	m	namespace:apf	file:
c1	apf/apfHierarchic.cc	/^static const double c1 = -3.162277660168379;$/;"	m	namespace:apf	file:
cItr	parma/diffMC/parma_associative.h	/^      typename Container::iterator cItr;$/;"	m	class:parma::Associative
c_param	test/fusion.cc	/^double const c_param = 0.2;$/;"	v
cachedFrame	ma/maSize.cc	/^  Matrix cachedFrame;$/;"	m	struct:ma::BothEval	file:
cachedLogM	ma/maSize.cc	/^  Matrix cachedLogM;$/;"	m	struct:ma::LogMEval	file:
cachedSizes	ma/maSize.cc	/^  Vector cachedSizes;$/;"	m	struct:ma::BothEval	file:
cachedVert	ma/maSize.cc	/^  Entity* cachedVert;$/;"	m	struct:ma::BothEval	file:
cachedVert	ma/maSize.cc	/^  Entity* cachedVert;$/;"	m	struct:ma::LogMEval	file:
calcMaxJacDet	crv/crvQuality.cc	/^static double calcMaxJacDet(int n, apf::NewArray<double>& nodes)$/;"	f	namespace:crv
calcMinJacDet	crv/crvQuality.cc	/^static double calcMinJacDet(int n, apf::NewArray<double>& nodes)$/;"	f	namespace:crv
call	ma/maAdapt.cc	/^void NewEntities::call(Entity* e)$/;"	f	class:ma::NewEntities
call	ma/maExtrude.cc	/^    virtual void call(Entity* e) {$/;"	f	class:ma::__anon28::DebugBuildCallback
call	ma/maOperator.cc	/^    void call(Entity* e)$/;"	f	class:ma::CollectiveOperation
callback	apf/apfMesh2.cc	/^    BuildCallback* callback;$/;"	m	class:apf::ElementBuilder	file:
can	can/canArray.h	/^namespace can {$/;"	n
can	can/canNewArray.h	/^namespace can {$/;"	n
canGetClosestPoint	apf/apfMesh.cc	/^bool Mesh::canGetClosestPoint()$/;"	f	class:apf::Mesh
canGetModelNormal	apf/apfMesh.cc	/^bool Mesh::canGetModelNormal()$/;"	f	class:apf::Mesh
canModify	apf/apfCavityOp.h	/^    bool canModify;$/;"	m	class:apf::CavityOp
canSnap	apf/apfMesh.cc	/^bool Mesh::canSnap()$/;"	f	class:apf::Mesh
canSplitPyramidCommon	ma/maLayerTemplates.cc	/^static bool canSplitPyramidCommon(Refine* r, Entity** v)$/;"	f	namespace:ma
can_compress	lion/lionNoZLib.cc	/^const bool can_compress = false;$/;"	m	namespace:lion	file:
can_compress	lion/lionZLib.cc	/^const bool can_compress = true;$/;"	m	namespace:lion	file:
cancel	ma/maCollapse.cc	/^void Collapse::cancel()$/;"	f	class:ma::Collapse
cancel	ma/maEdgeSwap.cc	/^    void cancel()$/;"	f	class:ma::EdgeSwap2D
cancel	ma/maFaceSplit.cc	/^void FaceSplit::cancel()$/;"	f	class:ma::FaceSplit
cancel	ma/maLayerCollapse.cc	/^void LayerCollapse::cancel()$/;"	f	class:ma::LayerCollapse
cancel	ma/maMatchedCollapse.cc	/^void MatchedCollapse::cancel()$/;"	f	class:ma::MatchedCollapse
cancel	ma/maSplits.cc	/^void Splits::cancel()$/;"	f	class:ma::Splits
cancel	parma/diffMC/parma_edgeEqVtxSelector.cc	/^      void cancel(apf::Migration** plan, parma::Mid* capacity) {$/;"	f	class:__anon52::EdgeEqVtx
cancel	parma/diffMC/parma_elmLtVtxEdgeSelector.cc	/^      void cancel(apf::Migration** plan, Midd* capacity) {$/;"	f	class:__anon64::ElmLtVtxEdgeSelector
cancel	parma/diffMC/parma_ltSelector.cc	/^      void cancel(apf::Migration** plan, parma::Mid* capacity) {$/;"	f	class:__anon58::LtSelector
cancelSnaps	ma/maMatchedSnapper.cc	/^void MatchedSnapper::cancelSnaps()$/;"	f	class:ma::MatchedSnapper
cancelTriangle	ma/maEdgeSwap.cc	/^    void cancelTriangle(int i)$/;"	f	class:ma::SwapCavity
cap	gmi/agm.c	/^  int cap[AGM_BDRY_TYPES];$/;"	m	struct:bdrys	file:
cap	gmi/agm.c	/^  int cap[AGM_ENT_TYPES];$/;"	m	struct:ents	file:
cap	gmi/agm.c	/^  int cap[AGM_USE_TYPES];$/;"	m	struct:uses	file:
cap	mds/mds.h	/^  mds_id cap[MDS_TYPES];$/;"	m	struct:mds
cap_model	gmi_cap/gmi_cap.cc	/^struct cap_model {$/;"	s	file:
capacity	pcu/pcu_buffer.h	/^  size_t capacity;$/;"	m	struct:__anon36
caseName	test/generate.cc	/^std::string caseName;$/;"	m	namespace:__anon19	file:
castEntity	apf_cap/apfCAP.cc	/^MeshEntity* castEntity(capEntity* entity)$/;"	f	namespace:apf
castEntity	apf_sim/apfSIM.cc	/^MeshEntity* castEntity(pEntity entity)$/;"	f	namespace:apf
catch	pcu/reel/reel.c	/^static void catch(int s)$/;"	f	file:
cavity	ma/maCollapse.h	/^    Cavity cavity;$/;"	m	class:ma::Collapse
cavity	ma/maEdgeSwap.cc	/^    Cavity cavity;$/;"	m	class:ma::EdgeSwap2D	file:
cavity	ma/maEdgeSwap.cc	/^    Cavity cavity;$/;"	m	class:ma::EdgeSwap3D	file:
cavityExists	ma/maEdgeSwap.cc	/^    bool cavityExists[2];$/;"	m	class:ma::EdgeSwap3D	file:
cavityWeight	parma/diffMC/parma_edgeEqVtxSelector.cc	/^      double cavityWeight(apf::Migration* plan, SetEnt& s) {$/;"	f	class:__anon52::EdgeEqVtx
ceil_log2	pcu/pcu_coll.c	/^static int ceil_log2(int n)$/;"	f	file:
cellDim	apf/apfVtk.cc	/^    int cellDim;$/;"	m	class:apf::WriteIPField	file:
center	phasta/phBubble.cc	/^  apf::Vector3 center;$/;"	m	struct:ph::Bubble	file:
center	test/fusion3.cc	/^double center[]={1.7, 0.08,0.};$/;"	v
centerBodies	parma/rib/parma_rib.cc	/^static void centerBodies(Bodies* b, mth::Vector3<double> const& c)$/;"	f	namespace:parma
centroid	parma/diffMC/parma_centroids.h	/^      apf::Vector3 centroid;$/;"	m	class:parma::Centroids
centroid	test/fusion.cc	/^    ma::Vector centroid;$/;"	m	class:Vortex	file:
centroid	test/fusion3.cc	/^    ma::Vector centroid;$/;"	m	class:Vortex	file:
centroids	parma/diffMC/parma_centroidSelector.cc	/^      Centroids* centroids;$/;"	m	class:parma::CentroidSelector	file:
changeData	apf/apfField.cc	/^void FieldBase::changeData(FieldData* d)$/;"	f	class:apf::FieldBase
changeMdsDimension	mds/apfMDS.cc	/^void changeMdsDimension(Mesh2* in, int d)$/;"	f	namespace:apf
changeMeshOrder	crv/crvElevation.cc	/^void changeMeshOrder(apf::Mesh2* m, int newOrder)$/;"	f	namespace:crv
changeMeshShape	apf/apfMesh.cc	/^void changeMeshShape(Mesh* m, FieldShape* newShape, bool project)$/;"	f	namespace:apf
changeShape	apf/apfMesh.cc	/^void Mesh::changeShape(FieldShape* newShape, bool project)$/;"	f	class:apf::Mesh
change_down	mds/mds_apf.c	/^static void change_down(struct mds* m, mds_id e, struct mds_set* s)$/;"	f	file:
changes	zoltan/apfZoltanCallbacks.h	/^    int changes; $/;"	m	class:apf::ZoltanData
checkAdjPartsandNets	parma/diffMC/maximalIndependentSet/test/testMIS.cc	/^void checkAdjPartsandNets(partInfo& part, int totNumParts) {$/;"	f
checkAllEdgeCollapses	ma/maCoarsen.cc	/^void checkAllEdgeCollapses(Adapt* a, int modelDimension)$/;"	f	namespace:ma
checkBalance	phasta/phCook.cc	/^  void checkBalance(apf::Mesh2* m, ph::Input& in) {$/;"	f	namespace:ph
checkBoundaryVertex	phasta/phOutput.cc	/^static void checkBoundaryVertex(apf::Mesh* m,$/;"	f	namespace:ph
checkClass	ma/maCollapse.cc	/^bool Collapse::checkClass()$/;"	f	class:ma::Collapse
checkEdgeCollapseClassification	ma/maCollapse.cc	/^bool checkEdgeCollapseClassification(Adapt* a, Entity* edge)$/;"	f	namespace:ma
checkEdgeCollapseEdgeRings	ma/maCollapse.cc	/^bool checkEdgeCollapseEdgeRings(Adapt* a, Entity* edge)$/;"	f	namespace:ma
checkEdgeCollapseFaceRings	ma/maCollapse.cc	/^bool checkEdgeCollapseFaceRings(Adapt* a, Entity* edge)$/;"	f	namespace:ma
checkEdgeCollapseTopology	ma/maCollapse.cc	/^bool checkEdgeCollapseTopology(Adapt* a, Entity* edge)$/;"	f	namespace:ma
checkEntityShape	test/shapefun2.cc	/^static void checkEntityShape(apf::Mesh* lm, apf::Mesh* m,$/;"	f	namespace:test
checkEntityValidity	test/bezierValidity.cc	/^void checkEntityValidity(int validityTag, int entity, int order)$/;"	f
checkFieldShape	test/shapefun2.cc	/^static void checkFieldShape(apf::FieldShape* fs)$/;"	f	namespace:test
checkFilePos	mds/mdsUgrid.cc	/^  void checkFilePos(Reader* r, header* h) {$/;"	f	namespace:__anon101
checkFilteredMatching	phasta/phFilterMatching.cc	/^static void checkFilteredMatching(apf::Mesh* m, ModelMatching& mm, int dim)$/;"	f	namespace:ph
checkFlagConsistency	ma/maAdapt.cc	/^bool checkFlagConsistency(Adapt* a, int dimension, int flag)$/;"	f	namespace:ma
checkForUnsnap	ma/maLayerSnap.cc	/^static bool checkForUnsnap(Adapt* a, Tag* snapTag)$/;"	f	namespace:ma
checkGeom	ma/maRegionCollapse.cc	/^bool RegionCollapse::checkGeom()$/;"	f	class:ma::RegionCollapse
checkIndividualCollapses	ma/maLayerCollapse.cc	/^bool LayerCollapse::checkIndividualCollapses()$/;"	f	class:ma::LayerCollapse
checkInputs	phasta/condense.cc	/^  void checkInputs(int argc, char** argv) {$/;"	f	namespace:__anon85
checkInterface	phasta/phOutput.cc	/^bool checkInterface(Output& o, BCs& bcs) {$/;"	f	namespace:ph
checkIsDegenerate	crv/crvSnap.cc	/^static bool checkIsDegenerate(apf::Mesh* m, apf::ModelEntity* g,$/;"	f	namespace:crv
checkLayerShape	ma/maLayer.cc	/^void checkLayerShape(Mesh* m, const char* key)$/;"	f	namespace:ma
checkLoadBalance	phasta/phOutput.cc	/^static void checkLoadBalance(Output& o)$/;"	f	namespace:ph
checkMarker	mds/mdsGmsh.cc	/^void checkMarker(Reader* r, char const* marker)$/;"	f	namespace:__anon96
checkParametrization	ma/maDBG.cc	/^void checkParametrization(ma::Adapt* a,$/;"	f	namespace:ma_dbg
checkParametrization	test/capStoneCheckParametrization.cc	/^void checkParametrization(MeshDatabaseInterface* mdb, GeometryDatabaseInterface* gdb)$/;"	f
checkPrismDiagonalCode	ma/maTemplates.cc	/^bool checkPrismDiagonalCode(int code)$/;"	f	namespace:ma
checkReorder	phasta/phCook.cc	/^  void checkReorder(apf::Mesh2* m, ph::Input& in, int numMasters) {$/;"	f	namespace:ph
checkRingSide	ma/maCollapse.cc	/^static bool checkRingSide(Adapt* a, Entity* side, Entity* vert, Model* centerModel)$/;"	f	namespace:ma
checkTet	ma/maEdgeSwap.cc	/^    bool checkTet(bool isTop, Entity* tv[3])$/;"	f	class:ma::SwapCavity
checkTopo	ma/maCollapse.cc	/^bool Collapse::checkTopo()$/;"	f	class:ma::Collapse
checkTopo	ma/maEdgeSwap.cc	/^    bool checkTopo()$/;"	f	class:ma::EdgeSwap2D
checkTopo	ma/maMatchedCollapse.cc	/^bool MatchedCollapse::checkTopo()$/;"	f	class:ma::MatchedCollapse
checkTopo	ma/maRegionCollapse.cc	/^bool RegionCollapse::checkTopo()$/;"	f	class:ma::RegionCollapse
checkTopo2	ma/maMatchedCollapse.cc	/^bool MatchedCollapse::checkTopo2()$/;"	f	class:ma::MatchedCollapse
checkTriangle	ma/maEdgeSwap.cc	/^    bool checkTriangle(int i)$/;"	f	class:ma::SwapCavity
checkValidity	crv/crvQuality.cc	/^int Quality2D::checkValidity(apf::MeshEntity* e)$/;"	f	class:crv::Quality2D
checkValidity	crv/crvQuality.cc	/^int Quality3D::checkValidity(apf::MeshEntity* e)$/;"	f	class:crv::Quality3D
checkValidity	crv/crvQuality.cc	/^int checkValidity(apf::Mesh* m, apf::MeshEntity* e,$/;"	f	namespace:crv
checkValidity	ma/maLayerCollapse.cc	/^bool LayerCollapse::checkValidity(double qualityToBeat)$/;"	f	class:ma::LayerCollapse
checkValidity	test/bezierValidity.cc	/^void checkValidity(apf::Mesh* m, int order)$/;"	f
checkValues	test/fusion2.cc	/^static void checkValues(apf::Mesh2* m)$/;"	f	file:
checkVertexOrder	test/runSimxAnisoAdapt.cc	/^bool checkVertexOrder($/;"	f
check_c_assert	test/assert_timing.cc	/^double check_c_assert() {$/;"	f
check_ent	gmi/agm.c	/^static void check_ent(struct agm* m, struct agm_ent e)$/;"	f	file:
check_ent	mds/mds.c	/^static void check_ent(struct mds* m, mds_id e)$/;"	f	file:
check_pcu_assert	test/assert_timing.cc	/^double check_pcu_assert() {$/;"	f
check_rank	pcu/pcu_mpi.c	/^static void check_rank(int rank)$/;"	f	file:
chef	phasta/chef.h	/^namespace chef {$/;"	n
chef	phasta/phAdapt.cc	/^namespace chef {$/;"	n	file:
chef	phasta/phCook.cc	/^namespace chef {$/;"	n	file:
chooseBaseDiagonals	ma/maTetrahedronize.cc	/^static void chooseBaseDiagonals(Adapt* a)$/;"	f	namespace:ma
chunk	proteushash.py	/^  chunk = f.read(1024)$/;"	v
clamp	ma/maBalance.cc	/^static double clamp(double x, double max, double min)$/;"	f	namespace:ma
clampForIterations	ma/maBalance.cc	/^static double clampForIterations(Adapt* a, double weight)$/;"	f	namespace:ma
clampForLayerPermissions	ma/maBalance.cc	/^static double clampForLayerPermissions(Adapt* a, int type, double weight)$/;"	f	namespace:ma
class_from_osh	omega_h/apfOmega_h.cc	/^class_from_osh(apf::Mesh2* am, osh::Mesh* om,$/;"	f	namespace:apf
class_to_osh	omega_h/apfOmega_h.cc	/^static void class_to_osh(osh::Mesh* mesh_osh, apf::Mesh* mesh_apf, int dim) {$/;"	f	namespace:apf
classifDim	mds/apfMDS.cc	/^int classifDim(gmi_model* model, Mesh* m, apf::MeshEntity* e)$/;"	f	namespace:apf
cleanup	dsp/dspSmoothers.cc	/^void Smoother::cleanup()$/;"	f	class:dsp::Smoother
cleanupAfter	ma/maRefine.cc	/^void cleanupAfter(Refine* r)$/;"	f	namespace:ma
cleanupLayer	ma/maTetrahedronize.cc	/^void cleanupLayer(Adapt* a)$/;"	f	namespace:ma
clear	apf/apfMesh2.cc	/^void clear(Mesh2* m) {$/;"	f	namespace:apf
clearAttAssociation	phasta/phAttrib.cc	/^void ph::clearAttAssociation(gmi_model* mdl, ph::Input& in)$/;"	f	class:ph
clearBuildCallback	ma/maAdapt.cc	/^void clearBuildCallback(Adapt* a)$/;"	f	namespace:ma
clearFlag	ma/maAdapt.cc	/^void clearFlag(Adapt* a, Entity* e, int flag)$/;"	f	namespace:ma
clearFlagFromDimension	ma/maAdapt.cc	/^void clearFlagFromDimension(Adapt* a, int flag, int dimension)$/;"	f	namespace:ma
clearFlagMatched	ma/maAdapt.cc	/^void clearFlagMatched(Adapt* a, Entity* e, int flag)$/;"	f	namespace:ma
clearFlags	ma/maAdapt.cc	/^void clearFlags(Adapt* a)$/;"	f	namespace:ma
clearGRStream	phasta/phstream.cc	/^void clearGRStream(GRStream* grs) {$/;"	f
clearMatches	apf_cap/apfCAP.h	/^    void clearMatches(MeshEntity*) {}$/;"	f	class:apf::MeshCAP
clearMatches	apf_sim/apfSIM.h	/^    void clearMatches(MeshEntity*) {}$/;"	f	class:apf::MeshSIM
clearMatches	mds/apfMDS.cc	/^    void clearMatches(MeshEntity* e)$/;"	f	class:apf::MeshMDS
clearQualityCache	ma/maAdapt.cc	/^void clearQualityCache(Adapt* a)$/;"	f	namespace:ma
clearRStream	phasta/phstream.cc	/^void clearRStream(RStream* rs) {$/;"	f
clearSendTag	parma/diffMC/parma_centroidSelector.cc	/^      void clearSendTag() {$/;"	f	class:parma::CentroidSelector	file:
clearTag	crv/crvAdapt.cc	/^void clearTag(Adapt* a, ma::Entity* e)$/;"	f	namespace:crv
clearTag	parma/diffMC/parma_meshaux.h	/^void clearTag(apf::Mesh*& m, apf::MeshTag* t) {$/;"	f
clearTagData	pumi/GenTag.cc	/^void Taggable::clearTagData()$/;"	f	class:Taggable
clearTags	crv/crvAdapt.cc	/^static void clearTags(Adapt* a)$/;"	f	namespace:crv
clearTags	phasta/phPartition.cc	/^void clearTags(apf::Mesh* m, apf::MeshTag* t) {$/;"	f	namespace:ph
clearTags	test/ptnParma.cc	/^void clearTags(apf::Mesh* m, apf::MeshTag* t) {$/;"	f	namespace:__anon10
clearTags	test/vtxEdgeElmBalance.cc	/^  void clearTags(apf::Mesh* m, apf::MeshTag* t) {$/;"	f	namespace:__anon7
clearTags	test/vtxElmBalance.cc	/^  void clearTags(apf::Mesh* m, apf::MeshTag* t) {$/;"	f	namespace:__anon18
clear_	apf_cap/apfCAP.h	/^    void clear_() {}$/;"	f	class:apf::MeshCAP
clear_	apf_sim/apfSIM.h	/^    void clear_() {}$/;"	f	class:apf::MeshSIM
clear_	mds/apfMDS.cc	/^    void clear_()$/;"	f	class:apf::MeshMDS
clone	apf/apfArrayData.cc	/^    virtual FieldData* clone() {$/;"	f	class:apf::ArrayDataOf
clone	apf/apfCoordData.cc	/^FieldData* CoordData::clone() {$/;"	f	class:apf::CoordData
clone	apf/apfTagData.h	/^    virtual FieldData* clone()$/;"	f	class:apf::TagDataOf
clone	apf/apfUserData.cc	/^FieldData* UserData::clone()$/;"	f	class:apf::UserData
clone	apf_sim/apfSIMDataOf.h	/^  virtual FieldData * clone()$/;"	f	class:apf::SIMDataOf
cloneEntity	phasta/phInterfaceCutter.cc	/^static apf::MeshEntity* cloneEntity(apf::Mesh2* m, apf::MeshEntity* e)$/;"	f	namespace:ph
cloneField	apf/apf.cc	/^Field* cloneField(Field* f, Mesh* onto)$/;"	f	namespace:apf
closeAttributeMatching	phasta/phFilterMatching.cc	/^static void closeAttributeMatching(gmi_model* m, ModelMatching& mm)$/;"	f	namespace:ph
closeBoundary	dsp/dsp.cc	/^void closeBoundary(apf::Mesh* m, Boundary& b)$/;"	f	namespace:dsp
closeBoundaryRec	dsp/dsp.cc	/^static void closeBoundaryRec(gmi_model* gm, gmi_ent* e, Boundary& b)$/;"	f	namespace:dsp
closeFaceMatching	phasta/phFilterMatching.cc	/^static void closeFaceMatching(gmi_model* gm, gmi_ent* f, ModelMatching& mm)$/;"	f	namespace:ph
closeFaceMatchingWithFrame	phasta/phFilterMatching.cc	/^static void closeFaceMatchingWithFrame(gmi_model* gm, gmi_ent* f, gmi_ent* of,$/;"	f	namespace:ph
closeTime	phasta/phiotimer.cc	/^  size_t closeTime[NUM_PHASTAIO_MODES];$/;"	m	struct:phastaio_stats	file:
close_compressed	pcu/pcu_io.c	/^static void close_compressed(pcu_file* pf)$/;"	f	file:
close_compressed_read	pcu/pcu_io.c	/^static void close_compressed_read(pcu_file* pf)$/;"	f	file:
close_compressed_write	pcu/pcu_io.c	/^static void close_compressed_write(pcu_file* pf)$/;"	f	file:
closes	phasta/phiotimer.cc	/^  size_t closes[NUM_PHASTAIO_MODES];$/;"	m	struct:phastaio_stats	file:
closest_point	gmi/gmi.h	/^  void (*closest_point)(struct gmi_model* m, struct gmi_ent* e,$/;"	m	struct:gmi_model_ops
closest_point	gmi_cap/gmi_cap.cc	/^static void closest_point(struct gmi_model* m, struct gmi_ent* e,$/;"	f	file:
closest_point	gmi_sim/gmi_sim.cc	/^static void closest_point(struct gmi_model* m, struct gmi_ent* e,$/;"	f	file:
coarsen	ma/maCoarsen.cc	/^bool coarsen(Adapt* a)$/;"	f	namespace:ma
coarsenLayer	ma/maLayerCoarsen.cc	/^bool coarsenLayer(Adapt* a)$/;"	f	namespace:ma
coarsensLeft	ma/maAdapt.h	/^    int coarsensLeft;$/;"	m	class:ma::Adapt
codeToEdges	ma/sliverCodeMatch.cc	/^int const codeToEdges[8][2][2]=$/;"	v
codeToType	ma/sliverCodeMatch.cc	/^int const codeToType[8]=$/;"	v
codeToVert	ma/sliverCodeMatch.cc	/^int const codeToVert[8]=$/;"	v
code_index	ma/maTables.h	/^  int code_index; \/\/the index of the template to be applied$/;"	m	struct:ma::CodeMatch
code_match	ma/maTables.cc	/^CodeMatch const* code_match[apf::Mesh::TYPES] =$/;"	m	namespace:ma	file:
coeffs	crv/crvShapeHandler.cc	/^    apf::NewArray<double> coeffs[4];$/;"	m	class:crv::BezierTransfer	file:
cofactor	apf/apfMatrix.h	/^inline Matrix<3,3> cofactor(Matrix<3,3> const &m)$/;"	f	namespace:apf
coll	pcu/pcu_msg.h	/^  pcu_coll coll; \/\/collective operation object$/;"	m	struct:pcu_msg_struct
collapse	ma/maCoarsen.cc	/^    Collapse collapse;$/;"	m	class:ma::AllEdgeCollapser	file:
collapse	ma/maCoarsen.cc	/^    Collapse collapse;$/;"	m	class:ma::CollapseChecker	file:
collapse	ma/maCoarsen.cc	/^    MatchedCollapse collapse;$/;"	m	class:ma::MatchedEdgeCollapser	file:
collapse	ma/maDoubleSplitCollapse.h	/^    Collapse collapse;$/;"	m	class:ma::DoubleSplitCollapse
collapse	ma/maFaceSplitCollapse.h	/^    Collapse collapse;$/;"	m	class:ma::FaceSplitCollapse
collapse	ma/maLayerCollapse.h	/^  Collapse collapse;$/;"	m	struct:ma::LayerCollapse
collapse	ma/maSnapper.h	/^    Collapse collapse;$/;"	m	class:ma::Snapper
collapse	ma/maVertRemover.h	/^    Collapse collapse;$/;"	m	class:ma::VertRemover
collapseAllEdges	ma/maCoarsen.cc	/^int collapseAllEdges(Adapt* a, int modelDimension)$/;"	f	namespace:ma
collapseAllStacks	ma/maLayerCoarsen.cc	/^static long collapseAllStacks(Adapt* a, int d)$/;"	f	namespace:ma
collapseInvalidEdges	crv/crvShape.cc	/^static void collapseInvalidEdges(Adapt* a)$/;"	f	namespace:crv
collapseLocalStacks	ma/maLayerCoarsen.cc	/^static void collapseLocalStacks(Adapt* a,$/;"	f	namespace:ma
collapseMatchedEdges	ma/maCoarsen.cc	/^static int collapseMatchedEdges(Adapt* a, int modelDimension)$/;"	f	namespace:ma
collapses	ma/maMatchedCollapse.h	/^  apf::DynamicArray<Collapse> collapses;$/;"	m	struct:ma::MatchedCollapse
collectBadElements	ma/maSnapper.cc	/^static void collectBadElements(Adapt* a, Upward& es,$/;"	f	namespace:ma
collectEntityModels	stk/apfSTK.cc	/^void collectEntityModels($/;"	f	namespace:apf
collectForLayerRefine	ma/maLayer.cc	/^void collectForLayerRefine(Refine* r)$/;"	f	namespace:ma
collectForMatching	ma/maRefine.cc	/^void collectForMatching(Refine* r)$/;"	f	namespace:ma
collectForTransfer	ma/maRefine.cc	/^void collectForTransfer(Refine* r)$/;"	f	namespace:ma
collectNodeXi	crv/crvBezierShapes.cc	/^void collectNodeXi(int parentType, int childType, int P,$/;"	f	namespace:crv
color	apf/apfMIS.h	/^    int color;$/;"	m	class:apf::MIS
colorEntitiesOfDimWithValues	ma/maDBG.cc	/^void colorEntitiesOfDimWithValues(ma::Adapt* a,$/;"	f	namespace:ma_dbg
cols	mth/mthMatrix.h	/^    unsigned cols() const {return N;}$/;"	f	class:mth::Matrix
cols	mth/mthMatrix.h	/^    unsigned cols() const {return columns;}$/;"	f	class:mth::Matrix
columns	apf/apfDynamicMatrix.h	/^    std::size_t columns;$/;"	m	class:apf::DynamicMatrix
columns	mth/mthMatrix.h	/^    unsigned columns;$/;"	m	class:mth::Matrix
combine	phasta/phConstraint.cc	/^static Constraint* combine(Constraint* a, Constraint* b,$/;"	f	namespace:ph
combineAll	phasta/phConstraint.cc	/^Constraint* combineAll(gmi_model* gm, FieldBCs& bcs, Make make,$/;"	f	namespace:ph
combineAllElas	phasta/phConstraint.cc	/^Constraint* combineAllElas(gmi_model* gm, FieldBCs& bcs, Make make,$/;"	f	namespace:ph
combineElas	phasta/phConstraint.cc	/^static Constraint* combineElas(Constraint* a, Constraint* b,$/;"	f	namespace:ph
combineField	phasta/phCook.cc	/^  apf::Field* combineField(apf::Mesh* m,$/;"	f	namespace:chef
combineField	phasta/phRestart.cc	/^apf::Field* combineField(apf::Mesh* m,$/;"	f	namespace:ph
combineInterface	phasta/phConstraint.cc	/^Constraint* combineInterface$/;"	f	namespace:ph
combineLinePlane	phasta/phConstraint.cc	/^static Constraint* combineLinePlane(Constraint* a, Constraint* b,$/;"	f	namespace:ph
combineLinePlaneElas	phasta/phConstraint.cc	/^static Constraint* combineLinePlaneElas(Constraint* a, Constraint* b,$/;"	f	namespace:ph
combinePlanes	phasta/phConstraint.cc	/^static Constraint* combinePlanes(Constraint* a, Constraint* b,$/;"	f	namespace:ph
combinePlanesElas	phasta/phConstraint.cc	/^static Constraint* combinePlanesElas(Constraint* a, Constraint* b,$/;"	f	namespace:ph
combinePoints	phasta/phConstraint.cc	/^static Constraint* combinePoints(Constraint* a, Constraint* b,$/;"	f	namespace:ph
combinePointsElas	phasta/phConstraint.cc	/^static Constraint* combinePointsElas(Constraint* a, Constraint* b,$/;"	f	namespace:ph
comm	apf_sim/apfSIM.cc	/^    pAttachDataCommu comm;$/;"	m	class:apf::TagSIM	file:
commEdges	ma/maSnapper.h	/^    apf::Up commEdges;$/;"	m	class:ma::FirstProblemPlane
commonDown	apf_cap/apfCAP.cc	/^static MeshEntity* commonDown(Mesh2* m, MeshEntity* a, MeshEntity* b, int dim)$/;"	f	namespace:apf
common_down	mds/mds.c	/^static mds_id common_down(struct mds* m, mds_id a, mds_id b, int d)$/;"	f	file:
commsize	test/fieldReduce.cc	/^int commsize = -1;$/;"	m	namespace:__anon15	file:
compFactory	phasta/phAttrib.cc	/^static ph::BC* compFactory(pAttribute a, pGEntity ge)$/;"	f	file:
compId	parma/diffMC/parma_dcpart.cc	/^unsigned dcPart::compId(apf::MeshEntity* e) {$/;"	f	class:dcPart
comp_entries	gmi/gmi_lookup.c	/^static int comp_entries(const void* va, const void* vb)$/;"	f	file:
compare	test/hierarchic.cc	/^void L2Projector::compare() {$/;"	f	class:__anon20::L2Projector
compare	test/test_AD.cc	/^void compare(AD const& x, double val, double da, double db)$/;"	f
compareComp	parma/diffMC/parma_components.cc	/^  bool compareComp(Comp a, Comp b) {$/;"	f	namespace:__anon65
compareIsoSF	sam/sam.cc	/^apf::Field* compareIsoSF(apf::Mesh* m, const char* desiredSzFld, int method)$/;"	f	namespace:sam
compare_copy_sets	mds/mds_apf.c	/^static int compare_copy_sets(struct mds_net* net,$/;"	f	file:
completeEntMatching	phasta/phFilterMatching.cc	/^static void completeEntMatching(gmi_ent* e, ModelMatching& mm, ModelSet& visited)$/;"	f	namespace:ph
completeMatching	phasta/phFilterMatching.cc	/^static void completeMatching(ModelMatching& mm)$/;"	f	namespace:ph
components	apf/apfNumberingClass.h	/^    int components;$/;"	m	class:apf::NumberingOf
components	apf/apfPackedField.h	/^    int components;$/;"	m	class:apf::PackedField
components	apf/apfVtk.cc	/^    int components;$/;"	m	class:apf::WriteIPField	file:
components_from_osh	omega_h/apfOmega_h.cc	/^static void components_from_osh($/;"	f	namespace:apf
components_to_osh	omega_h/apfOmega_h.cc	/^static void components_to_osh($/;"	f	namespace:apf
compress	lion/lionNoZLib.cc	/^void compress(void* dest, unsigned long& destLen,$/;"	f	namespace:lion
compress	lion/lionZLib.cc	/^void compress(void* dest, unsigned long& destLen,$/;"	f	namespace:lion
compress	pcu/pcu_io.c	/^  bool compress;$/;"	m	struct:pcu_file	file:
compressBound	lion/lionNoZLib.cc	/^unsigned long compressBound(unsigned long sourceLen)$/;"	f	namespace:lion
compressBound	lion/lionZLib.cc	/^unsigned long compressBound(unsigned long sourceLen)$/;"	f	namespace:lion
compressed_read	pcu/pcu_io.c	/^static void compressed_read(pcu_file* pf, void* data, size_t size)$/;"	f	file:
compressed_write	pcu/pcu_io.c	/^static void compressed_write(pcu_file* pf, void const* data, size_t size)$/;"	f	file:
computeCosAngle	apf/apf.cc	/^double computeCosAngle(Mesh* m, MeshEntity* pe, MeshEntity* e1, MeshEntity* e2,$/;"	f	namespace:apf
computeCosAngleInTet	apf/apfSimplexAngleCalcs.cc	/^double computeCosAngleInTet(Mesh* m, MeshEntity* tet,$/;"	f	namespace:apf
computeCosAngleInTri	apf/apfSimplexAngleCalcs.cc	/^double computeCosAngleInTri(Mesh* m, MeshEntity* tri,$/;"	f	namespace:apf
computeDistance	parma/diffMC/parma_graphDist.cc	/^  apf::MeshTag* computeDistance(apf::Mesh* m, parma::dcComponents& c) {$/;"	f	namespace:__anon74
computeEdgeEdgeCosAngleInTet	apf/apfSimplexAngleCalcs.cc	/^static double computeEdgeEdgeCosAngleInTet(Mesh* m, MeshEntity* tet,$/;"	f	namespace:apf
computeEdgeEdgeCosAngleInTri	apf/apfSimplexAngleCalcs.cc	/^static double computeEdgeEdgeCosAngleInTri(Mesh* m, MeshEntity* tri,$/;"	f	namespace:apf
computeEdgeFaceCosAngleInTet	apf/apfSimplexAngleCalcs.cc	/^static double computeEdgeFaceCosAngleInTet(Mesh* m, MeshEntity* tet,$/;"	f	namespace:apf
computeEdgeTangentAtVertex	apf/apfSimplexAngleCalcs.cc	/^Vector3 computeEdgeTangentAtVertex(Mesh* m, MeshEntity* edge,$/;"	f	namespace:apf
computeElementSets	ma/maCollapse.cc	/^void Collapse::computeElementSets()$/;"	f	class:ma::Collapse
computeElementSets	ma/maLayerCollapse.cc	/^void LayerCollapse::computeElementSets()$/;"	f	class:ma::LayerCollapse
computeFaceFaceCosAngleInTet	apf/apfSimplexAngleCalcs.cc	/^static double computeFaceFaceCosAngleInTet(Mesh* m, MeshEntity* tet,$/;"	f	namespace:apf
computeFaceNormalAtEdgeInTet	apf/apfSimplexAngleCalcs.cc	/^Vector3 computeFaceNormalAtEdgeInTet(Mesh* m, MeshEntity* tet,$/;"	f	namespace:apf
computeFaceNormalAtVertex	apf/apfSimplexAngleCalcs.cc	/^Vector3 computeFaceNormalAtVertex(Mesh* m, MeshEntity* face,$/;"	f	namespace:apf
computeInverse	stk/apfSTK.cc	/^void StkModels::computeInverse()$/;"	f	class:apf::StkModels
computeJacDetNodes	crv/crvQuality.cc	/^int Quality3D::computeJacDetNodes(apf::MeshEntity* e,$/;"	f	class:crv::Quality3D
computeNormals	ma/maSnapper.cc	/^static void computeNormals(Mesh* m, Upward& es, apf::NewArray<Vector>& normals)$/;"	f	namespace:ma
computeShortestHeightInTet	apf/apfSimplexAngleCalcs.cc	/^double computeShortestHeightInTet(Mesh* m, MeshEntity* tet,$/;"	f	namespace:apf
computeShortestHeightInTri	apf/apfSimplexAngleCalcs.cc	/^double computeShortestHeightInTri(Mesh* m, MeshEntity* tri,$/;"	f	namespace:apf
computeSizeFactor	spr/sprEstimateError.cc	/^static void computeSizeFactor(Estimation* e)$/;"	f	namespace:spr
computeSizeFactor	spr/sprEstimateTargetError.cc	/^static void computeSizeFactor(Estimation* e)$/;"	f	namespace:spr::target
computeTetJacobianDetFromBezierFormulation	crv/crvQuality.cc	/^double computeTetJacobianDetFromBezierFormulation(apf::Mesh* m,$/;"	f	namespace:crv
computeTetNodeIndex	crv/crvTables.cc	/^int computeTetNodeIndex(int P, int i, int j, int k)$/;"	f	namespace:crv
computeTriJacobianDetFromBezierFormulation	crv/crvQuality.cc	/^double computeTriJacobianDetFromBezierFormulation(apf::Mesh* m,$/;"	f	namespace:crv
computeTriNodeIndex	crv/crvTables.cc	/^int computeTriNodeIndex(int P, int i, int j)$/;"	f	namespace:crv
compute_l2_error	test/poisson.cc	/^    void compute_l2_error() {$/;"	f	class:__anon17::Poisson	file:
configure	ma/maInput.cc	/^Input* configure($/;"	f	namespace:ma
configureIdentity	ma/maInput.cc	/^Input* configureIdentity(Mesh* m, SizeField* f, SolutionTransfer* s)$/;"	f	namespace:ma
configureMatching	ma/maInput.cc	/^Input* configureMatching(Mesh* m, int n, SolutionTransfer* s)$/;"	f	namespace:ma
configureShapeCorrection	crv/crvAdapt.cc	/^ma::Input* configureShapeCorrection($/;"	f	namespace:crv
configureUniformRefine	ma/maInput.cc	/^Input* configureUniformRefine(Mesh* m, int n, SolutionTransfer* s)$/;"	f	namespace:ma
conn_to_osh	omega_h/apfOmega_h.cc	/^static void conn_to_osh(osh::Mesh* mesh_osh, apf::Mesh* mesh_apf,$/;"	f	namespace:apf
connectPlanes	test/fusion2.cc	/^static void connectPlanes(apf::Mesh2* m)$/;"	f	file:
const_iterator	can/canArray.h	/^    typedef T const* const_iterator;$/;"	t	class:can::Array
construct	apf/apfConstruct.cc	/^void construct(Mesh2* m, const int* conn, int nelem, int etype,$/;"	f	namespace:apf
constructElements	apf/apfConstruct.cc	/^static void constructElements($/;"	f	namespace:apf
constructMIS	apf/apfMIS.cc	/^  void constructMIS(Mesh* m, MeshTag* coloring, int vtx_dim, int color,$/;"	f	namespace:apf
constructNetGraph	parma/diffMC/maximalIndependentSet/misLuby.cc	/^  int constructNetGraph(partInfo& part) {$/;"	f	namespace:__anon50
constructRemotes	apf/apfConstruct.cc	/^static void constructRemotes(Mesh2* m, GlobalToVert& globalToVert)$/;"	f	namespace:apf
constructResidence	apf/apfConstruct.cc	/^static void constructResidence(Mesh2* m, GlobalToVert& globalToVert)$/;"	f	namespace:apf
constructVerts	apf/apfConstruct.cc	/^static void constructVerts($/;"	f	namespace:apf
container	pumi/GenTag.h	/^    Entry* container;$/;"	m	class:Taggable
contains	mds/mds.c	/^static int contains(struct mds_set* s, mds_id id)$/;"	f	file:
convergenceTolerance	crv/crvQuality.cc	/^static double convergenceTolerance = 0.01;$/;"	m	namespace:crv	file:
convert	apf/apfConvert.cc	/^void convert(Mesh *in, Mesh2 *out, MeshEntity** nodes, MeshEntity** elems, bool copy_data)$/;"	f	namespace:apf
convertField	apf/apfConvert.cc	/^    void convertField(Field* in, Field* out)$/;"	f	class:apf::Converter
convertFields	apf/apfConvert.cc	/^    void convertFields()$/;"	f	class:apf::Converter
convertGhostToEntWeight	parma/diffMC/parma_ghostWeights.cc	/^  Weights* convertGhostToEntWeight(GhostWeights* gw, int dim) {$/;"	f	namespace:parma
convertGlobalNumbering	apf/apfConvert.cc	/^    void convertGlobalNumbering($/;"	f	class:apf::Converter
convertGlobalNumberings	apf/apfConvert.cc	/^    void convertGlobalNumberings()$/;"	f	class:apf::Converter
convertInterpolatingToBezier	crv/crvCurveMesh.cc	/^void BezierCurver::convertInterpolatingToBezier()$/;"	f	class:crv::BezierCurver
convertInterpolationPoints	crv/crvCurveMesh.cc	/^void convertInterpolationPoints(apf::Mesh2* m, apf::MeshEntity* e,$/;"	f	namespace:crv
convertInterpolationPoints	crv/crvCurveMesh.cc	/^void convertInterpolationPoints(int n, int ne,$/;"	f	namespace:crv
convertNumbering	apf/apfConvert.cc	/^    void convertNumbering(Numbering* in, Numbering* out)$/;"	f	class:apf::Converter
convertNumberings	apf/apfConvert.cc	/^    void convertNumberings()$/;"	f	class:apf::Converter
convertQuadratic	apf/apfConvert.cc	/^    void convertQuadratic()$/;"	f	class:apf::Converter
convertQuadraticTetToBezier	ma/maQuality.cc	/^static void convertQuadraticTetToBezier(Vector xyz[10])$/;"	f	namespace:ma
convertResult	zoltan/apfZoltanMesh.cc	/^static Migration* convertResult(ZoltanMesh* b, ZoltanData* ztn)$/;"	f	namespace:apf
convertTag	apf/apfConvert.cc	/^    void convertTag(Mesh* inMesh, MeshTag* in, Mesh* outMesh, MeshTag* out)$/;"	f	class:apf::Converter
convertTags	apf/apfConvert.cc	/^    void convertTags()$/;"	f	class:apf::Converter
convertToPumi	test/runSimxAnisoAdapt.cc	/^apf::Mesh2* convertToPumi($/;"	f
convert_down	mds/mds.c	/^static void convert_down(struct mds* m,$/;"	f	file:
convs	apf_cap/apfCAP.cc	/^static int const* convs[Mesh::TYPES][4][4] =$/;"	m	namespace:apf	file:
convs	mds/mds.c	/^static int const* convs[MDS_TYPES][4][4] =$/;"	v	file:
cook	phasta/phCook.cc	/^  void cook(gmi_model*& g, apf::Mesh2*& m) {$/;"	f	namespace:chef
cook	phasta/phCook.cc	/^  void cook(gmi_model*& g, apf::Mesh2*& m,$/;"	f	namespace:chef
coordinateField	apf/apfMesh.h	/^    Field* coordinateField;$/;"	m	class:apf::Mesh
coordinates	phasta/phOutput.h	/^  double* coordinates;$/;"	m	struct:ph::EnsaArrays
coords	test/icesheet.cc	/^  double* coords;$/;"	m	struct:MeshInfo	file:
coords_from_osh	omega_h/apfOmega_h.cc	/^static void coords_from_osh(apf::Mesh* am, osh::Mesh* om) {$/;"	f	namespace:apf
coords_to_osh	omega_h/apfOmega_h.cc	/^static void coords_to_osh(osh::Mesh* om, apf::Mesh* am) {$/;"	f	namespace:apf
copy	can/canArray.h	/^    void copy(Array<T,0> const& other)$/;"	f	class:can::Array
copy	can/canArray.h	/^    void copy(Array<T,N> const& other)$/;"	f	class:can::Array
copy	mth/mthAD.h	/^    void copy(AD<B, 0> const& other)$/;"	f	class:mth::AD
copy	mth/mthAD.h	/^    void copy(AD<B, N> const& other)$/;"	f	class:mth::AD
copy	mth/mthTensor.h	/^    void copy(Matrix<T> const& b)$/;"	f	class:mth::Tensor
copy	mth/mthTensor.h	/^    void copy(Tensor<T> const& b)$/;"	f	class:mth::Tensor
copyData	apf/apf.cc	/^void copyData(Field* to, Field* from)$/;"	f	namespace:apf
copyFieldData	apf/apfFieldData.cc	/^void copyFieldData(FieldDataOf<T>* from, FieldDataOf<T>* to)$/;"	f	namespace:apf
copyFieldsFromBulk	stk/apfSTK.cc	/^void copyFieldsFromBulk($/;"	f	namespace:apf
copyFieldsToBulk	stk/apfSTK.cc	/^void copyFieldsToBulk($/;"	f	namespace:apf
copyFieldsToMeta	stk/apfSTK.cc	/^void copyFieldsToMeta($/;"	f	namespace:apf
copyMeshToBulk	stk/apfMeshSTK.cc	/^void copyMeshToBulk($/;"	f	namespace:apf
copyMeshToMeta	stk/apfMeshSTK.cc	/^void copyMeshToMeta(Mesh* m, StkModels& models, StkMetaData* meta)$/;"	f	namespace:apf
copyPlane	test/fusion2.cc	/^static void copyPlane(apf::Mesh2* m)$/;"	f	file:
copyTriangleNodes	crv/crvSubdivision.cc	/^static void copyTriangleNodes(int P, apf::NewArray<T>& nodes,$/;"	f	namespace:crv
copy_less	mds/mds_apf.c	/^static int copy_less(struct mds_copy a, struct mds_copy b)$/;"	f	file:
copy_set	mds/mds.c	/^static void copy_set(struct mds_set* to, struct mds_set* from)$/;"	f	file:
copy_string	gmi/gmi.c	/^static char* copy_string(const char* a)$/;"	f	file:
core	parma/diffMC/parma_components.h	/^      Level* core;$/;"	m	class:parma::dcComponents::Components
core_get_centroid	phasta/phRigidBody.cc	/^void core_get_centroid (int r_tag, double ct[]){$/;"	f
core_get_pos_on_surf	phasta/phSnap.cc	/^void core_get_pos_on_surf (double dx[], double dy[], double dz[], int numnp,$/;"	f
core_get_rbms	phasta/phRigidBody.cc	/^void core_get_rbms (std::vector<ph::rigidBodyMotion> &rbms) {$/;"	f
core_is_in_closure	phasta/phSnap.cc	/^void core_is_in_closure (int e_dim, int e_tag, int t_dim, int t_tag, int& answer) {$/;"	f
core_measure_mesh	phasta/phMeshQuality.cc	/^void core_measure_mesh (double x1[], double x2[], double x3[], int numnp,$/;"	f
core_mesh_quality	phasta/phastaChef.f	/^      module core_mesh_quality$/;"	m
core_rigid_body	phasta/phastaChef.f	/^      module core_rigid_body$/;"	m
core_snap	phasta/phastaChef.f	/^      module core_snap$/;"	m
core_update_rbms	phasta/phRigidBody.cc	/^void core_update_rbms (double tx[], double ty[], double tz[],$/;"	f
cos	mth/mthAD.h	/^AD<T, N> cos(AD<T, N> const& A)$/;"	f	namespace:mth
cos	mth/mthAD.h	/^double cos(double A)$/;"	f	namespace:mth
count	apf/apfMesh.cc	/^int Migration::count()$/;"	f	class:apf::Migration
count	apf/apfNumbering.cc	/^    int count;$/;"	m	class:apf::Counter	file:
count	apf_cap/apfCAP.cc	/^    int count;$/;"	m	class:apf::TagCAP	file:
count	apf_cap/apfCAP.cc	/^std::size_t MeshCAP::count(int dimension)$/;"	f	class:apf::MeshCAP
count	apf_sim/apfSIM.cc	/^    int count;$/;"	m	class:apf::TagSIM	file:
count	apf_sim/apfSIM.cc	/^std::size_t MeshSIM::count(int dimension)$/;"	f	class:apf::MeshSIM
count	mds/apfMDS.cc	/^    std::size_t count(int dimension)$/;"	f	class:apf::MeshMDS
count	parma/diffMC/parma_vtxPtnWriter.cc	/^    int count() {$/;"	f	class:__anon72::Ptn
count	pcu/pcu_order.c	/^  int count;$/;"	m	struct:pcu_order_struct	file:
count	pumi/pumi_ghost.cc	/^int Ghosting::count()$/;"	f	class:Ghosting
count	pumi/pumi_ghost.cc	/^int Ghosting::count(pMeshEnt e, int d)$/;"	f	class:Ghosting
count	pumi/pumi_list.h	/^    std::size_t count;$/;"	m	class:List
count	pumi/pumi_mesh.cc	/^int Distribution::count()$/;"	f	class:Distribution
countComponents	apf/apf.cc	/^int countComponents(Field* f)$/;"	f	namespace:apf
countComponents	apf/apfMatrixField.cc	/^int MatrixField::countComponents() const$/;"	f	class:apf::MatrixField
countComponents	apf/apfNumbering.cc	/^int NumberingOf<T>::countComponents() const {return components;}$/;"	f	class:apf::NumberingOf
countComponents	apf/apfNumbering.cc	/^int countComponents(GlobalNumbering* n)$/;"	f	namespace:apf
countComponents	apf/apfNumbering.cc	/^int countComponents(Numbering* n)$/;"	f	namespace:apf
countComponents	apf/apfPackedField.h	/^    virtual int countComponents() const {return components;}$/;"	f	class:apf::PackedField
countComponents	apf/apfScalarField.cc	/^int ScalarField::countComponents() const$/;"	f	class:apf::ScalarField
countComponents	apf/apfVectorField.cc	/^int VectorField::countComponents() const$/;"	f	class:apf::VectorField
countDOFs	apf/apfMixedNumbering.cc	/^int countDOFs(std::vector<GlobalNumbering*> const& n) {$/;"	f	namespace:apf
countDOFs	apf/apfMixedNumbering.cc	/^int countDOFs(std::vector<Numbering*> const& n) {$/;"	f	namespace:apf
countElementNodes	apf/apfShape.cc	/^int countElementNodes(FieldShape* s, int type)$/;"	f	namespace:apf
countElementNodes	apf/apfVtk.cc	/^static int countElementNodes(Numbering* n, MeshEntity* e)$/;"	f	namespace:apf
countEntitiesOfType	apf/apfMesh.cc	/^int countEntitiesOfType(Mesh* m, int type)$/;"	f	namespace:apf
countEntitiesOn	apf/apfMesh.cc	/^int countEntitiesOn(Mesh* m, ModelEntity* me, int dim)$/;"	f	namespace:apf
countEntitiesWithFlag	ma/maTetrahedronize.cc	/^static int countEntitiesWithFlag(Adapt* a, int flag, int dim)$/;"	f	namespace:ma
countEssentialBCs	phasta/phInput.cc	/^int countEssentialBCs(Input& in)$/;"	f	namespace:ph
countFieldNodes	apf/apfNumbering.cc	/^static int countFieldNodes(FieldBase* f)$/;"	f	namespace:apf
countFields	apf/apfMesh.cc	/^int Mesh::countFields()$/;"	f	class:apf::Mesh
countFixed	apf/apfNumbering.cc	/^int countFixed(Numbering* n)$/;"	f	namespace:apf
countGaussPoints	apf/apf.cc	/^int countGaussPoints(int type, int order)$/;"	f	namespace:apf
countGlobalNumberings	apf/apfMesh.cc	/^int Mesh::countGlobalNumberings()$/;"	f	class:apf::Mesh
countIPs	apf/apfVtk.cc	/^static int countIPs(FieldBase* f, int cellDim)$/;"	f	namespace:apf
countIntPoints	apf/apf.cc	/^int countIntPoints(MeshElement* e, int order)$/;"	f	namespace:apf
countIntegrations	apf/apfIntegrate.cc	/^    virtual int countIntegrations() const {return 1;}$/;"	f	class:apf::PrismIntegration
countIntegrations	apf/apfIntegrate.cc	/^    virtual int countIntegrations() const {return 1;}$/;"	f	class:apf::PyramidIntegration
countIntegrations	apf/apfIntegrate.cc	/^    virtual int countIntegrations() const {return 2;}$/;"	f	class:apf::HexahedronIntegration
countIntegrations	apf/apfIntegrate.cc	/^    virtual int countIntegrations() const {return 3;}$/;"	f	class:apf::QuadIntegration
countIntegrations	apf/apfIntegrate.cc	/^    virtual int countIntegrations() const {return 6;}$/;"	f	class:apf::EdgeIntegration
countIntegrations	apf/apfIntegrate.cc	/^    virtual int countIntegrations() const {return 6;}$/;"	f	class:apf::TriangleIntegration
countIntegrations	apf/apfIntegrate.cc	/^    virtual int countIntegrations() const {return 7;}$/;"	f	class:apf::TetrahedronIntegration
countMap	apf/apfMesh.h	/^  std::map<int, size_t> countMap;$/;"	m	struct:apf::MatchedSharing
countNaturalBCs	phasta/phInput.cc	/^int countNaturalBCs(Input& in)$/;"	f	namespace:ph
countNodes	apf/apf.cc	/^int countNodes(Element* e)$/;"	f	namespace:apf
countNodes	apf/apfHierarchic.cc	/^    int countNodes() const { return 1; }$/;"	f	class:apf::HVertex
countNodes	apf/apfHierarchic.cc	/^    int countNodes() const { return 3; }$/;"	f	class:apf::HEdge2
countNodes	apf/apfHierarchic.cc	/^    int countNodes() const { return 4; }$/;"	f	class:apf::HEdge3
countNodes	apf/apfHierarchic.cc	/^    int countNodes() const { return 6; }$/;"	f	class:apf::HTriangle2
countNodes	apf/apfHierarchic.cc	/^    int countNodes() const {return 10;}$/;"	f	class:apf::HTetrahedron2
countNodes	apf/apfHierarchic.cc	/^    int countNodes() const {return 10;}$/;"	f	class:apf::HTriangle3
countNodes	apf/apfIPShape.cc	/^        int countNodes() const {return 1;}$/;"	f	class:apf::ConstantIPFit::Tetrahedron
countNodes	apf/apfIPShape.cc	/^        int countNodes() const {return 1;}$/;"	f	class:apf::ConstantIPFit::Triangle
countNodes	apf/apfIPShape.cc	/^        int countNodes() const {return 3;}$/;"	f	class:apf::LinearIPFit::Triangle
countNodes	apf/apfIPShape.cc	/^        int countNodes() const {return 4;}$/;"	f	class:apf::LinearIPFit::Tetrahedron
countNodes	apf/apfIPShape.cc	/^        int countNodes() const$/;"	f	class:apf::VoronoiShape::Element
countNodes	apf/apfNumbering.cc	/^int countNodes(GlobalNumbering* n)$/;"	f	namespace:apf
countNodes	apf/apfNumbering.cc	/^int countNodes(Numbering* n)$/;"	f	namespace:apf
countNodes	apf/apfShape.cc	/^        int countNodes() const {return 10;}$/;"	f	class:apf::LagrangeCubic::Triangle
countNodes	apf/apfShape.cc	/^        int countNodes() const {return 10;}$/;"	f	class:apf::QuadraticBase::Tetrahedron
countNodes	apf/apfShape.cc	/^        int countNodes() const {return 1;}$/;"	f	class:apf::Constant::Element
countNodes	apf/apfShape.cc	/^        int countNodes() const {return 1;}$/;"	f	class:apf::LagrangeCubic::Vertex
countNodes	apf/apfShape.cc	/^        int countNodes() const {return 1;}$/;"	f	class:apf::Linear::Vertex
countNodes	apf/apfShape.cc	/^        int countNodes() const {return 20;}$/;"	f	class:apf::LagrangeCubic::Tetrahedron
countNodes	apf/apfShape.cc	/^        int countNodes() const {return 2;}$/;"	f	class:apf::Linear::Edge
countNodes	apf/apfShape.cc	/^        int countNodes() const {return 3;}$/;"	f	class:apf::Linear::Triangle
countNodes	apf/apfShape.cc	/^        int countNodes() const {return 3;}$/;"	f	class:apf::QuadraticBase::Edge
countNodes	apf/apfShape.cc	/^        int countNodes() const {return 4;}$/;"	f	class:apf::LagrangeCubic::Edge
countNodes	apf/apfShape.cc	/^        int countNodes() const {return 4;}$/;"	f	class:apf::Linear::Quad
countNodes	apf/apfShape.cc	/^        int countNodes() const {return 4;}$/;"	f	class:apf::Linear::Tetrahedron
countNodes	apf/apfShape.cc	/^        int countNodes() const {return 5;}$/;"	f	class:apf::Linear::Pyramid
countNodes	apf/apfShape.cc	/^        int countNodes() const {return 6;}$/;"	f	class:apf::Linear::Prism
countNodes	apf/apfShape.cc	/^        int countNodes() const {return 6;}$/;"	f	class:apf::QuadraticBase::Triangle
countNodes	apf/apfShape.cc	/^        int countNodes() const {return 8;}$/;"	f	class:apf::Linear::Hexahedron
countNodes	apf/apfShape.cc	/^        int countNodes() const {return 9;}$/;"	f	class:apf::LagrangeQuadratic::Quad
countNodes	apf/apfShape.cc	/^      int countNodes() const {return 8;}$/;"	f	class:apf::SerendipityQuadratic::Quad
countNodes	crv/crvBezier.cc	/^    int countNodes() const {$/;"	f	class:crv::Bezier::Tetrahedron
countNodes	crv/crvBezier.cc	/^    int countNodes() const {$/;"	f	class:crv::GregorySurface4::Tetrahedron
countNodes	crv/crvBezier.cc	/^    int countNodes() const {return 1;}$/;"	f	class:crv::Bezier::Vertex
countNodes	crv/crvBezier.cc	/^    int countNodes() const {return P+1;}$/;"	f	class:crv::Bezier::Edge
countNodes	crv/crvBezier.cc	/^    int countNodes() const {return getNumControlPoints(apf::Mesh::TRIANGLE,P);}$/;"	f	class:crv::Bezier::Triangle
countNodes	crv/crvBezier.cc	/^    int countNodes() const$/;"	f	class:crv::GregorySurface4::Triangle
countNodesOn	apf/apfField.cc	/^int FieldBase::countNodesOn(MeshEntity* e)$/;"	f	class:apf::FieldBase
countNodesOn	apf/apfHierarchic.cc	/^    int countNodesOn(int type) {$/;"	f	class:apf::Hierarchic2
countNodesOn	apf/apfHierarchic.cc	/^    int countNodesOn(int type)$/;"	f	class:apf::Hierarchic3
countNodesOn	apf/apfIPShape.cc	/^    int countNodesOn(int type)$/;"	f	class:apf::IPBase
countNodesOn	apf/apfShape.cc	/^    int countNodesOn(int type)$/;"	f	class:apf::Constant
countNodesOn	apf/apfShape.cc	/^    int countNodesOn(int type)$/;"	f	class:apf::LagrangeCubic
countNodesOn	apf/apfShape.cc	/^    int countNodesOn(int type)$/;"	f	class:apf::LagrangeQuadratic
countNodesOn	apf/apfShape.cc	/^    int countNodesOn(int type)$/;"	f	class:apf::Linear
countNodesOn	apf/apfShape.cc	/^    int countNodesOn(int type)$/;"	f	class:apf::SerendipityQuadratic
countNodesOn	crv/crvBezier.cc	/^  int countNodesOn(int type)$/;"	f	class:crv::Bezier
countNodesOn	crv/crvBezier.cc	/^  int countNodesOn(int type)$/;"	f	class:crv::GregorySurface4
countNumberInvalidElements	crv/crv.cc	/^int countNumberInvalidElements(apf::Mesh2* m)$/;"	f	namespace:crv
countNumberings	apf/apfMesh.cc	/^int Mesh::countNumberings()$/;"	f	class:apf::Mesh
countOwned	apf/apfMesh.cc	/^int countOwned(Mesh* m, int dim, Sharing * shr)$/;"	f	namespace:apf
countOwned	parma/diffMC/parma_vtxPtnWriter.cc	/^    int countOwned(apf::Mesh* m) {$/;"	f	class:__anon72::Ptn	file:
countOwnedEntitiesOfType	crv/crvVtk.cc	/^static int countOwnedEntitiesOfType(apf::Mesh* m, int type)$/;"	f	namespace:crv
countPatchPoints	spr/sprRecoverField.cc	/^static int countPatchPoints(Patch* p)$/;"	f	namespace:spr
countPoints	apf/apfIntegrate.cc	/^        virtual int countPoints() const {return 11;}$/;"	f	class:apf::TetrahedronIntegration::N4
countPoints	apf/apfIntegrate.cc	/^        virtual int countPoints() const {return 12;}$/;"	f	class:apf::TriangleIntegration::N6
countPoints	apf/apfIntegrate.cc	/^        virtual int countPoints() const {return 15;}$/;"	f	class:apf::TetrahedronIntegration::N5
countPoints	apf/apfIntegrate.cc	/^        virtual int countPoints() const {return 1;}$/;"	f	class:apf::EdgeIntegration::N1
countPoints	apf/apfIntegrate.cc	/^        virtual int countPoints() const {return 1;}$/;"	f	class:apf::HexahedronIntegration::N1
countPoints	apf/apfIntegrate.cc	/^        virtual int countPoints() const {return 1;}$/;"	f	class:apf::PrismIntegration::N1
countPoints	apf/apfIntegrate.cc	/^        virtual int countPoints() const {return 1;}$/;"	f	class:apf::PyramidIntegration::N1
countPoints	apf/apfIntegrate.cc	/^        virtual int countPoints() const {return 1;}$/;"	f	class:apf::QuadIntegration::N1
countPoints	apf/apfIntegrate.cc	/^        virtual int countPoints() const {return 1;}$/;"	f	class:apf::TetrahedronIntegration::N1
countPoints	apf/apfIntegrate.cc	/^        virtual int countPoints() const {return 1;}$/;"	f	class:apf::TriangleIntegration::N1
countPoints	apf/apfIntegrate.cc	/^        virtual int countPoints() const {return 24;}$/;"	f	class:apf::TetrahedronIntegration::N6
countPoints	apf/apfIntegrate.cc	/^        virtual int countPoints() const {return 2;}$/;"	f	class:apf::EdgeIntegration::N2
countPoints	apf/apfIntegrate.cc	/^        virtual int countPoints() const {return 35;}$/;"	f	class:apf::TetrahedronIntegration::N7
countPoints	apf/apfIntegrate.cc	/^        virtual int countPoints() const {return 3;}$/;"	f	class:apf::EdgeIntegration::N3
countPoints	apf/apfIntegrate.cc	/^        virtual int countPoints() const {return 3;}$/;"	f	class:apf::TriangleIntegration::N2
countPoints	apf/apfIntegrate.cc	/^        virtual int countPoints() const {return 4;}$/;"	f	class:apf::EdgeIntegration::N4
countPoints	apf/apfIntegrate.cc	/^        virtual int countPoints() const {return 4;}$/;"	f	class:apf::QuadIntegration::N2
countPoints	apf/apfIntegrate.cc	/^        virtual int countPoints() const {return 4;}$/;"	f	class:apf::TetrahedronIntegration::N2
countPoints	apf/apfIntegrate.cc	/^        virtual int countPoints() const {return 4;}$/;"	f	class:apf::TriangleIntegration::N3
countPoints	apf/apfIntegrate.cc	/^        virtual int countPoints() const {return 5;}$/;"	f	class:apf::EdgeIntegration::N5
countPoints	apf/apfIntegrate.cc	/^        virtual int countPoints() const {return 5;}$/;"	f	class:apf::TetrahedronIntegration::N3
countPoints	apf/apfIntegrate.cc	/^        virtual int countPoints() const {return 6;}$/;"	f	class:apf::EdgeIntegration::N6
countPoints	apf/apfIntegrate.cc	/^        virtual int countPoints() const {return 6;}$/;"	f	class:apf::TriangleIntegration::N4
countPoints	apf/apfIntegrate.cc	/^        virtual int countPoints() const {return 7;}$/;"	f	class:apf::TriangleIntegration::N5
countPoints	apf/apfIntegrate.cc	/^        virtual int countPoints() const {return 8;}$/;"	f	class:apf::HexahedronIntegration::N2
countPoints	apf/apfIntegrate.cc	/^        virtual int countPoints() const {return 9;}$/;"	f	class:apf::QuadIntegration::N3
countPolynomialTerms	spr/sprRecoverField.cc	/^static int countPolynomialTerms(int dim, int order)$/;"	f	namespace:spr
countRegions	test/runSimxAnisoAdapt.cc	/^static int countRegions(pMesh mesh)$/;"	f	file:
countScalarBCs	phasta/phInput.cc	/^int countScalarBCs(Input& in)$/;"	f	namespace:ph
countUpward	apf_cap/apfCAP.cc	/^int MeshCAP::countUpward(MeshEntity* e)$/;"	f	class:apf::MeshCAP
countUpward	apf_sim/apfSIM.cc	/^int MeshSIM::countUpward(MeshEntity* e)$/;"	f	class:apf::MeshSIM
countUpward	mds/apfMDS.cc	/^    int countUpward(MeshEntity* e)$/;"	f	class:apf::MeshMDS
countValuesOn	apf/apfField.cc	/^int FieldBase::countValuesOn(MeshEntity* e)$/;"	f	class:apf::FieldBase
countVerts	test/runSimxAnisoAdapt.cc	/^static int countVerts(pMesh mesh)$/;"	f	file:
count_ghost_dofs	apf/apfMixedNumbering.cc	/^static int count_ghost_dofs($/;"	f	namespace:apf
count_owned_dofs	apf/apfMixedNumbering.cc	/^static int count_owned_dofs($/;"	f	namespace:apf
count_tagged	mds/mds_smb.c	/^static mds_id count_tagged(struct mds_apf* m, struct mds_tag* tag, int t)$/;"	f	file:
cpus	phasta/phiotimer.cc	/^  size_t cpus;$/;"	m	struct:phastaio_stats	file:
crawl	ma/maCrawler.cc	/^  Entity* crawl(Entity* v)$/;"	f	struct:ma::LayerNumberer
crawl	ma/maLayerCoarsen.cc	/^  Entity* crawl(Entity* v)$/;"	f	struct:ma::CurveLocalizer
crawl	ma/maLayerRefine.cc	/^  Entity* crawl(Entity* e)$/;"	f	struct:ma::SplitTagger
crawl	ma/maLayerRefine.cc	/^  Entity* crawl(Entity* t)$/;"	f	struct:ma::Disambiguator
crawl	ma/maLayerSnap.cc	/^  Entity* crawl(Entity* v)$/;"	f	struct:ma::BaseTopLinker
crawl	ma/maLayerSnap.cc	/^  Entity* crawl(Entity* v)$/;"	f	struct:ma::LayerSnapper
crawl	ma/maLayerSnap.cc	/^  Entity* crawl(Entity* v)$/;"	f	struct:ma::SnapTagger
crawl	ma/maLayerSnap.cc	/^  Entity* crawl(Entity* v)$/;"	f	struct:ma::UnsnapChecker
crawl	ma/maLayerSnap.cc	/^  Entity* crawl(Entity* v)$/;"	f	struct:ma::Unsnapper
crawl	ma/maTetrahedronize.cc	/^  Entity* crawl(Entity* e)$/;"	f	struct:ma::QuadFlagger
crawl	ma/maTetrahedronize.cc	/^  Entity* crawl(Entity* e)$/;"	f	struct:ma::QuadMarker
crawlLayer	ma/maCrawler.cc	/^void crawlLayer(Crawler* c, Crawler::Layer& layer)$/;"	f	namespace:ma
crawlLayers	ma/maCrawler.cc	/^void crawlLayers(Crawler* c)$/;"	f	namespace:ma
crawlLayers_doubleSync	ma/maLayerSnap.cc	/^static void crawlLayers_doubleSync(Crawler* c)$/;"	f	namespace:ma
create	gmi/gmi_mesh.c	/^static struct gmi_model* create(const char* filename,$/;"	f	file:
create	gmi/gmi_null.c	/^static struct gmi_model* create(const char* filename)$/;"	f	file:
createAdjacency	apf_cap/apfCAP.cc	/^void MeshCAP::createAdjacency(int from_dim, int to_dim)$/;"	f	class:apf::MeshCAP
createAdjacency	apf_sim/apfSIM.cc	/^void MeshSIM::createAdjacency(int from_dim, int to_dim)$/;"	f	class:apf::MeshSIM
createAdjacency	mds/apfMDS.cc	/^    void createAdjacency(int from_dim, int to_dim)$/;"	f	class:apf::MeshMDS
createCavityMesh	ma/maDBG.cc	/^void createCavityMesh(ma::Adapt* a,$/;"	f	namespace:ma_dbg
createDimension	apf/apfConvert.cc	/^    void createDimension(int dim)$/;"	f	class:apf::Converter
createDimension	apf/apfConvert.cc	/^    void createDimension(int dim, MeshEntity** elems)$/;"	f	class:apf::Converter
createDistTag	parma/diffMC/parma_graphDist.cc	/^  apf::MeshTag* createDistTag(apf::Mesh* m) {$/;"	f	namespace:__anon74
createDoubleTag	apf_cap/apfCAP.cc	/^MeshTag* MeshCAP::createDoubleTag(const char* name, int size)$/;"	f	class:apf::MeshCAP
createDoubleTag	apf_sim/apfSIM.cc	/^MeshTag* MeshSIM::createDoubleTag(const char* name, int size)$/;"	f	class:apf::MeshSIM
createDoubleTag	mds/apfMDS.cc	/^    MeshTag* createDoubleTag(const char* name, int size)$/;"	f	class:apf::MeshMDS
createElement	apf/apf.cc	/^Element* createElement(Field* f, MeshElement* e)$/;"	f	namespace:apf
createElement	apf/apf.cc	/^Element* createElement(Field* f, MeshEntity* e)$/;"	f	namespace:apf
createEmptyMesh	test/verify_convert.cc	/^apf::Mesh2* createEmptyMesh()$/;"	f
createEntities	apf/apfConvert.cc	/^    void createEntities()$/;"	f	class:apf::Converter
createEntity	apf/apfMesh2.h	/^    MeshEntity* createEntity(int type, ModelEntity* c, MeshEntity** down)$/;"	f	class:apf::Mesh2
createEntity_	apf_cap/apfCAP.cc	/^MeshEntity* MeshCAP::createEntity_(int type, ModelEntity* me, MeshEntity** down)$/;"	f	class:apf::MeshCAP
createEntity_	apf_sim/apfSIM.h	/^    MeshEntity * createEntity_(int, ModelEntity*, MeshEntity**) { return NULL; }$/;"	f	class:apf::MeshSIM
createEntity_	mds/apfMDS.cc	/^    MeshEntity* createEntity_(int type, ModelEntity* c,$/;"	f	class:apf::MeshMDS
createField	apf/apf.cc	/^Field* createField(Mesh* m, const char* name, int valueType, FieldShape* shape)$/;"	f	namespace:apf
createFieldOn	apf/apf.cc	/^Field* createFieldOn(Mesh* m, const char* name, int valueType)$/;"	f	namespace:apf
createFieldTransfer	ma/maSolutionTransfer.cc	/^SolutionTransfer* createFieldTransfer(apf::Field* f)$/;"	f	namespace:ma
createGeneralField	apf/apf.cc	/^Field* createGeneralField($/;"	f	namespace:apf
createGlobalNumbering	apf/apfNumbering.cc	/^GlobalNumbering* createGlobalNumbering($/;"	f	namespace:apf
createGlobalNumbering	apf/apfNumbering.cc	/^GlobalNumbering* createGlobalNumbering(Field* f)$/;"	f	namespace:apf
createIPField	apf/apf.cc	/^Field* createIPField(Mesh* m, const char* name, int valueType, int order)$/;"	f	namespace:apf
createIntTag	apf_cap/apfCAP.cc	/^MeshTag* MeshCAP::createIntTag(const char* name, int size)$/;"	f	class:apf::MeshCAP
createIntTag	apf_sim/apfSIM.cc	/^MeshTag* MeshSIM::createIntTag(const char* name, int size)$/;"	f	class:apf::MeshSIM
createIntTag	mds/apfMDS.cc	/^    MeshTag* createIntTag(const char* name, int size)$/;"	f	class:apf::MeshMDS
createLagrangeField	apf/apf.cc	/^Field* createLagrangeField(Mesh* m, const char* name, int valueType, int order)$/;"	f	namespace:apf
createLongTag	apf_cap/apfCAP.cc	/^MeshTag* MeshCAP::createLongTag(const char* name, int size)$/;"	f	class:apf::MeshCAP
createLongTag	apf_sim/apfSIM.cc	/^MeshTag* MeshSIM::createLongTag(const char* name, int size)$/;"	f	class:apf::MeshSIM
createLongTag	mds/apfMDS.cc	/^    MeshTag* createLongTag(const char* name, int size)$/;"	f	class:apf::MeshMDS
createMatches	apf/apfConvert.cc	/^    void createMatches(int dim)$/;"	f	class:apf::Converter
createMdsMesh	mds/apfMDS.cc	/^Mesh2* createMdsMesh(gmi_model* model, Mesh* from, bool reorder, bool copy_data)$/;"	f	namespace:apf
createMesh	apf_cap/apfCAP.cc	/^Mesh2* createMesh(MeshDatabaseInterface* mdb, GeometryDatabaseInterface* gdb)$/;"	f	namespace:apf
createMesh	apf_cap/apfCAP.cc	/^Mesh2* createMesh(capMesh* mesh)$/;"	f	namespace:apf
createMesh	apf_sim/apfSIM.cc	/^Mesh2* createMesh(pParMesh mesh)$/;"	f	namespace:apf
createMesh	test/1d.cc	/^void createMesh(gmi_model*& g, apf::Mesh2*& m, int n)$/;"	f
createMesh	test/verify_convert.cc	/^apf::Mesh2* createMesh()$/;"	f
createMesh2D	test/bezierElevation.cc	/^apf::Mesh2* createMesh2D()$/;"	f
createMesh2D	test/bezierMesh.cc	/^apf::Mesh2* createMesh2D()$/;"	f
createMesh2D	test/bezierMisc.cc	/^apf::Mesh2* createMesh2D()$/;"	f
createMesh2D	test/bezierRefine.cc	/^apf::Mesh2* createMesh2D()$/;"	f
createMesh2D	test/bezierSubdivision.cc	/^apf::Mesh2* createMesh2D()$/;"	f
createMesh2D	test/bezierValidity.cc	/^apf::Mesh2* createMesh2D()$/;"	f
createMesh3D	test/bezierElevation.cc	/^apf::Mesh2* createMesh3D()$/;"	f
createMesh3D	test/bezierMesh.cc	/^apf::Mesh2* createMesh3D()$/;"	f
createMesh3D	test/bezierMisc.cc	/^apf::Mesh2* createMesh3D()$/;"	f
createMesh3D	test/bezierRefine.cc	/^apf::Mesh2* createMesh3D()$/;"	f
createMesh3D	test/bezierSubdivision.cc	/^apf::Mesh2* createMesh3D()$/;"	f
createMesh3D	test/bezierValidity.cc	/^apf::Mesh2* createMesh3D()$/;"	f
createMeshElement	apf/apf.cc	/^MeshElement* createMeshElement(Mesh* m, MeshEntity* e)$/;"	f	namespace:apf
createMeshElement	apf/apf.cc	/^MeshElement* createMeshElement(apf::Field* f, MeshEntity*e)$/;"	f	namespace:apf
createNumbering	apf/apfNumbering.cc	/^Numbering* createNumbering($/;"	f	namespace:apf
createNumbering	apf/apfNumbering.cc	/^Numbering* createNumbering(Field* f)$/;"	f	namespace:apf
createPackedField	apf/apf.cc	/^Field* createPackedField(Mesh* m, const char* name, int components,$/;"	f	namespace:apf
createRemotes	apf/apfConvert.cc	/^    void createRemotes(int dim)$/;"	f	class:apf::Converter
createSIMField	apf_sim/apfSIM.cc	/^apf::Field* createSIMField(Mesh* m, const char* name, int valueType,$/;"	f	namespace:apf
createSIMFieldOn	apf_sim/apfSIM.cc	/^apf::Field* createSIMFieldOn(Mesh* m, const char* name, int valueType)$/;"	f	namespace:apf
createSIMGeneralField	apf_sim/apfSIM.cc	/^apf::Field* apf::createSIMGeneralField($/;"	f	class:apf
createSIMLagrangeField	apf_sim/apfSIM.cc	/^apf::Field* createSIMLagrangeField(Mesh* m, const char* name, int valueType, int order)$/;"	f	namespace:apf
createSIMPackedField	apf_sim/apfSIM.cc	/^apf::Field* createSIMPackedField(Mesh* m, const char* name, int components,$/;"	f	namespace:apf
createStepField	apf/apf.cc	/^Field* createStepField(Mesh* m, const char* name, int valueType)$/;"	f	namespace:apf
createTags	apf/apfTagData.cc	/^void TagData::createTags(const char* name, int components)$/;"	f	class:apf::TagData
createUserField	apf/apf.cc	/^Field* createUserField(Mesh* m, const char* name, int valueType, FieldShape* s,$/;"	f	namespace:apf
createVert	apf/apfMesh2.h	/^    MeshEntity* createVert(ModelEntity* c)$/;"	f	class:apf::Mesh2
createVert_	apf_cap/apfCAP.cc	/^MeshEntity* MeshCAP::createVert_(ModelEntity* me)$/;"	f	class:apf::MeshCAP
createVert_	apf_sim/apfSIM.h	/^    MeshEntity * createVert_(ModelEntity*) { return NULL; }$/;"	f	class:apf::MeshSIM
createVert_	mds/apfMDS.cc	/^    MeshEntity* createVert_(ModelEntity* c)$/;"	f	class:apf::MeshMDS
createVertex	apf/apfMesh2.cc	/^MeshEntity* Mesh2::createVertex(ModelEntity* c, Vector3 const& point,$/;"	f	class:apf::Mesh2
createVertices	apf/apfConvert.cc	/^    void createVertices()$/;"	f	class:apf::Converter
createVertices	apf/apfConvert.cc	/^    void createVertices(MeshEntity** nodes)$/;"	f	class:apf::Converter
createVolumeMesh	test/capStoneAttachSolution.cc	/^apf::Mesh2* createVolumeMesh(apf::Mesh2* m, const std::vector<row> &t, int s, std::vector<std::vector<apf::MeshEntity*> > &surfToStrandMap)$/;"	f
create_ghost	apf/apfMixedNumbering.cc	/^static void create_ghost($/;"	f	namespace:apf
create_global	apf/apfMixedNumbering.cc	/^static void create_global($/;"	f	namespace:apf
create_native	gmi_sim/gmi_sim.cc	/^static gmi_model* create_native(const char* filename)$/;"	f	file:
create_owned	apf/apfMixedNumbering.cc	/^static void create_owned($/;"	f	namespace:apf
create_sets	stk/apfSTK.cc	/^StkModels* create_sets(Mesh* m, const char* filename) {$/;"	f	namespace:apf
create_smd	gmi_sim/gmi_sim.cc	/^static gmi_model* create_smd(const char* filename)$/;"	f	file:
creator	gmi/gmi.c	/^struct creator {$/;"	s	file:
creators	gmi/gmi.c	/^struct creators {$/;"	s	file:
cross	apf/apfMatrix.cc	/^Matrix3x3 cross(Vector3 const& u)$/;"	f	namespace:apf
cross	apf/apfVector.h	/^inline Vector<3> cross(Vector<3> const& a, Vector<3> const& b)$/;"	f	namespace:apf
cross	mth/mth_def.h	/^Matrix<T,3,3> cross(Vector<T,3> const& a)$/;"	f	namespace:mth
cross	mth/mth_def.h	/^Vector<T,3> cross(Vector<T,3> const& a, Vector<T,3> const& b)$/;"	f	namespace:mth
crv	crv/crv.cc	/^namespace crv {$/;"	n	file:
crv	crv/crv.h	/^namespace crv {$/;"	n
crv	crv/crvAdapt.cc	/^namespace crv {$/;"	n	file:
crv	crv/crvAdapt.h	/^namespace crv {$/;"	n
crv	crv/crvBernstein.cc	/^namespace crv {$/;"	n	file:
crv	crv/crvBezier.cc	/^namespace crv {$/;"	n	file:
crv	crv/crvBezier.h	/^namespace crv {$/;"	n
crv	crv/crvBezierPoints.cc	/^namespace crv {$/;"	n	file:
crv	crv/crvBezierShapes.cc	/^namespace crv {$/;"	n	file:
crv	crv/crvBezierShapes.h	/^namespace crv {$/;"	n
crv	crv/crvBlended.cc	/^namespace crv {$/;"	n	file:
crv	crv/crvCurveMesh.cc	/^namespace crv {$/;"	n	file:
crv	crv/crvElevation.cc	/^namespace crv {$/;"	n	file:
crv	crv/crvG1Points.cc	/^namespace crv {$/;"	n	file:
crv	crv/crvMath.cc	/^namespace crv {$/;"	n	file:
crv	crv/crvMath.h	/^namespace crv {$/;"	n
crv	crv/crvQuality.cc	/^namespace crv {$/;"	n	file:
crv	crv/crvQuality.h	/^namespace crv {$/;"	n
crv	crv/crvReposition.cc	/^namespace crv {$/;"	n	file:
crv	crv/crvShape.cc	/^namespace crv {$/;"	n	file:
crv	crv/crvShape.h	/^namespace crv {$/;"	n
crv	crv/crvShapeFixer.cc	/^namespace crv {$/;"	n	file:
crv	crv/crvShapeFixer.h	/^namespace crv {$/;"	n
crv	crv/crvShapeHandler.cc	/^namespace crv {$/;"	n	file:
crv	crv/crvSnap.cc	/^namespace crv {$/;"	n	file:
crv	crv/crvSnap.h	/^namespace crv {$/;"	n
crv	crv/crvSubdivision.cc	/^namespace crv {$/;"	n	file:
crv	crv/crvTables.cc	/^namespace crv {$/;"	n	file:
crv	crv/crvTables.h	/^namespace crv {$/;"	n
crv	crv/crvVtk.cc	/^namespace crv {$/;"	n	file:
ctors	gmi/gmi.c	/^static struct creators* ctors = NULL;$/;"	v	typeref:struct:creators	file:
ctrPts1	test/fusion3.cc	/^double ctrPts1[]={1.016280,-0.491436,1.016339,-0.576055,1.016458,-0.745292,1.013586,-0.885286,1.005280,-1.187189,1.018980,-1.259631,1.145615,-1.358098,1.279885,-1.374623,1.371504,-1.366860,1.372193,-1.324668,1.374535,-1.254708,1.466892,-1.244305,1.579787,-1.249065,1.688906,-1.253107,1.765520,-1.250035,1.767502,-1.216165,1.786996,-1.173692,1.894360,-1.111232,2.019187,-1.050151,2.133636,-0.971656,2.214745,-0.791719,2.292841,-0.590573,2.361567,-0.392790,2.370055,-0.221740,2.366193,-0.125585,2.364867,-0.042481,2.364982,0.042260,2.365556,0.127201,2.367961,0.226271,2.365545,0.384391,2.327108,0.519472,2.248071,0.724465,2.147787,0.983202,2.049837,1.059713,1.796218,1.079554,1.643892,1.075869,1.596925,1.094105,1.529310,1.157013,1.445690,1.228385,1.374921,1.292198,1.371379,1.325309,1.362306,1.348841,1.288830,1.350508,1.275925,1.343253,1.278241,1.330827,1.264274,1.290961,1.242774,1.244102,1.222321,1.212539,1.202955,1.194695,1.180196,1.181590,1.137059,1.168767,1.094365,1.164451,1.044741,1.164281,1.014930,1.163964,1.013266,1.120499,1.015576,1.122973,1.015882,0.921073,1.016036,0.820123};$/;"	v
ctrPts2	test/fusion3.cc	/^double ctrPts2[]={1.016036,0.820123,1.016096,0.780123,1.016157,0.740123,1.016252,-0.451436,1.016252,-0.451436,1.016280,-0.491436};$/;"	v
ctrPts3	test/fusion3.cc	/^double ctrPts3[]={0.996280,-0.491450,0.996314,-0.575982,0.996384,-0.745045,0.993883,-0.885439,0.984202,-1.183789,1.003006,-1.274805,1.137848,-1.376951,1.278533,-1.393845,1.380030,-1.391029,1.396554,-1.314309,1.388522,-1.275221,1.464230,-1.264109,1.579747,-1.269291,1.686975,-1.272306,1.772659,-1.273010,1.791923,-1.213667,1.797690,-1.193204,1.903648,-1.128151,2.027706,-1.068902,2.150735,-0.983387,2.233518,-0.798453,2.311373,-0.598166,2.381278,-0.397133,2.390131,-0.221365,2.386160,-0.124820,2.384875,-0.042445,2.384981,0.042215,2.385553,0.126855,2.387960,0.225757,2.385552,0.386796,2.345935,0.526927,2.266178,0.731424,2.168455,0.991192,2.052354,1.081869,1.797203,1.098672,1.642207,1.097144,1.611419,1.109567,1.542371,1.171822,1.458626,1.243422,1.389165,1.307523,1.396699,1.321986,1.363915,1.372893,1.292112,1.372394,1.253441,1.351408,1.259218,1.333175,1.245723,1.299509,1.224933,1.252985,1.206429,1.225063,1.190934,1.211020,1.173123,1.200473,1.133433,1.188578,1.092442,1.183999,1.050234,1.186137,0.994144,1.176988,0.993480,1.116593,0.995524,1.123680,0.995865,0.921289,0.996036,0.820093};$/;"	v
ctrPts4	test/fusion3.cc	/^double ctrPts4[]={0.996036,0.820093,0.996096,0.780093,0.996157,0.740093,0.996252,-0.451450,0.996252,-0.451450,0.996280,-0.491450};$/;"	v
ctrPts5	test/fusion3.cc	/^double ctrPts5[]={0.500000,0.000000,0.500000,-2.200000,0.500000,-3.400000,3.000000,-2.400000,3.000000,-1.200000,3.000000,0.000000};$/;"	v
ctrPts6	test/fusion3.cc	/^double ctrPts6[]={3.000000,0.000000,3.000000,1.200000,3.000000,2.400000,0.500000,3.400000,0.500000,2.200000,0.500000,0.000000};$/;"	v
ctrl	phasta/condense.cc	/^    ph::Input ctrl;$/;"	m	struct:__anon85::GroupCode	file:
ctrlPts	test/fusion3.cc	/^  vector <double> ctrlPts;$/;"	m	class:BSpline	file:
cubic	test/hierarchic.cc	/^static double cubic(int d, apf::Vector3 const& p) {$/;"	f	namespace:__anon20
curl	apf/apfVectorElement.cc	/^void VectorElement::curl(Vector3 const& xi, Vector3& c)$/;"	f	class:apf::VectorElement
current	pumi/pumi_list.h	/^    ListMember* current;$/;"	m	class:ListIterator
curves	ma/maLayerCollapse.h	/^  EntityVector curves[2];$/;"	m	struct:ma::LayerCollapse
cutEntities	phasta/phInterfaceCutter.cc	/^static void cutEntities(apf::Mesh2* m, FieldBCs& fbcs, MaterialMap& mm)$/;"	f	namespace:ph
cutEntity	phasta/phInterfaceCutter.cc	/^static void cutEntity(apf::Mesh2* m, MaterialMap& mm, apf::MeshEntity* e)$/;"	f	namespace:ph
cutInterface	phasta/phInterfaceCutter.cc	/^void cutInterface(apf::Mesh2* m, BCs& bcs)$/;"	f	namespace:ph
cutInterfaceSIM	phasta/phInterfaceCutter.cc	/^void cutInterfaceSIM(apf::Mesh2* m, BCs& bcs)$/;"	f	namespace:ph
cut_trailing_spaces	phasta/phIO.c	/^static void cut_trailing_spaces(char* s)$/;"	f	file:
d	apf_cap/apfCAP.h	/^    int d;$/;"	m	class:apf::MeshCAP
d	apf_sim/apfSIM.h	/^    int d;$/;"	m	class:apf::MeshSIM
d	mds/mds.h	/^  int d;$/;"	m	struct:mds
d	parma/diffMC/parma_centroidSelector.cc	/^      Distance* d;$/;"	m	class:__anon49::DistanceQueue	file:
d	parma/diffMC/parma_shapeSelector.cc	/^    uint d[1];$/;"	m	struct:__anon57::UintArr	file:
d	parma/diffMC/parma_vtxSelector.cc	/^    uint d[1];$/;"	m	struct:__anon59::UintArr	file:
d	parma/extractParmaResults.py	/^  d = len(vtxImbAll) - len(elmImbAll)$/;"	v
d	parma/extractParmaResults.py	/^  d = len(vtxImbAll) - len(iterTimeAll)$/;"	v
d_param	test/fusion.cc	/^double const d_param = 0.0;$/;"	v
data	apf/apfField.cc	/^  apf::NewArray<double> data;$/;"	m	struct:apf::ZeroOp	file:
data	apf/apfField.h	/^    FieldData* data;$/;"	m	class:apf::FieldBase
data	apf/apfHierarchic.cc	/^    apf::NewArray<double> data;$/;"	m	class:apf::Projector	file:
data	apf/apfNumbering.cc	/^    FieldDataOf<T>* data;$/;"	m	class:apf::Globalizer	file:
data	apf/apfVtk.cc	/^    FieldDataOf<T>* data;$/;"	m	class:apf::WriteIPField	file:
data	gmi/agm.c	/^  char* data[AGM_OBJ_TYPES][MAX_SUBTYPES];$/;"	m	struct:agm_tag	file:
data	gmi/gmi_analytic.c	/^  struct agm_tag* data;$/;"	m	struct:gmi_analytic	typeref:struct:gmi_analytic::agm_tag	file:
data	mds/mds_net.h	/^  struct mds_copies** data[MDS_TYPES];$/;"	m	struct:mds_net	typeref:struct:mds_net::mds_copies
data	mds/mds_tag.h	/^  char* data[MDS_TYPES];$/;"	m	struct:mds_tag
data	pumi/GenTag.h	/^      void* data;$/;"	m	struct:Taggable::Entry
dataArray	apf/apfArrayData.cc	/^    T* dataArray;$/;"	m	class:apf::ArrayDataOf	file:
dataIndex	apf/apfVtk.cc	/^    int dataIndex;$/;"	m	class:apf::WriteIPField	file:
dataToEncode	apf/apfVtk.cc	/^    T* dataToEncode;$/;"	m	class:apf::WriteIPField	file:
data_of	gmi/gmi_analytic.c	/^static void** data_of(struct gmi_analytic* m, struct agm_ent e)$/;"	f	file:
dbgLvl	zoltan/apfZoltanCallbacks.h	/^    int dbgLvl;$/;"	m	class:apf::ZoltanData
dcAvg	parma/extractParmaResults.py	/^dcAvg = metric("disconnectedAvg")$/;"	v
dcCompNbor	parma/diffMC/parma_dcpart.h	/^      std::vector<unsigned> dcCompNbor;$/;"	m	class:dcPart
dcCompSz	parma/diffMC/parma_dcpart.h	/^      std::vector<unsigned> dcCompSz;$/;"	m	class:dcPart
dcComponents	parma/diffMC/parma_components.cc	/^  dcComponents::dcComponents(apf::Mesh* m, unsigned verbose)$/;"	f	class:parma::dcComponents
dcComponents	parma/diffMC/parma_dcpart.h	/^  class dcComponents {$/;"	c	namespace:parma
dcMax	parma/extractParmaResults.py	/^dcMax = metric("disconnectedMax")$/;"	v
dcPart	parma/diffMC/parma_dcpart.cc	/^dcPart::dcPart(apf::Mesh*& mesh, unsigned v)$/;"	f	class:dcPart
dcPart	parma/diffMC/parma_dcpart.h	/^      dcPart() {}$/;"	f	class:dcPart
dcPart	parma/diffMC/parma_dcpart.h	/^class dcPart {$/;"	c
dcPartFixer	parma/diffMC/parma_dcpart.h	/^class dcPartFixer { $/;"	c
dcPartFixer	parma/diffMC/parma_dcpartFixer.cc	/^dcPartFixer::dcPartFixer(apf::Mesh* mesh, unsigned verbose) $/;"	f	class:dcPartFixer
deallocate	apf_cap/apfCAP.cc	/^    virtual void deallocate(void* p)$/;"	f	class:apf::DoubleTagCAP
deallocate	apf_cap/apfCAP.cc	/^    virtual void deallocate(void* p)$/;"	f	class:apf::IntTagCAP
deallocate	apf_sim/apfSIM.cc	/^    virtual void deallocate(void* p)$/;"	f	class:apf::DoubleTagSIM
deallocate	apf_sim/apfSIM.cc	/^    virtual void deallocate(void* p)$/;"	f	class:apf::IntTagSIM
deallocate	apf_sim/apfSIM.cc	/^    virtual void deallocate(void* p)$/;"	f	class:apf::LongTagSIM
deallocate	can/canNewArray.h	/^    void deallocate()$/;"	f	class:can::NewArray
debug	parma/diffMC/parma_commons.cc	/^void parmaCommons::debug(bool isActive, const char* fmt,...) {$/;"	f	class:parmaCommons
debug	zoltan/apfZoltanMesh.h	/^    bool debug;$/;"	m	class:apf::ZoltanMesh
debugFolder	ma/maInput.h	/^    const char* debugFolder;$/;"	m	class:ma::Input
declareField	stk/apfSTK.cc	/^void declareField(Field* f, StkMetaData* md)$/;"	f	namespace:apf
declarePart	stk/apfMeshSTK.cc	/^static void declarePart(StkModel* model,$/;"	f	namespace:apf
decomposePLU	crv/crvMath.cc	/^static void decomposePLU(int n, mth::Matrix<double> const& a,$/;"	f	namespace:crv
decomposeQR	mth/mthQR.cc	/^unsigned decomposeQR($/;"	f	namespace:mth
decrease_dimension	mds/mds.c	/^static void decrease_dimension(struct mds* m)$/;"	f	file:
define_output_fields	stk/apfExodusOutput.cc	/^static void define_output_fields(stk::io::StkMeshIoBroker& mesh_data,$/;"	f	namespace:apf
defrag	ma/maExtrude.cc	/^void defrag(Mesh* m) {$/;"	f	namespace:ma::__anon28
degree	apf_cap/apfCAP.cc	/^int const degree[Mesh::TYPES][4] =$/;"	m	namespace:apf	file:
degree	mth/mthAD.h	/^    enum { degree = N };$/;"	e	enum:mth::AD::__anon31
degreesOfFreedom	phasta/phConstraint.cc	/^  int degreesOfFreedom;$/;"	m	struct:ph::Constraint	file:
del	pumi/mPartEntityContainer.cc	/^void mPartEntityContainer::del(int d, gEntity* e)$/;"	f	class:mPartEntityContainer
del	pumi/pumi.h	/^  void del(int d, gEntity *ge) {allEntities.del(d, ge); } $/;"	f	class:gModel
deleteAdjacency	apf_cap/apfCAP.cc	/^void MeshCAP::deleteAdjacency(int from_dim, int to_dim)$/;"	f	class:apf::MeshCAP
deleteAdjacency	apf_sim/apfSIM.cc	/^void MeshSIM::deleteAdjacency(int from_dim, int to_dim)$/;"	f	class:apf::MeshSIM
deleteAdjacency	mds/apfMDS.cc	/^    void deleteAdjacency(int from_dim, int to_dim)$/;"	f	class:apf::MeshMDS
deleteCallback	ma/maAdapt.h	/^    DeleteCallback* deleteCallback;$/;"	m	class:ma::Adapt
deleteDoubleCB	apf_sim/apfSIM.cc	/^    static int deleteDoubleCB($/;"	f	class:apf::DoubleTagSIM
deleteGhost	apf_cap/apfCAP.h	/^    void deleteGhost(MeshEntity*) {}$/;"	f	class:apf::MeshCAP
deleteGhost	apf_sim/apfSIM.h	/^    void deleteGhost(MeshEntity*) {}$/;"	f	class:apf::MeshSIM
deleteGhost	mds/apfMDS.cc	/^    void deleteGhost(MeshEntity* e)$/;"	f	class:apf::MeshMDS
deleteIntCB	apf_sim/apfSIM.cc	/^    static int deleteIntCB($/;"	f	class:apf::IntTagSIM
deleteLongCB	apf_sim/apfSIM.cc	/^    static int deleteLongCB($/;"	f	class:apf::LongTagSIM
deleteOldEntities	apf/apfMigrate.cc	/^void deleteOldEntities($/;"	f	namespace:apf
deletePM	mds/apfPM.cc	/^void deletePM(PM& ps)$/;"	f	namespace:apf
deletePMent	mds/apfPM.cc	/^void deletePMent(PM& ps, PME* p)$/;"	f	namespace:apf
deleteTagData	pumi/GenTag.cc	/^void Taggable::deleteTagData(TagHandle* tag)$/;"	f	class:Taggable
deleted	pcu/pcu_aa.c	/^  pcu_aa_node* deleted;$/;"	m	struct:remove_vars	file:
deprecated	phasta/phInput.cc	/^static bool deprecated(stringset& old, std::string const& name)$/;"	f	namespace:ph
depth	parma/diffMC/parma_components.cc	/^    unsigned depth;$/;"	m	struct:__anon65::Comp	file:
depth	parma/diffMC/parma_components.h	/^      unsigned* depth;$/;"	m	class:parma::dcComponents::Components
depth	parma/diffMC/parma_ghostMPASWeights.cc	/^      apf::MeshTag* depth;$/;"	m	class:parma::GhostElementFinder	file:
depth	parma/diffMC/parma_ghostWeights.cc	/^      apf::MeshTag* depth;$/;"	m	class:parma::VtxGhostFinder	file:
deref	apf_cap/apfCAP.cc	/^MeshEntity* MeshCAP::deref(MeshIterator* it)$/;"	f	class:apf::MeshCAP
deref	apf_sim/apfSIM.h	/^    MeshEntity * deref(MeshIterator*) { return NULL; }$/;"	f	class:apf::MeshSIM
deref	mds/apfMDS.cc	/^    MeshEntity* deref(MeshIterator* it)$/;"	f	class:apf::MeshMDS
derive2DMdlFromManifold	mds/apfMDS.cc	/^void derive2DMdlFromManifold(Mesh2* mesh, bool* isModelVert,$/;"	f	namespace:apf
deriveMdlFromManifold	mds/apfMDS.cc	/^void deriveMdlFromManifold(Mesh2* mesh, bool* isModelVert,$/;"	f	namespace:apf
deriveMdsModel	mds/apfMDS.cc	/^void deriveMdsModel(Mesh2* in)$/;"	f	namespace:apf
describeArray	apf/apfVtk.cc	/^static void describeArray($/;"	f	namespace:apf
describeArray	crv/crvVtk.cc	/^static void describeArray($/;"	f	namespace:crv
desiredTotNumParts	test/sim_part.cc	/^int desiredTotNumParts;  \/\/ Desired total no. of partitions$/;"	v
destroy	apf/apfMesh2.h	/^    void destroy(MeshEntity* e)$/;"	f	class:apf::Mesh2
destroy	gmi/gmi.h	/^  void (*destroy)(struct gmi_model* m);$/;"	m	struct:gmi_model_ops
destroy	gmi_cap/gmi_cap.cc	/^static void destroy(gmi_model* m)$/;"	f	file:
destroy	gmi_sim/gmi_sim.cc	/^static void destroy(gmi_model* m)$/;"	f	file:
destroy	parma/diffMC/parma_shapeSelector.cc	/^  void destroy(UintArr* u) {$/;"	f	namespace:__anon57
destroy	parma/diffMC/parma_vtxSelector.cc	/^  void destroy(UintArr* u) {$/;"	f	namespace:__anon59
destroyElement	apf/apf.cc	/^void destroyElement(Element* e)$/;"	f	namespace:apf
destroyElement	ma/maAdapt.cc	/^void destroyElement(Adapt* a, Entity* e)$/;"	f	namespace:ma
destroyField	apf/apf.cc	/^void destroyField(Field* f)$/;"	f	namespace:apf
destroyGRStream	phasta/phstream.cc	/^void destroyGRStream(GRStream* grs) {$/;"	f
destroyGhostWeights	parma/diffMC/parma_ghostWeights.cc	/^  void destroyGhostWeights(GhostWeights* gw) {$/;"	f	namespace:parma
destroyGlobalNumbering	apf/apfNumbering.cc	/^void destroyGlobalNumbering(GlobalNumbering* n)$/;"	f	namespace:apf
destroyIfExists	phasta/phRestart.cc	/^static void destroyIfExists(apf::Mesh* m, const char* name)$/;"	f	namespace:ph
destroyKnapsack	parma/diffMC/zeroOneKnapsack.c	/^void destroyKnapsack(Knapsack knapsack) {$/;"	f
destroyMesh	apf/apf.cc	/^void destroyMesh(Mesh* m)$/;"	f	namespace:apf
destroyMeshElement	apf/apf.cc	/^void destroyMeshElement(MeshElement* e)$/;"	f	namespace:apf
destroyNative	apf_cap/apfCAP.cc	/^void MeshCAP::destroyNative()$/;"	f	class:apf::MeshCAP
destroyNative	apf_sim/apfSIM.cc	/^void MeshSIM::destroyNative()$/;"	f	class:apf::MeshSIM
destroyNative	mds/apfMDS.cc	/^    void destroyNative()$/;"	f	class:apf::MeshMDS
destroyNewElements	ma/maCollapse.cc	/^void Collapse::destroyNewElements()$/;"	f	class:ma::Collapse
destroyNumbering	apf/apfNumbering.cc	/^void destroyNumbering(Numbering* n)$/;"	f	namespace:apf
destroyOldElements	ma/maCollapse.cc	/^void Collapse::destroyOldElements()$/;"	f	class:ma::Collapse
destroyOldElements	ma/maFaceSplit.cc	/^void FaceSplit::destroyOldElements()$/;"	f	class:ma::FaceSplit
destroyOldElements	ma/maLayerCollapse.cc	/^void LayerCollapse::destroyOldElements()$/;"	f	class:ma::LayerCollapse
destroyOldElements	ma/maMatchedCollapse.cc	/^void MatchedCollapse::destroyOldElements()$/;"	f	class:ma::MatchedCollapse
destroyOldElements	ma/maSplits.cc	/^void Splits::destroyOldElements()$/;"	f	class:ma::Splits
destroyOldFaces	ma/maEdgeSwap.cc	/^    void destroyOldFaces()$/;"	f	class:ma::EdgeSwap2D
destroyOldTets	ma/maEdgeSwap.cc	/^    void destroyOldTets()$/;"	f	class:ma::EdgeSwap3D
destroyRStream	phasta/phstream.cc	/^void destroyRStream(RStream* rs) {$/;"	f
destroySplitElements	ma/maRefine.cc	/^void destroySplitElements(Refine* r)$/;"	f	namespace:ma
destroyTag	apf_cap/apfCAP.cc	/^void MeshCAP::destroyTag(MeshTag* tag)$/;"	f	class:apf::MeshCAP
destroyTag	apf_sim/apfSIM.cc	/^void MeshSIM::destroyTag(MeshTag* tag)$/;"	f	class:apf::MeshSIM
destroyTag	mds/apfMDS.cc	/^    void destroyTag(MeshTag* t)$/;"	f	class:apf::MeshMDS
destroyTags	apf/apfTagData.cc	/^void TagData::destroyTags()$/;"	f	class:apf::TagData
destroy_	apf_cap/apfCAP.cc	/^void MeshCAP::destroy_(MeshEntity* e)$/;"	f	class:apf::MeshCAP
destroy_	apf_sim/apfSIM.h	/^    void destroy_(MeshEntity* ) {}$/;"	f	class:apf::MeshSIM
destroy_	mds/apfMDS.cc	/^    void destroy_(MeshEntity* e)$/;"	f	class:apf::MeshMDS
destruct	apf/apfConstruct.cc	/^void destruct(Mesh2* m, int*& conn, int& nelem, int &etype)$/;"	f	namespace:apf
destructSimxMesh	test/runSimxAnisoAdapt.cc	/^void destructSimxMesh($/;"	f
det2x2	mth/mth_def.h	/^T det2x2(Tensor<T> const& a)$/;"	f	namespace:mth
det3x3	mth/mth_def.h	/^T det3x3(Tensor<T> const& a)$/;"	f	namespace:mth
detachAndWriteField	phasta/phRestart.cc	/^void detachAndWriteField($/;"	f	namespace:ph
detachAndWriteRandField	phasta/phRestart.cc	/^void detachAndWriteRandField($/;"	f	namespace:ph
detachAndWriteSolution	phasta/phRestart.cc	/^void detachAndWriteSolution(Input& in, Output& out, apf::Mesh* m, std::string path)$/;"	f	namespace:ph
detachField	phasta/phRestart.cc	/^void detachField($/;"	f	namespace:ph
detachTags	apf/apfTagData.cc	/^void TagData::detachTags()$/;"	f	class:apf::TagData
detachVtxTag	test/icesheet.cc	/^void detachVtxTag(apf::Mesh2* mesh, apf::MeshTag* t) {$/;"	f
determinant	mth/mth_def.h	/^T determinant(Matrix<T,2,2> const& a)$/;"	f	namespace:mth
determinant	mth/mth_def.h	/^T determinant(Matrix<T,3,3> const& a)$/;"	f	namespace:mth
determinant	mth/mth_def.h	/^T determinant(Tensor<T> const& a)$/;"	f	namespace:mth
determinePointsPerElement	spr/sprRecoverField.cc	/^static int determinePointsPerElement(apf::Field* f)$/;"	f	namespace:spr
deviatoric	mth/mth_def.h	/^void deviatoric(Tensor<T> const& a, Tensor<T>& r)$/;"	f	namespace:mth
didAnything	ma/maSnap.cc	/^    bool didAnything;$/;"	m	class:ma::SnapAll	file:
didAnything	ma/maSnap.cc	/^    bool didAnything;$/;"	m	class:ma::SnapMatched	file:
didAnything	ma/maSnap_mohara.cc	/^    bool didAnything;$/;"	m	class:ma::SnapAll	file:
didAnything	ma/maSnap_mohara.cc	/^    bool didAnything;$/;"	m	class:ma::SnapMatched	file:
didBreakGeomConsistency	ma/maEdgeSwap.cc	/^    bool didBreakGeomConsistency()$/;"	f	class:ma::EdgeSwap2D
didImproveQuality	ma/maEdgeSwap.cc	/^    bool didImproveQuality()$/;"	f	class:ma::EdgeSwap2D
didInvert	ma/maSnapper.cc	/^static bool didInvert(Mesh* m, Vector& oldNormal, Entity* tri)$/;"	f	namespace:ma
diff	mth/mthAD.h	/^    void diff(unsigned int i, unsigned int n)$/;"	f	class:mth::AD
diff	mth/mthAD.h	/^    void diff(unsigned int i, unsigned int n=0)$/;"	f	class:mth::AD
diffnorm	test/eigen_test.cc	/^static double diffnorm(apf::Vector<3> const& a, apf::Vector<3> const& b)$/;"	f	file:
diffnorm	test/eigen_test.cc	/^static double diffnorm(double a, double b)$/;"	f	file:
diffnormEigenVec	test/eigen_test.cc	/^static double diffnormEigenVec(apf::Vector<3> const& a, apf::Vector<3> const& b)$/;"	f	file:
diffnormEigenVecs	test/eigen_test.cc	/^static double diffnormEigenVecs(apf::Matrix3x3 const& a, apf::Matrix3x3 const& b)$/;"	f	file:
dijkstra	parma/diffMC/parma_dijkstra.cc	/^  void dijkstra(apf::Mesh* m, DijkstraContains* c,$/;"	f	namespace:parma
dijkstra_	parma/diffMC/parma_dijkstra.cc	/^  void dijkstra_(apf::Mesh* m, parma::DijkstraContains* c,$/;"	f	namespace:__anon70
dim	gmi/gmi.h	/^  int (*dim)(struct gmi_model* m, struct gmi_ent* e);$/;"	m	struct:gmi_model_ops
dim	gmi_sim/gmi_sim.cc	/^  int dim;$/;"	m	struct:sim_iter	file:
dim	mds/apfBox.h	/^  int dim;$/;"	m	struct:apf::BoxBuilder
dim	mds/apfBox.h	/^  struct { int dim; int tag; } modelTable[27];$/;"	m	struct:apf::BoxBuilder::__anon95
dim	mth/mthTensor.h	/^    unsigned dim() const {return this->columns;}$/;"	f	class:mth::Tensor
dim	phasta/phBC.h	/^  int dim;$/;"	m	struct:ph::BC
dim	pumi/GenIterator.h	/^    int dim;$/;"	m	class:GenIterator
dim	sam/samElementCount.cc	/^  int dim;$/;"	m	class:sam::TotalMetricVolumeIso	file:
dim	spr/sprRecoverField.cc	/^  int dim;$/;"	m	struct:spr::Recovery	file:
dimName	apf/apfMesh.cc	/^char const* const dimName[4] = {$/;"	m	namespace:apf	file:
dimension	apf/apfIPShape.cc	/^    int dimension;$/;"	m	class:apf::IPBase	file:
dimension	ma/maQuality.cc	/^    int dimension;$/;"	m	class:ma::FixedMetricIntegrator	file:
dimension	ma/maSize.cc	/^    int dimension;$/;"	m	class:ma::SizeFieldIntegrator	file:
dir	ma/maSnapper.h	/^  Vector dir;$/;"	m	struct:ma::Ray
dir	test/refine2x.cc	/^    int dir;$/;"	m	class:AnisotropicX	file:
direction	apf/apfGeometry.h	/^  Vector3 direction;$/;"	m	struct:apf::Line
direction	phasta/phAttrib.cc	/^  pAttributeTensor1 direction;$/;"	m	struct:CompBC	file:
disable_surface	test/generate.cc	/^int disable_surface = 0;$/;"	m	namespace:__anon19	file:
disable_volume	test/generate.cc	/^int disable_volume = 0;$/;"	m	namespace:__anon19	file:
disambiguateBaseTri	ma/maLayerRefine.cc	/^static void disambiguateBaseTri(Adapt* a, Entity* t)$/;"	f	namespace:ma
disambiguateBaseTris	ma/maLayerRefine.cc	/^static void disambiguateBaseTris(Adapt* a)$/;"	f	namespace:ma
disambiguateLayerTris	ma/maLayerRefine.cc	/^static void disambiguateLayerTris(Adapt* a)$/;"	f	namespace:ma
disconnected	parma/diffMC/parma_vtxSelector.cc	/^  bool disconnected(apf::Mesh* m, apf::Migration* plan, apf::Up& cavity) {$/;"	f	namespace:__anon59
disownMdsModel	mds/apfMDS.cc	/^void disownMdsModel(Mesh2* in)$/;"	f	namespace:apf
displace	dsp/dsp.cc	/^void displace(apf::Mesh2* m, apf::Field* df,$/;"	f	namespace:dsp
displaceMesh	apf/apfMesh2.cc	/^void displaceMesh(Mesh2* m, Field* d, double factor)$/;"	f	namespace:apf
displacementMigration	phasta/phInput.h	/^    int displacementMigration;$/;"	m	class:ph::Input
dist	parma/diffMC/parma_vtxSelector.h	/^      apf::MeshTag* dist;$/;"	m	class:parma::VtxSelector
distUp	parma/extractParmaResults.py	/^distUp = metric("distanceUpdate")$/;"	v
distUpAll	parma/extractParmaResults.py	/^distUpAll = []$/;"	v
distance	apf/apfGeometry.cc	/^double Plane::distance(Vector3 const& a) const$/;"	f	class:apf::Plane
distanceTagName	parma/diffMC/parma_graphDist.cc	/^  const char* distanceTagName() {$/;"	f	namespace:__anon74
distr_getAffected	pumi/pumi_mesh.cc	/^static void distr_getAffected (pMesh m, Distribution* plan, EntityVector affected[4])$/;"	f	file:
distr_makeResidence	pumi/pumi_mesh.cc	/^static Parts distr_makeResidence(Parts& parts)$/;"	f	file:
distr_updateResidences	pumi/pumi_mesh.cc	/^static void distr_updateResidences(pMesh m,$/;"	f	file:
distribute	pumi/pumi_mesh.cc	/^void distribute(pMesh m, Distribution* plan)$/;"	f
div	apf/apfVectorElement.cc	/^double VectorElement::div(Vector3 const& xi)$/;"	f	class:apf::VectorElement
do_distr	test/pumi.cc	/^int do_distr=0;$/;"	v
do_off_part_bridge	pumi/pumi_ghost.cc	/^void do_off_part_bridge(pMesh m, int brg_dim, int ghost_dim, int num_layer, $/;"	f
done	pcu/pcu_mpi.h	/^  bool (*done)(pcu_message* m);$/;"	m	struct:__anon34
done_sending_peers	pcu/pcu_msg.c	/^static bool done_sending_peers(pcu_aa_tree t)$/;"	f	file:
doubleSplitCollapse	crv/crvShapeFixer.h	/^    ma::DoubleSplitCollapse doubleSplitCollapse;$/;"	m	class:crv::CrvEdgeEdgeFixer
doubleSplitCollapse	ma/maShape.cc	/^    DoubleSplitCollapse doubleSplitCollapse;$/;"	m	class:ma::EdgeEdgeFixer	file:
down	mds/mds.c	/^struct down {$/;"	s	file:
down	mds/mds.h	/^  mds_id* down[4][MDS_TYPES];$/;"	m	struct:mds
down_degree	mds/mds_smb.c	/^static int down_degree(int t)$/;"	f	file:
downs_to_copies	mds/mds_apf.c	/^static void downs_to_copies($/;"	f	file:
downs_to_copy	mds/mds_apf.c	/^static void downs_to_copy(struct mds_set* s,$/;"	f	file:
dq	parma/diffMC/parma_bdryVtx.cc	/^      parma::DistanceQueue<parma::Greater>* dq;$/;"	m	class:__anon54::DistItr	file:
dsp	dsp/dsp.cc	/^namespace dsp {$/;"	n	file:
dsp	dsp/dsp.h	/^namespace dsp {$/;"	n
dsp	dsp/dspAdapters.cc	/^namespace dsp {$/;"	n	file:
dsp	dsp/dspAdapters.h	/^namespace dsp {$/;"	n
dsp	dsp/dspGraphDistance.cc	/^namespace dsp {$/;"	n	file:
dsp	dsp/dspGraphDistance.h	/^namespace dsp {$/;"	n
dsp	dsp/dspSmoothers.cc	/^namespace dsp {$/;"	n	file:
dsp	dsp/dspSmoothers.h	/^namespace dsp {$/;"	n
dtor_order	pcu/pcu_order.c	/^static void dtor_order(pcu_order o)$/;"	f	file:
dtwo	parma/diffMC/parma_elmLtVtxEdgeSelector.cc	/^    dtwo()$/;"	f	struct:__anon64::dtwo
dtwo	parma/diffMC/parma_elmLtVtxEdgeSelector.cc	/^    dtwo(double x, double y)$/;"	f	struct:__anon64::dtwo
dtwo	parma/diffMC/parma_elmLtVtxEdgeSelector.cc	/^  struct dtwo {$/;"	s	namespace:__anon64	file:
dug	ma/maSnapper.h	/^    bool dug;$/;"	m	class:ma::Snapper
dumpMeshWithFlag	ma/maDBG.cc	/^void dumpMeshWithFlag(ma::Adapt* a,$/;"	f	namespace:ma_dbg
dumpMeshWithQualities	ma/maDBG.cc	/^void dumpMeshWithQualities(ma::Adapt* a,$/;"	f	namespace:ma_dbg
dwalMigration	phasta/phInput.h	/^    int dwalMigration;$/;"	m	class:ph::Input
dx	mth/mthAD.h	/^    T& dx(unsigned int i) {return dx_[i];}$/;"	f	class:mth::AD
dx	mth/mthAD.h	/^    T& dx(unsigned int i)$/;"	f	class:mth::AD
dx	mth/mthAD.h	/^    const T dx(unsigned int i) const {$/;"	f	class:mth::AD
dx	mth/mthAD.h	/^    const T& dx(unsigned int i) const {return dx_[i];}$/;"	f	class:mth::AD
dx_	mth/mthAD.h	/^    T dx_[N];$/;"	m	class:mth::AD
dx_	mth/mthAD.h	/^    can::Array<T> dx_;$/;"	m	class:mth::AD
e	apf/apfCavityOp.h	/^    struct PullRequest { MeshEntity* e; int to; };$/;"	m	struct:apf::CavityOp::PullRequest
e	apf/apfGradientByVolume.cc	/^    Element* e;$/;"	m	class:apf::GradientIntegrator	file:
e	apf/apfMesh.h	/^  MeshEntity* e[400];$/;"	m	struct:apf::Up
e	gmi/gmi.h	/^  struct gmi_ent* e[1];$/;"	m	struct:gmi_set	typeref:struct:gmi_set::gmi_ent
e	gmi_sim/gmi_sim.cc	/^    GEIter e;$/;"	m	union:sim_iter::__anon103	file:
e	ma/maMatchedCollapse.h	/^  Entity* e;$/;"	m	struct:ma::Rebuild
e	mds/mds.c	/^  mds_id* e;$/;"	m	struct:down	file:
e	mds/mds.h	/^  mds_id e[MDS_SET_MAX];$/;"	m	struct:mds_set
e	mds/mds_net.h	/^  mds_id e;$/;"	m	struct:mds_copy
e	mds/mds_order.c	/^  mds_id* e;$/;"	m	struct:queue	file:
e	pumi/mPartEntityContainer.h	/^  gmi_ent* e;$/;"	m	class:gEntity
e0	mds/mds.c	/^static int const e0[] = {MDS_VERTEX,MDS_VERTEX};$/;"	v	file:
e_param	test/fusion.cc	/^double const e_param = 1.3;$/;"	v
echoRemotes	apf/apfMigrate.cc	/^static void echoRemotes($/;"	f	namespace:apf
edge	ma/maCollapse.h	/^    Entity* edge; $/;"	m	class:ma::Collapse
edge	ma/maEdgeSwap.cc	/^    Entity* edge;$/;"	m	class:ma::EdgeSwap2D	file:
edge	ma/maEdgeSwap.cc	/^    Entity* edge;$/;"	m	class:ma::EdgeSwap3D	file:
edge	ma/maEdgeSwap.cc	/^    Entity* edge;$/;"	m	class:ma::SwapLoop	file:
edge	ma/maShape.cc	/^    Entity* edge;$/;"	m	class:ma::LargeAngleTriFixer	file:
edge	ma/maShape.cc	/^    Entity* edge;$/;"	m	class:ma::QualityImprover2D	file:
edge	ma/maShortEdgeRemover.h	/^    Entity* edge;$/;"	m	class:ma::ShortEdgeRemover
edge	test/shapefun2.cc	/^static apf::Vector3 const edge[2] = {$/;"	m	class:test::apf	file:
edge0	test/bezierElevation.cc	/^void edge0(double const p[2], double x[3], void*)$/;"	f
edge0	test/bezierMesh.cc	/^void edge0(double const p[2], double x[3], void*)$/;"	f
edge0	test/bezierRefine.cc	/^void edge0(double const p[2], double x[3], void*)$/;"	f
edge0	test/bezierSubdivision.cc	/^void edge0(double const p[2], double x[3], void*)$/;"	f
edge0	test/bezierValidity.cc	/^void edge0(double const p[2], double x[3], void*)$/;"	f
edge1	test/bezierElevation.cc	/^void edge1(double const p[2], double x[3], void*)$/;"	f
edge1	test/bezierMesh.cc	/^void edge1(double const p[2], double x[3], void*)$/;"	f
edge1	test/bezierRefine.cc	/^void edge1(double const p[2], double x[3], void*)$/;"	f
edge1	test/bezierSubdivision.cc	/^void edge1(double const p[2], double x[3], void*)$/;"	f
edge1	test/bezierValidity.cc	/^void edge1(double const p[2], double x[3], void*)$/;"	f
edge2	test/bezierElevation.cc	/^void edge2(double const p[2], double x[3], void*)$/;"	f
edge2	test/bezierMesh.cc	/^void edge2(double const p[2], double x[3], void*)$/;"	f
edge2	test/bezierRefine.cc	/^void edge2(double const p[2], double x[3], void*)$/;"	f
edge2	test/bezierSubdivision.cc	/^void edge2(double const p[2], double x[3], void*)$/;"	f
edge2	test/bezierValidity.cc	/^void edge2(double const p[2], double x[3], void*)$/;"	f
edge3	test/bezierMesh.cc	/^void edge3(double const p[2], double x[3], void*)$/;"	f
edge3	test/bezierRefine.cc	/^void edge3(double const p[2], double x[3], void*)$/;"	f
edge3	test/bezierValidity.cc	/^void edge3(double const p[2], double x[3], void*)$/;"	f
edgeEdgeFixer	crv/crvShapeFixer.h	/^    CrvEdgeEdgeFixer edgeEdgeFixer;$/;"	m	class:crv::CrvLargeAngleTetFixer
edgeEdgeFixer	ma/maShape.cc	/^    EdgeEdgeFixer edgeEdgeFixer;$/;"	m	class:ma::LargeAngleTetFixer	file:
edgeExists	ma/maMesh.cc	/^bool edgeExists(Mesh* m, Entity* v0, Entity* v1)$/;"	f	namespace:ma
edgeFaces	crv/crvTables.h	/^static int const edgeFaces[6][2] = {{1,0},{2,0},{3,0},{3,1},{1,2},{2,3}};$/;"	m	namespace:crv
edgeFunction	test/bezierElevation.cc	/^void edgeFunction(double const p[2], double x[3], void*)$/;"	f
edgeFunction	test/bezierSubdivision.cc	/^void edgeFunction(double const p[2], double x[3], void*)$/;"	f
edgeFunction	test/fusion.cc	/^void edgeFunction(double const p[2], double x[3], void*)$/;"	f
edgeFunction	test/fusion3.cc	/^void edgeFunction(double const p[2], double *xyz, void*  data)$/;"	f
edgeSwap	crv/crvShape.cc	/^  ma::EdgeSwap* edgeSwap;$/;"	m	class:crv::EdgeSwapper	file:
edgeSwap	crv/crvShapeFixer.h	/^    ma::EdgeSwap* edgeSwap;$/;"	m	class:crv::CrvEdgeEdgeFixer
edgeSwap	crv/crvShapeFixer.h	/^    ma::EdgeSwap* edgeSwap;$/;"	m	class:crv::CrvFaceVertFixer
edgeSwap	ma/maShape.cc	/^    EdgeSwap* edgeSwap;$/;"	m	class:ma::EdgeEdgeFixer	file:
edgeSwap	ma/maShape.cc	/^    EdgeSwap* edgeSwap;$/;"	m	class:ma::FaceVertFixer	file:
edgeSwap	ma/maShape.cc	/^    EdgeSwap* edgeSwap;$/;"	m	class:ma::FixBySwap	file:
edgeSwap	ma/maShape.cc	/^    EdgeSwap* edgeSwap;$/;"	m	class:ma::LargeAngleTriFixer	file:
edgeSwap	ma/maShape.cc	/^    EdgeSwap* edgeSwap;$/;"	m	class:ma::QualityImprover2D	file:
edge_code_match	ma/maTables.cc	/^CodeMatch const edge_code_match[2] =$/;"	m	namespace:ma	file:
edge_dim	apf/apfMIS.h	/^    const int edge_dim;$/;"	m	class:apf::MIS
edge_edge	ma/sliverCodeMatch.cc	/^  edge_edge=0,$/;"	e	enum:__anon30	file:
edge_edge_code_count	ma/maTables.h	/^  edge_edge_code_count = 2,$/;"	e	enum:ma::__anon27
edge_edge_codes	ma/maTables.cc	/^int const edge_edge_codes[edge_edge_code_count] =$/;"	m	namespace:ma	file:
edge_edge_xi	crv/crvTables.cc	/^static apf::Vector3 const edge_edge_xi[1] = {$/;"	m	class:crv::apf	file:
edge_regions	gmi_sim/gmi_sim.cc	/^static gmi_set* edge_regions(pGEdge e)$/;"	f	file:
edge_templates	ma/maTemplates.cc	/^SplitFunction edge_templates[edge_edge_code_count] =$/;"	m	namespace:ma	file:
edge_vert_xi	apf/apfBoundaryToElementXi.cc	/^static Vector3 const edge_vert_xi[2] = {$/;"	m	namespace:apf	file:
edge_vert_xi	crv/crvTables.cc	/^static apf::Vector3 const edge_vert_xi[2] = {$/;"	m	class:crv::apf	file:
edge_verts	ma/maEdgeSwap.cc	/^    Entity* edge_verts[2];$/;"	m	class:ma::SwapLoop	file:
edge_verts	test/fusion3.cc	/^int const edge_verts[numGE][2] = {$/;"	v
edges	crv/crvShape.cc	/^  ma::Entity* edges[6];$/;"	m	class:crv::EdgeReshaper	file:
edges	crv/crvShape.cc	/^  ma::Entity* edges[6];$/;"	m	class:crv::EdgeSwapper	file:
edges	crv/crvShapeFixer.h	/^    apf::MeshEntity* edges[2];$/;"	m	class:crv::CrvEdgeEdgeFixer
edges	crv/crvShapeFixer.h	/^    apf::MeshEntity* edges[3];$/;"	m	class:crv::CrvFaceVertFixer
edges	ma/maLayerCollapse.h	/^  EntityVector edges;$/;"	m	struct:ma::LayerCollapse
edges	ma/maShape.cc	/^    Entity* edges[2];$/;"	m	class:ma::EdgeEdgeFixer	file:
edges	ma/maShape.cc	/^    Entity* edges[3];$/;"	m	class:ma::FaceVertFixer	file:
edges	ma/maShape.cc	/^    Entity* edges[3];$/;"	m	class:ma::FixBySwap	file:
edges	ma/maVertRemover.h	/^    apf::Up edges;$/;"	m	class:ma::VertRemover
edgew	test/ugridptnstats.cc	/^const double edgew = 1.0;$/;"	v
eigen	apf/apfMatrix.cc	/^int eigen(Matrix3x3 const& A,$/;"	f	namespace:apf
eigenQR	mth/mthQR.cc	/^bool eigenQR(Matrix<T,M,M> const& a,$/;"	f	namespace:mth
eiter	apf_sim/apfSIM.h	/^    EIter eiter;$/;"	m	class:apf::MeshSIM
elem	apf/apfIPShape.cc	/^    Element elem[Mesh::TYPES];$/;"	m	class:apf::VoronoiShape	file:
elem	ma/maQuality.cc	/^    apf::Element* elem;$/;"	m	class:ma::FixedMetricIntegrator	file:
elem_edge_xi	crv/crvTables.cc	/^apf::Vector3 const* const elem_edge_xi[apf::Mesh::TYPES] = {$/;"	m	class:crv::apf	file:
elem_size	spr/sprEstimateTargetError.cc	/^  apf::Field* elem_size;$/;"	m	struct:spr::target::Estimation	file:
elem_vert_xi	apf/apfBoundaryToElementXi.cc	/^static Vector3 const* const elem_vert_xi[Mesh::TYPES] = {$/;"	m	namespace:apf	file:
elem_vert_xi	crv/crvTables.cc	/^apf::Vector3 const* const elem_vert_xi[apf::Mesh::TYPES] = {$/;"	m	class:crv::apf	file:
element	crv/crvShapeFixer.h	/^    apf::MeshEntity* element;$/;"	m	class:crv::CrvShortEdgeFixer
element	ma/maShape.cc	/^    Entity* element;$/;"	m	class:ma::ShortEdgeFixer	file:
element	sam/samElementCount.cc	/^  apf::Element* element;$/;"	m	class:sam::TotalMetricVolumeIso	file:
element	spr/sprEstimateError.cc	/^    apf::Element* element;$/;"	m	class:spr::ElementError	file:
element	spr/sprEstimateError.cc	/^    apf::Element* element;$/;"	m	class:spr::SelfProduct	file:
element	spr/sprEstimateTargetError.cc	/^    apf::Element* element;$/;"	m	class:spr::target::ElementError	file:
elementImbalance	phasta/phInput.h	/^    double elementImbalance;$/;"	m	class:ph::Input
elementType	phasta/phBlock.h	/^  int elementType;$/;"	m	struct:ph::BlockKey
elementType	test/icesheet.cc	/^  unsigned elementType;$/;"	m	struct:MeshInfo	file:
elementType1	phasta/phBlock.h	/^  int elementType1;$/;"	m	struct:ph::BlockKeyInterface
element_count	pumi/pumi.h	/^    int element_count;$/;"	m	class:Distribution
element_size	spr/sprEstimateError.cc	/^  apf::Field* element_size;$/;"	m	struct:spr::Estimation	file:
elements	apf/apfMesh.h	/^    std::vector<MeshEntity*> elements;$/;"	m	class:apf::Migration
elements	spr/sprRecoverField.cc	/^  EntitySet elements;$/;"	m	struct:spr::Patch	file:
elements	test/icesheet.cc	/^  int* elements;$/;"	m	struct:MeshInfo	file:
elements	zoltan/apfZoltanMesh.h	/^    DynamicArray<MeshEntity*> elements;$/;"	m	class:apf::ZoltanMesh
elementsPerMigration	phasta/phInput.h	/^    int elementsPerMigration;$/;"	m	class:ph::Input
elementsToCollapse	ma/maCollapse.h	/^    EntitySet elementsToCollapse;$/;"	m	class:ma::Collapse
elementsToCollapse	ma/maLayerCollapse.h	/^  EntitySet elementsToCollapse;$/;"	m	struct:ma::LayerCollapse
elementsToKeep	ma/maCollapse.h	/^    EntitySet elementsToKeep;$/;"	m	class:ma::Collapse
elementsToKeep	ma/maLayerCollapse.h	/^  EntitySet elementsToKeep;$/;"	m	struct:ma::LayerCollapse
elems	can/canArray.h	/^    T elems[N];$/;"	m	class:can::Array
elems	can/canArray.h	/^    T* elems;$/;"	m	class:can::Array
elems	mth/mthMatrix.h	/^    can::Array<T> elems;$/;"	m	class:mth::Matrix
elevateBezier	crv/crvElevation.cc	/^void elevateBezier(int type, int P, int r,$/;"	f	namespace:crv
elevateBezierArray	crv/crvElevation.cc	/^elevateBezierArray[apf::Mesh::TYPES] =$/;"	m	namespace:crv	file:
elevateBezierCurve	crv/crvElevation.cc	/^void elevateBezierCurve(apf::Mesh2* m, apf::MeshEntity* edge, int n, int r)$/;"	f	namespace:crv
elevateBezierCurves	crv/crvCurveMesh.cc	/^static void elevateBezierCurves(apf::Mesh2* m)$/;"	f	namespace:crv
elevateBezierEdge	crv/crvElevation.cc	/^void elevateBezierEdge(int P, int r, apf::NewArray<apf::Vector3>& nodes,$/;"	f	namespace:crv
elevateBezierEdgeJacobianDet	crv/crvElevation.cc	/^static void elevateBezierEdgeJacobianDet(int P, int r,$/;"	f	namespace:crv
elevateBezierJacobianDet	crv/crvElevation.cc	/^void elevateBezierJacobianDet(int type, int P, int r,$/;"	f	namespace:crv
elevateBezierJacobianDetArray	crv/crvElevation.cc	/^elevateBezierJacobianDetArray[apf::Mesh::TYPES] =$/;"	m	namespace:crv	file:
elevateBezierTet	crv/crvElevation.cc	/^void elevateBezierTet(int P, int r, apf::NewArray<apf::Vector3>& nodes,$/;"	f	namespace:crv
elevateBezierTetJacobianDet	crv/crvElevation.cc	/^static void elevateBezierTetJacobianDet(int P, int r,$/;"	f	namespace:crv
elevateBezierTriangle	crv/crvElevation.cc	/^void elevateBezierTriangle(int P, int r, apf::NewArray<apf::Vector3>& nodes,$/;"	f	namespace:crv
elevateBezierTriangleJacobianDet	crv/crvElevation.cc	/^static void elevateBezierTriangleJacobianDet(int P, int r,$/;"	f	namespace:crv
elmImb	parma/extractParmaResults.py	/^elmImb = metric("elementImbalance")$/;"	v
elmImbAll	parma/extractParmaResults.py	/^elmImbAll = []$/;"	v
elmMigr	parma/extractParmaResults.py	/^elmMigr = metric("elementMigration")$/;"	v
elmMigrAll	parma/extractParmaResults.py	/^elmMigrAll = []$/;"	v
elmSel	parma/extractParmaResults.py	/^elmSel = metric("elementSelection")$/;"	v
elmSelAll	parma/extractParmaResults.py	/^elmSelAll = []$/;"	v
empty	dsp/dspGraphDistance.cc	/^static bool empty(std::vector<apf::MeshEntity*> const& vs, size_t first)$/;"	f	namespace:dsp
empty	mds/apfMDS.cc	/^  bool empty() { return q.empty(); }$/;"	f	struct:apf::Queue
empty	parma/diffMC/parma_centroidSelector.cc	/^      bool empty() {$/;"	f	class:__anon49::DistanceQueue
empty	parma/diffMC/parma_distQ.h	/^    bool empty()$/;"	f	class:parma::DistanceQueue
encodeILWORK	phasta/phLinks.cc	/^void encodeILWORK(apf::Numbering* n, Links& links, int& size, int*& a)$/;"	f	namespace:ph
encodeILWORKF	phasta/phLinks.cc	/^void encodeILWORKF(apf::Numbering* n, Links& links, int& size, int*& a)$/;"	f	namespace:ph
end	apf/apfGeometry.h	/^  Vector3 end;$/;"	m	struct:apf::LineSegment
end	apf_cap/apfCAP.cc	/^void MeshCAP::end(MeshIterator* it)$/;"	f	class:apf::MeshCAP
end	apf_sim/apfSIM.cc	/^void MeshSIM::end(MeshIterator* it)$/;"	f	class:apf::MeshSIM
end	can/canArray.h	/^    T const* end() const {return elems + sz;}$/;"	f	class:can::Array
end	can/canArray.h	/^    T* end() {return elems + sz;}$/;"	f	class:can::Array
end	gmi/gmi.h	/^  void (*end)(struct gmi_model* m, struct gmi_iter* i);$/;"	m	struct:gmi_model_ops
end	gmi_cap/gmi_cap.cc	/^static void end(gmi_model*, gmi_iter* i)$/;"	f	file:
end	gmi_sim/gmi_sim.cc	/^static void end(gmi_model*, gmi_iter* i)$/;"	f	file:
end	ma/maCrawler.h	/^  virtual void end() {}$/;"	f	struct:ma::Crawler
end	ma/maLayerCoarsen.cc	/^  void end()$/;"	f	struct:ma::CurveLocalizer
end	ma/maLayerRefine.cc	/^  void end()$/;"	f	struct:ma::Disambiguator
end	ma/maLayerRefine.cc	/^  void end()$/;"	f	struct:ma::SplitTagger
end	ma/maLayerSnap.cc	/^  void end()$/;"	f	struct:ma::LayerSnapper
end	ma/maLayerSnap.cc	/^  void end()$/;"	f	struct:ma::SnapTagger
end	ma/maLayerSnap.cc	/^  void end()$/;"	f	struct:ma::UnsnapChecker
end	ma/maLayerSnap.cc	/^  void end()$/;"	f	struct:ma::Unsnapper
end	ma/maTetrahedronize.cc	/^  void end()$/;"	f	struct:ma::QuadMarker
end	mds/apfMDS.cc	/^    void end(MeshIterator* it)$/;"	f	class:apf::MeshMDS
end	mds/mds.h	/^  mds_id end[MDS_TYPES];$/;"	m	struct:mds
end	mds/mds_order.c	/^  mds_id end;$/;"	m	struct:queue	file:
end	parma/diffMC/parma_associative.h	/^      void end() {$/;"	f	class:parma::Associative
end	parma/diffMC/parma_components.cc	/^      void end() {$/;"	f	class:parma::dcComponents::BdryItr
end	pumi/GenIterator.h	/^     inline  bool end() const$/;"	f	class:GenIterator
end	pumi/mPartEntityContainer.cc	/^mPartEntityContainer::iter mPartEntityContainer::end(int what)$/;"	f	class:mPartEntityContainer
end	pumi/pumi.h	/^  iterall end(int d) {return allEntities.end(d);}$/;"	f	class:gModel
end	pumi/pumi_list.h	/^    ListIterator<T> end() {return ListIterator<T>(&head);}$/;"	f	class:List
endBdry	parma/diffMC/parma_components.cc	/^  void dcComponents::endBdry() { bItr->end(); }$/;"	f	class:parma::dcComponents
end_bit	pcu/pcu_coll.h	/^  bool (*end_bit)(int bit); \/\/return true if bit is one past the last$/;"	m	struct:__anon39
end_coll_step	pcu/pcu_coll.c	/^static bool end_coll_step(pcu_coll* c)$/;"	f	file:
ends_with	mds/mds_smb.c	/^static int ends_with(const char* s, const char* w)$/;"	f	file:
enforceDiagonals	ma/maTetrahedronize.cc	/^  void enforceDiagonals(int diagonals)$/;"	f	struct:ma::UnsafePrismOverride
ensa_dof	phasta/phInput.h	/^    int ensa_dof;$/;"	m	class:ph::Input
ensa_melas_dof	phasta/phInput.h	/^    int ensa_melas_dof;$/;"	m	class:ph::Input
ensureNewNumbering	test/fusion2.cc	/^static void ensureNewNumbering(apf::Mesh2* m)$/;"	f	file:
ent	apf/apfField.cc	/^  MeshEntity* ent;$/;"	m	struct:apf::ZeroOp	file:
entDim	parma/diffMC/parma_entWeights.h	/^      int entDim;$/;"	m	class:parma::EntWeights
entDim	parma/diffMC/parma_ghostMPASWeights.cc	/^      int entDim;$/;"	m	class:parma::GhostMPASWeights	file:
entMap	mds/mdsGmsh.cc	/^  std::map<long, apf::MeshEntity*> entMap[4];$/;"	m	struct:__anon96::Reader	file:
ent_bdry_types	gmi/agm.c	/^static enum agm_bdry_type const ent_bdry_types[AGM_ENT_TYPES] = {$/;"	v	file:
ent_use_types	gmi/agm.c	/^static enum agm_use_type const ent_use_types[AGM_ENT_TYPES] = {$/;"	v	file:
enterFilteredMatching	phasta/phFilterMatching.cc	/^void enterFilteredMatching(apf::Mesh2* m, Input& in, BCs& bcs)$/;"	f	namespace:ph
entities	ma/maAdapt.h	/^    std::vector<Entity*> entities;$/;"	m	class:ma::NewEntities
entity	apf/apfElement.h	/^    MeshEntity* entity;$/;"	m	class:apf::Element
entity	apf/apfFieldOf.cc	/^    MeshEntity* entity;$/;"	m	class:apf::Axpy	file:
entity	apf/apfMesh.h	/^  MeshEntity* entity;$/;"	m	struct:apf::Copy
entity	apf/apfNumbering.h	/^  MeshEntity* entity;$/;"	m	struct:apf::Node
entity	apf/apfVtk.cc	/^    MeshEntity* entity;$/;"	m	class:apf::WriteIPField	file:
entity	mds/mdsGmsh.cc	/^  apf::MeshEntity* entity;$/;"	m	struct:__anon96::Node	file:
entity	spr/sprEstimateError.cc	/^    apf::MeshEntity* entity;$/;"	m	class:spr::AverageOp	file:
entity	spr/sprEstimateError.cc	/^    apf::MeshEntity* entity;$/;"	m	class:spr::ElementError	file:
entity	spr/sprEstimateTargetError.cc	/^    apf::MeshEntity* entity;$/;"	m	class:spr::target::AverageOp	file:
entity	spr/sprEstimateTargetError.cc	/^    apf::MeshEntity* entity;$/;"	m	class:spr::target::ElementError	file:
entity	spr/sprRecoverField.cc	/^  apf::MeshEntity* entity;$/;"	m	struct:spr::Patch	file:
entry	gmi/gmi_lookup.c	/^struct entry {$/;"	s	file:
ents	apf/apfMIS.h	/^    MeshEntity** ents;$/;"	m	class:apf::MIS
ents	gmi/agm.c	/^  struct ents ents;$/;"	m	struct:agm	typeref:struct:agm::ents	file:
ents	gmi/agm.c	/^struct ents {$/;"	s	file:
ents	ma/maExtrude.cc	/^  Crawler::Layer ents[3];$/;"	m	struct:ma::__anon28::FullLayer	file:
ents	stk/apfAlbany.h	/^  Vector ents;$/;"	m	struct:apf::StkModel
ents_from_osh	omega_h/apfOmega_h.cc	/^ents_from_osh($/;"	f	namespace:apf
entset	parma/diffMC/parma_ghostWeights.cc	/^      typedef std::set<apf::MeshEntity*> entset;$/;"	t	class:parma::ElmGhostFinder	file:
eps	spr/sprEstimateError.cc	/^  apf::Field* eps;$/;"	m	struct:spr::Estimation	file:
eps	spr/sprEstimateTargetError.cc	/^  apf::Field* eps;$/;"	m	struct:spr::target::Estimation	file:
eps_star	spr/sprEstimateError.cc	/^  apf::Field* eps_star;$/;"	m	struct:spr::Estimation	file:
eps_star	spr/sprEstimateTargetError.cc	/^  apf::Field* eps_star;$/;"	m	struct:spr::target::Estimation	file:
erase	parma/diffMC/parma_distQ.h	/^    DistanceQIter erase(int dist, apf::MeshEntity* e)$/;"	f	class:parma::DistanceQueue
error	parma/diffMC/parma_commons.cc	/^void parmaCommons::error(const char* fmt,...) {$/;"	f	class:parmaCommons
errorThreshold	sam/sam.cc	/^apf::Field* errorThreshold(apf::Mesh* m, const char* fieldName,$/;"	f	namespace:sam
essentialBCs	phasta/phBC.cc	/^static KnownBC const essentialBCs[7] = {$/;"	m	namespace:ph	file:
estimateError	spr/sprEstimateError.cc	/^static void estimateError(Estimation* e)$/;"	f	namespace:spr
estimateError	spr/sprEstimateTargetError.cc	/^static void estimateError(Estimation* e)$/;"	f	namespace:spr::target
estimation	spr/sprEstimateError.cc	/^    Estimation* estimation;$/;"	m	class:spr::AverageOp	file:
estimation	spr/sprEstimateError.cc	/^    Estimation* estimation;$/;"	m	class:spr::ElementError	file:
estimation	spr/sprEstimateError.cc	/^    Estimation* estimation;$/;"	m	class:spr::SelfProduct	file:
estimation	spr/sprEstimateTargetError.cc	/^    Estimation* estimation;$/;"	m	class:spr::target::AverageOp	file:
estimation	spr/sprEstimateTargetError.cc	/^    Estimation* estimation;$/;"	m	class:spr::target::ElementError	file:
eval	gmi/gmi.h	/^  void (*eval)(struct gmi_model* m, struct gmi_ent* e,$/;"	m	struct:gmi_model_ops
eval	gmi/gmi_analytic.c	/^static void eval(struct gmi_model* m, struct gmi_ent* e,$/;"	f	file:
eval	gmi_cap/gmi_cap.cc	/^static void eval(struct gmi_model* m, struct gmi_ent* e,$/;"	f	file:
eval	gmi_sim/gmi_sim.cc	/^static void eval(struct gmi_model* m, struct gmi_ent* e,$/;"	f	file:
eval	ma/maSize.cc	/^  void eval(Entity* e, double* result)$/;"	f	struct:ma::FrameEval
eval	ma/maSize.cc	/^  void eval(Entity* e, double* result)$/;"	f	struct:ma::LogMEval
eval	ma/maSize.cc	/^  void eval(Entity* e, double* result)$/;"	f	struct:ma::SizesEval
eval	phasta/phAttrib.cc	/^  virtual double* eval(apf::Vector3 const& x)$/;"	f	struct:CompBC
eval	phasta/phAttrib.cc	/^  virtual double* eval(apf::Vector3 const& x)$/;"	f	struct:Tensor0BC
eval	phasta/phAttrib.cc	/^  virtual double* eval(apf::Vector3 const& x)$/;"	f	struct:Tensor1BC
eval	phasta/phAttrib.cc	/^  virtual double* eval(apf::Vector3 const&)$/;"	f	struct:IntBC
eval	phasta/phBC.cc	/^double* ConstantBC::eval(apf::Vector3 const& x)$/;"	f	class:ph::ConstantBC
eval	test/fusion3.cc	/^double BSpline :: eval(double x) const$/;"	f	class:BSpline
eval	test/verify_convert.cc	/^  virtual void eval(apf::MeshEntity* e, double* result)$/;"	f	class:twox
evalCoord	test/fusion3.cc	/^void evalCoord(double para, double *xyz, void* userdata)$/;"	f
evalPolynomial	spr/sprRecoverField.cc	/^static double evalPolynomial(int dim, int order, apf::Vector3& point,$/;"	f	namespace:spr
evalPolynomialTerms	spr/sprRecoverField.cc	/^static void evalPolynomialTerms($/;"	f	namespace:spr
evaluateBlendedQuad	crv/crvShapeHandler.cc	/^    void evaluateBlendedQuad(ma::Entity* verts[4], ma::Entity* edges[4],$/;"	f	class:crv::BezierHandler
evaluateFlags	ma/maDBG.cc	/^void evaluateFlags(ma::Adapt* a,$/;"	f	namespace:ma_dbg
ew	parma/diffMC/parma_elmLtVtxEdgeSelector.cc	/^        double ew;$/;"	m	struct:__anon64::ElmLtVtxEdgeSelector::Migr	file:
exchange	parma/diffMC/parma_ghostMPASWeights.cc	/^      void exchange() {$/;"	f	class:parma::GhostMPASWeights	file:
exchange	parma/diffMC/parma_ghostWeights.cc	/^      void exchange() {$/;"	f	class:parma::GhostWeights	file:
exchangeGhostElementsFrom	parma/diffMC/parma_ghostMPASWeights.cc	/^      void exchangeGhostElementsFrom() {$/;"	f	class:parma::GhostMPASWeights	file:
exchangeGhostsFrom	parma/diffMC/parma_ghostWeights.cc	/^      void exchangeGhostsFrom() {$/;"	f	class:parma::GhostWeights	file:
exitFilteredMatching	phasta/phFilterMatching.cc	/^void exitFilteredMatching(apf::Mesh2* m)$/;"	f	namespace:ph
exp	mth/mthAD.h	/^AD<T, N> exp(AD<T, N> const& A)$/;"	f	namespace:mth
exp	mth/mthAD.h	/^double exp(double x)$/;"	f	namespace:mth
expandAsNecessary	spr/sprRecoverField.cc	/^static bool expandAsNecessary(Patch* p, apf::CavityOp* o)$/;"	f	namespace:spr
expandMdsMesh	mds/apfMDS.cc	/^Mesh2* expandMdsMesh(Mesh2* m, gmi_model* g, int inputPartCount)$/;"	f	namespace:apf
expand_once	mds/mds.c	/^static void expand_once(struct mds* m, struct mds_set* from, struct mds_set* to)$/;"	f	file:
expectedNum	test/sim_countBL.cc	/^int expectedNum;$/;"	v
expected_type_	ma/maExtrude.cc	/^  int expected_type_;$/;"	m	class:ma::__anon28::DebugBuildCallback	file:
export_gids	zoltan/apfZoltanCallbacks.h	/^    ZOLTAN_ID_PTR export_gids; \/* Global ids of nodes exported *\/$/;"	m	class:apf::ZoltanData
export_lids	zoltan/apfZoltanCallbacks.h	/^    ZOLTAN_ID_PTR export_lids; \/* Pointers to nodes exported *\/$/;"	m	class:apf::ZoltanData
export_procs	zoltan/apfZoltanCallbacks.h	/^    int *export_procs;$/;"	m	class:apf::ZoltanData
export_to_part	zoltan/apfZoltanCallbacks.h	/^    int *export_to_part;$/;"	m	class:apf::ZoltanData
exscan	apf/apfNumbering.cc	/^static long exscan(long x)$/;"	f	namespace:apf
ext	gmi/gmi.c	/^  char* ext;$/;"	m	struct:creator	file:
extractCoords	apf/apfConstruct.cc	/^void extractCoords(Mesh2* m, double*& coords, int& nverts)$/;"	f	namespace:apf
extractField	phasta/phCook.cc	/^  apf::Field* extractField(apf::Mesh* m,$/;"	f	namespace:chef
extractField	phasta/phRestart.cc	/^apf::Field* extractField(apf::Mesh* m,$/;"	f	namespace:ph
extractNthStrandData	test/capStoneAttachSolution.cc	/^static std::vector<double> extractNthStrandData(const std::vector<row> &table,$/;"	f	file:
extractSurfaceData	test/capStoneAttachSolution.cc	/^std::vector<double> extractSurfaceData(const std::vector<row> &table,$/;"	f
extrude	ma/maExtrude.cc	/^void extrude(Mesh* m, ModelExtrusions const& model_extrusions,$/;"	f	namespace:ma
eye	mth/mth_def.h	/^Tensor<T> eye(unsigned d)$/;"	f	namespace:mth
f	apf/apfGradientByVolume.cc	/^    Field* f;$/;"	m	class:apf::GradientIntegrator	file:
f	apf/apfGradientByVolume.cc	/^    Field* f;$/;"	m	class:apf::RecoverGradient	file:
f	apf/apfVtk.h	/^    FieldBase* f;$/;"	m	class:apf::HasAll
f	gmi/gmi.c	/^  gmi_creator f;$/;"	m	struct:creator	file:
f	gmi/gmi_analytic.c	/^  struct agm_tag* f;$/;"	m	struct:gmi_analytic	typeref:struct:gmi_analytic::agm_tag	file:
f	gmi_sim/gmi_sim.cc	/^    GFIter f;$/;"	m	union:sim_iter::__anon103	file:
f	parma/diffMC/parma_vtxPtnWriter.cc	/^    int f;$/;"	m	class:__anon72::Ptn	file:
f	pcu/pcu_io.c	/^  FILE* f;$/;"	m	struct:pcu_file	file:
f	proteushash.py	/^f = open(sys.argv[1])$/;"	v
f	spr/sprRecoverField.cc	/^  apf::Field* f;$/;"	m	struct:spr::Recovery	file:
f1	test/test_AD.cc	/^AD f1(AD const& a, AD const& b)$/;"	f
fCnt	test/refine2x.cc	/^    apf::Field* fCnt;$/;"	m	class:AnisotropicX	file:
fLen	test/refine2x.cc	/^    apf::Field* fLen;$/;"	m	class:AnisotropicX	file:
f_of	gmi/gmi_analytic.c	/^static gmi_analytic_fun* f_of(struct gmi_analytic* m, struct agm_ent e)$/;"	f	file:
f_star	spr/sprRecoverField.cc	/^  apf::Field* f_star;$/;"	m	struct:spr::Recovery	file:
face	ma/maShape.cc	/^    Entity *face, *oppVert;$/;"	m	class:ma::FaceVertFixer	file:
face0	test/bezierElevation.cc	/^void face0(double const p[2], double x[3], void*)$/;"	f
face0	test/bezierMesh.cc	/^void face0(double const p[2], double x[3], void*)$/;"	f
face0	test/bezierRefine.cc	/^void face0(double const p[2], double x[3], void*)$/;"	f
face0	test/bezierSubdivision.cc	/^void face0(double const p[2], double x[3], void*)$/;"	f
face0	test/bezierValidity.cc	/^void face0(double const p[2], double x[3], void*)$/;"	f
faceFunction	test/fusion.cc	/^void faceFunction(double const p[2], double x[3], void*)$/;"	f
faceFunction	test/fusion3.cc	/^void faceFunction(double const p[2], double x[3], void * data)$/;"	f
faceNormal	ma/maRegionCollapse.cc	/^Vector faceNormal(Mesh* mesh, Entity* face, Entity* rgn)$/;"	f	namespace:ma
faceSplit	ma/maFaceSplitCollapse.h	/^    FaceSplit faceSplit;$/;"	m	class:ma::FaceSplitCollapse
faceSplitCollapse	ma/maShape.cc	/^    FaceSplitCollapse faceSplitCollapse;$/;"	m	class:ma::FaceVertFixer	file:
faceTags	mds/mdsUgrid.cc	/^    unsigned* faceTags[2];$/;"	m	struct:__anon101::Reader	file:
faceTypeIdx	mds/mdsUgrid.cc	/^  int faceTypeIdx(int type) {$/;"	f	namespace:__anon101
faceVertFixer	crv/crvShapeFixer.h	/^    CrvFaceVertFixer faceVertFixer;$/;"	m	class:crv::CrvLargeAngleTetFixer
faceVertFixer	ma/maShape.cc	/^    FaceVertFixer faceVertFixer;$/;"	m	class:ma::LargeAngleTetFixer	file:
faceVerts	mds/mdsUgrid.cc	/^    unsigned* faceVerts[2];$/;"	m	struct:__anon101::Reader	file:
face_apf2ph	phasta/phAdjacent.cc	/^int const* const face_apf2ph[apf::Mesh::TYPES] = {$/;"	m	namespace:ph	file:
face_regions	gmi_sim/gmi_sim.cc	/^static gmi_set* face_regions(pGFace face)$/;"	f	file:
face_regions2	gmi_sim/gmi_sim.cc	/^static int face_regions2(pGFace face, pGRegion regions[2])$/;"	f	file:
face_reparam_one	test/bezierRefine.cc	/^void face_reparam_one(double const from[2], double to[2], void*)$/;"	f
face_reparam_three	test/bezierRefine.cc	/^void face_reparam_three(double const from[2], double to[2], void*)$/;"	f
face_reparam_two	test/bezierRefine.cc	/^void face_reparam_two(double const from[2], double to[2], void*)$/;"	f
face_reparam_zero	test/bezierRefine.cc	/^void face_reparam_zero(double const from[2], double to[2], void*)$/;"	f
faces	ma/maRegionCollapse.h	/^    Entity* faces[4];$/;"	m	class:ma::RegionCollapse
factor	apf/apfPartition.h	/^  int factor;$/;"	m	struct:apf::Round
factor	parma/diffMC/parma_balancer.h	/^      double factor;$/;"	m	class:parma::Balancer
factor	parma/group/parma_group.cc	/^  int factor;$/;"	m	struct:RetreatCode	file:
factor	test/capStoneAnisoAdaptWing.cc	/^    double factor;$/;"	m	class:WingShock	file:
factor	test/capStoneSizeFields.h	/^    double factor;$/;"	m	class:GeomB737
factor	test/capStoneSizeFields.h	/^    double factor;$/;"	m	class:GeomRobin
factor	test/capStoneSizeFields.h	/^    double factor;$/;"	m	class:Linear1
factor	test/capStoneSizeFields.h	/^    double factor;$/;"	m	class:Linear2
factor	test/capStoneSizeFields.h	/^    double factor;$/;"	m	class:Linear3
factor	test/capStoneSizeFields.h	/^    double factor;$/;"	m	class:Uniform
factor	test/capStoneSizeFields.h	/^    double factor;$/;"	m	class:WingShock
factorial	ma/maQuality.cc	/^static int factorial(int num)$/;"	f	namespace:ma
fail	apf/apf.cc	/^void fail(const char* why)$/;"	f	namespace:apf
fail	crv/crv.cc	/^void fail(const char* why)$/;"	f	namespace:crv
fail	parma/diffMC/maximalIndependentSet/mersenne_twister.cc	/^  void fail(const char* msg) {$/;"	f	namespace:__anon51
fail	phasta/ph.cc	/^void fail(const char* format, ...)$/;"	f	namespace:ph
fail	test/quality.cc	/^static void fail(char** argv)$/;"	f	namespace:__anon21
fd	apf_sim/apfSIMDataOf.h	/^  pField fd;$/;"	m	class:apf::SIMDataOf
feedbackUnsnap	ma/maLayerSnap.cc	/^static void feedbackUnsnap(Adapt* a, Tag* snapTag, BaseTopLinker& l)$/;"	f	namespace:ma
field	apf/apfElement.h	/^    Field* field;$/;"	m	class:apf::Element
field	apf/apfField.cc	/^  Field* field;$/;"	m	struct:apf::ZeroOp	file:
field	apf/apfFieldData.h	/^    FieldBase* field;$/;"	m	class:apf::FieldData
field	apf/apfNumbering.cc	/^    FieldBase* field;$/;"	m	class:apf::Counter	file:
field	apf/apfNumberingClass.h	/^    Field* field;$/;"	m	class:apf::NumberingOf
field	ma/maExtrude.cc	/^  apf::Field* field;$/;"	m	struct:ma::__anon28::FieldDataGetter	file:
field	ma/maExtrude.cc	/^  apf::Field* field;$/;"	m	struct:ma::__anon28::FieldDataSetter	file:
field	ma/maSize.cc	/^    apf::Field* field;$/;"	m	class:ma::FieldReader	file:
field	ma/maSolutionTransfer.cc	/^    apf::Field* field;$/;"	m	class:ma::FieldTransfer	file:
field	phasta/phAdapt.cc	/^  apf::Field* field;$/;"	m	struct:ph::AdaptCallback	file:
field	test/hierarchic.cc	/^    apf::Field* field;$/;"	m	class:__anon20::L2Projector	file:
field_from_osh	omega_h/apfOmega_h.cc	/^static void field_from_osh(apf::Field* f, osh::Tag<osh::Real> const* tag,$/;"	f	namespace:apf
field_from_osh	omega_h/apfOmega_h.cc	/^static void field_from_osh(apf::Mesh* am, osh::Tag<osh::Real> const* tag,$/;"	f	namespace:apf
field_to_osh	omega_h/apfOmega_h.cc	/^static void field_to_osh(osh::Mesh* om, apf::Field* f) {$/;"	f	namespace:apf
fields	apf/apfMesh.h	/^    std::vector<Field*> fields;$/;"	m	class:apf::Mesh
fields	phasta/phBC.h	/^  Map fields;$/;"	m	struct:ph::BCs
fields_from_osh	omega_h/apfOmega_h.cc	/^static void fields_from_osh(apf::Mesh* am, osh::Mesh* om) {$/;"	f	namespace:apf
fields_from_osh	omega_h/apfOmega_h.cc	/^static void fields_from_osh(apf::Mesh* am, osh::Mesh* om, int ent_dim) {$/;"	f	namespace:apf
fields_to_osh	omega_h/apfOmega_h.cc	/^static void fields_to_osh(osh::Mesh* om, apf::Mesh* am) {$/;"	f	namespace:apf
fight	ma/maLayerCoarsen.cc	/^  int fight(int a, int b)$/;"	f	struct:ma::CurveLocalizer
file	mds/mdsGmsh.cc	/^  FILE* file;$/;"	m	struct:__anon96::Reader	file:
file	mds/mdsUgrid.cc	/^    FILE* file;$/;"	m	struct:__anon101::Reader	file:
file	pcu/pcu_msg.h	/^  FILE* file; \/\/messenger-unique input or output file$/;"	m	struct:pcu_msg_struct
fileIdx	phasta/phiotimer.cc	/^  int fileIdx;$/;"	m	struct:phastaio_stats	file:
fill	pcu/pcu_order.c	/^static void fill(pcu_order o, pcu_aa_tree t)$/;"	f	file:
fill	test/hierarchic.cc	/^void L2Projector::fill() {$/;"	f	class:__anon20::L2Projector
fillBlockKeyInterfaceParams	phasta/phGeomBC.cc	/^void fillBlockKeyInterfaceParams$/;"	f	namespace:ph
fillBlockKeyParams	phasta/phGeomBC.cc	/^void fillBlockKeyParams(int* params, BlockKey& k)$/;"	f	namespace:ph
fill_boundary	test/poisson.cc	/^    void fill_boundary() {$/;"	f	class:__anon17::Poisson	file:
fill_hole	mds/mds.c	/^static mds_id fill_hole(struct mds* m, int t)$/;"	f	file:
fill_identity	mth/mthQR.cc	/^static void fill_identity(Matrix<T,M,M>& q)$/;"	f	namespace:mth
fill_volumetric	test/poisson.cc	/^    void fill_volumetric() {$/;"	f	class:__anon17::Poisson	file:
filterMatches	phasta/phInput.h	/^    int filterMatches;$/;"	m	class:ph::Input
filterMatching	phasta/phFilterMatching.cc	/^void filterMatching(apf::Mesh2* m, ModelMatching& mm, int dim)$/;"	f	namespace:ph
finalize	test/hierarchic.cc	/^void L2Projector::finalize() {$/;"	f	class:__anon20::L2Projector
finalize	test/simZBalance.cc	/^static void finalize() {$/;"	f	file:
finalizeMIS	apf/apfMIS.cc	/^  void finalizeMIS(MIS* mis) {$/;"	f	namespace:apf
find	gmi/gmi.h	/^  struct gmi_ent* (*find)(struct gmi_model* m, int dim, int tag);$/;"	m	struct:gmi_model_ops	typeref:struct:gmi_model_ops::find
find	gmi_cap/gmi_cap.cc	/^static gmi_ent* find(gmi_model* m, int dim, int tag)$/;"	f	file:
find	gmi_sim/gmi_sim.cc	/^static gmi_ent* find(gmi_model* m, int dim, int tag)$/;"	f	file:
find	ma/maSnapper.cc	/^bool FirstProblemPlane::find()$/;"	f	class:ma::FirstProblemPlane
findCandidateEdges	ma/maSnapper.cc	/^void FirstProblemPlane::findCandidateEdges(std::vector<Entity*> &edges)$/;"	f	class:ma::FirstProblemPlane
findCommonEdges	ma/maSnapper.cc	/^void FirstProblemPlane::findCommonEdges(apf::Up& cpRegions)$/;"	f	class:ma::FirstProblemPlane
findEdge	ma/maMesh.cc	/^Entity* findEdge(Mesh* m, Entity* v0, Entity* v1)$/;"	f	namespace:ma
findEdgeEdgeRotation	ma/sliverCodeMatch.cc	/^int findEdgeEdgeRotation(int const edges[2][2])$/;"	f
findEdgeInTri	crv/crvShapeHandler.cc	/^    ma::Entity* findEdgeInTri(ma::Entity* v0, ma::Entity* v1,$/;"	f	class:crv::BezierHandler
findEdgeTrianglesCross	crv/crvShapeHandler.cc	/^    bool findEdgeTrianglesCross(ma::EntityArray& entities,$/;"	f	class:crv::BezierHandler
findEdgeTrianglesShared	crv/crvShapeHandler.cc	/^    bool findEdgeTrianglesShared(ma::Entity* edge,$/;"	f	class:crv::BezierHandler
findEdges	ma/maShortEdgeRemover.cc	/^void ShortEdgeRemover::findEdges()$/;"	f	class:ma::ShortEdgeRemover
findEdges	ma/maVertRemover.cc	/^void VertRemover::findEdges()$/;"	f	class:ma::VertRemover
findElement	apf/apfMesh.cc	/^MeshEntity* findElement($/;"	f	namespace:apf
findEntry	pumi/GenTag.cc	/^static int findEntry(Entry* container, TagHandle* handle, int size)$/;"	f	file:
findField	apf/apfMesh.cc	/^Field* Mesh::findField(const char* name)$/;"	f	class:apf::Mesh
findFirst	mds/apfMDS.cc	/^apf::MeshEntity* findFirst(apf::Mesh* m)$/;"	f	namespace:apf
findFromFace	ma/maEdgeSwap.cc	/^    void findFromFace(Entity* startFace)$/;"	f	class:ma::SwapLoop
findGhostElements	parma/diffMC/parma_ghostMPASWeights.cc	/^      void findGhostElements(GhostElementFinder* finder, Sides* sides) {$/;"	f	class:parma::GhostMPASWeights	file:
findGhosts	parma/diffMC/parma_ghostWeights.cc	/^      void findGhosts(GhostFinder* finder, Sides* sides) {$/;"	f	class:parma::GhostWeights	file:
findGlobalNumbering	apf/apfMesh.cc	/^GlobalNumbering* Mesh::findGlobalNumbering(const char* name)$/;"	f	class:apf::Mesh
findGoodTriangulation	ma/maEdgeSwap.cc	/^    bool findGoodTriangulation(double q, Upward& ot)$/;"	f	class:ma::SwapCavity
findIn	apf/apfMesh.cc	/^int findIn(MeshEntity** a, int n, MeshEntity* e)$/;"	f	namespace:apf
findIndependentSet	ma/maCoarsen.cc	/^void findIndependentSet(Adapt* a)$/;"	f	namespace:ma
findInitialTet	ma/maEdgeSwap.cc	/^    Entity* findInitialTet(Entity* vert, Entity* face)$/;"	f	class:ma::SwapLoop
findLayerBase	ma/maLayer.cc	/^void findLayerBase(Adapt* a)$/;"	f	namespace:ma
findMatch	ma/prismCodeMatch.cc	/^void findMatch(int code, int& rotation, int& index)$/;"	f
findMatch	ma/pyramidCodeMatch.cc	/^void findMatch(int code, int& rotation, int& index)$/;"	f
findMatch	ma/tetCodeMatch.cc	/^void findMatch(int code, int& rotation, int& index)$/;"	f
findMatches	apf_sim/apfSIM.cc	/^static bool findMatches(Mesh* m)$/;"	f	namespace:apf
findMaterials	phasta/phInterfaceCutter.cc	/^static void findMaterials(gmi_model* gm, FieldBCs& fbcs,$/;"	f	namespace:ph
findMaterialsDFS	phasta/phInterfaceCutter.cc	/^static void findMaterialsDFS(gmi_model* gm, FieldBCs& fbcs,$/;"	f	namespace:ph
findModelEntity	apf/apfMesh.cc	/^ModelEntity* Mesh::findModelEntity(int type, int tag)$/;"	f	class:apf::Mesh
findNumbering	apf/apfMesh.cc	/^Numbering* Mesh::findNumbering(const char* name)$/;"	f	class:apf::Mesh
findOldFaces	ma/maEdgeSwap.cc	/^    void findOldFaces()$/;"	f	class:ma::EdgeSwap2D
findQuad	ma/maEdgeSwap.cc	/^    void findQuad()$/;"	f	class:ma::EdgeSwap2D
findSortedMedian	parma/rib/parma_rib.cc	/^int findSortedMedian(Bodies const* b)$/;"	f	namespace:parma
findSplitVert	ma/maRefine.cc	/^Entity* findSplitVert(Refine* r, Entity* parent)$/;"	f	namespace:ma
findSplitVert	ma/maRefine.cc	/^Entity* findSplitVert(Refine* r, Entity* v0, Entity* v1)$/;"	f	namespace:ma
findSplitVert	ma/maRefine.cc	/^Entity* findSplitVert(Refine* r, int dimension, int id)$/;"	f	namespace:ma
findTag	apf_cap/apfCAP.cc	/^MeshTag* MeshCAP::findTag(const char* name)$/;"	f	class:apf::MeshCAP
findTag	apf_sim/apfSIM.cc	/^MeshTag* MeshSIM::findTag(const char* name)$/;"	f	class:apf::MeshSIM
findTag	mds/apfMDS.cc	/^    MeshTag* findTag(const char* name)$/;"	f	class:apf::MeshMDS
findTetByTwoTris	ma/maMesh.cc	/^Entity* findTetByTwoTris(Mesh* m, Entity** tris)$/;"	f	namespace:ma
findTetRotation	ma/maMesh.cc	/^int findTetRotation(Mesh* m, Entity* tet, Entity** v)$/;"	f	namespace:ma
findTriDown	apf/apfMesh.cc	/^void findTriDown($/;"	f	namespace:apf
findTriFromVerts	ma/maMesh.cc	/^Entity* findTriFromVerts(Mesh* m, Entity** v)$/;"	f	namespace:ma
findUpward	apf/apfMesh.cc	/^MeshEntity* findUpward(Mesh* m, int type, MeshEntity** down)$/;"	f	namespace:apf
findVertFaceRotation	ma/sliverCodeMatch.cc	/^int findVertFaceRotation(int vert)$/;"	f
find_header	phasta/phIO.c	/^static int find_header(FILE* f, const char* name, char* found, char header[PH_LINE])$/;"	f	file:
find_path	gmi/agm.c	/^static int find_path(struct agm* m, struct agm_ent from, struct agm_ent to,$/;"	f	file:
find_peer	mds/mds_net.c	/^static int find_peer(struct mds_links* ln, unsigned p)$/;"	f	file:
find_peer	pcu/pcu_msg.c	/^static pcu_msg_peer* find_peer(pcu_aa_tree t, int id)$/;"	f	file:
find_place	mds/mds_net.c	/^static int find_place(struct mds_copies* cs, int p)$/;"	f	file:
find_prev	mds/mds_tag.c	/^static struct mds_tag** find_prev(struct mds_tags* ts, struct mds_tag* t)$/;"	f	file:
find_seed	mds/mds_order.c	/^static mds_id find_seed(struct mds_apf* m)$/;"	f	file:
first	gmi/agm.c	/^  struct agm_tag* first;$/;"	m	struct:agm_tags	typeref:struct:agm_tags::agm_tag	file:
first	mds/mds_order.c	/^  mds_id first;$/;"	m	struct:queue	file:
first	mds/mds_tag.h	/^  struct mds_tag* first;$/;"	m	struct:mds_tags	typeref:struct:mds_tags::mds_tag
first	parma/diffMC/parma_vtxPtnWriter.cc	/^    int first() {$/;"	f	class:__anon72::Ptn
first_bdry	gmi/agm.c	/^  int* first_bdry[AGM_ENT_TYPES];$/;"	m	struct:ents	file:
first_derivative	gmi/gmi.h	/^  void (*first_derivative)(struct gmi_model* m, struct gmi_ent* e,$/;"	m	struct:gmi_model_ops
first_derivative	gmi_cap/gmi_cap.cc	/^static void first_derivative(struct gmi_model* m, struct gmi_ent* e,$/;"	f	file:
first_derivative	gmi_sim/gmi_sim.cc	/^static void first_derivative(struct gmi_model* m, struct gmi_ent* e,$/;"	f	file:
first_free	mds/mds.h	/^  mds_id first_free[MDS_TYPES];$/;"	m	struct:mds
first_up	mds/mds.h	/^  mds_id* first_up[4][MDS_TYPES];$/;"	m	struct:mds
first_use	gmi/agm.c	/^  int* first_use[AGM_BDRY_TYPES];$/;"	m	struct:bdrys	file:
first_use	gmi/agm.c	/^  int* first_use[AGM_ENT_TYPES];$/;"	m	struct:ents	file:
fit	ma/maAdapt.cc	/^void Cavity::fit(EntityArray& oldElements)$/;"	f	class:ma::Cavity
fitElements	ma/maCollapse.cc	/^void Collapse::fitElements()$/;"	f	class:ma::Collapse
fiter	apf_sim/apfSIM.h	/^    FIter fiter;$/;"	m	class:apf::MeshSIM
fix	apf/apfNumbering.cc	/^void fix(Numbering* n, MeshEntity* e, int node, int component, bool fixed)$/;"	f	namespace:apf
fix	parma/diffMC/parma_dcpartFixer.cc	/^    void fix() {$/;"	f	class:dcPartFixer::PartFixer	file:
fixCoords	phasta/ph_convert.cc	/^static void fixCoords(apf::Mesh2* m)$/;"	f	file:
fixCrvElementShapes	crv/crvShape.cc	/^void fixCrvElementShapes(Adapt* a)$/;"	f	namespace:crv
fixElementShapes	ma/maShape.cc	/^void fixElementShapes(Adapt* a)$/;"	f	namespace:ma
fixInvalidEdges	crv/crvShape.cc	/^int fixInvalidEdges(Adapt* a)$/;"	f	namespace:crv
fixInvalidElements	crv/crvAdapt.cc	/^static int fixInvalidElements(crv::Adapt* a)$/;"	f	namespace:crv
fixLargeAngleTets	ma/maShape.cc	/^static void fixLargeAngleTets(Adapt* a)$/;"	f	namespace:ma
fixLargeAngleTris	ma/maShape.cc	/^static void fixLargeAngleTris(Adapt* a)$/;"	f	namespace:ma
fixLargeAngles	crv/crvShape.cc	/^int fixLargeAngles(Adapt *a)$/;"	f	namespace:crv
fixLargeAngles	ma/maShape.cc	/^static double fixLargeAngles(Adapt* a)$/;"	f	namespace:ma
fixLargeBoundaryAngles	crv/crvShape.cc	/^int fixLargeBoundaryAngles(Adapt* a)$/;"	f	namespace:crv
fixMatches	phasta/ph_convert.cc	/^static void fixMatches(apf::Mesh2* m)$/;"	f	file:
fixMatches	test/convert.cc	/^static void fixMatches(apf::Mesh2* m)$/;"	f	file:
fixMatches	test/generate.cc	/^void fixMatches(apf::Mesh2* m)$/;"	f	namespace:__anon19
fixPyramids	phasta/ph_convert.cc	/^static void fixPyramids(apf::Mesh2* m)$/;"	f	file:
fixPyramids	test/convert.cc	/^static void fixPyramids(apf::Mesh2* m)$/;"	f	file:
fixPyramids	test/generate.cc	/^void fixPyramids(apf::Mesh2* m)$/;"	f	namespace:__anon19
fixShortEdgeElements	crv/crvShape.cc	/^static int fixShortEdgeElements(Adapt* a)$/;"	f	namespace:crv
fixShortEdgeElements	ma/maShape.cc	/^static double fixShortEdgeElements(Adapt* a)$/;"	f	namespace:ma
fixer	crv/crvShapeFixer.h	/^    CrvTetFixerBase* fixer;$/;"	m	class:crv::CrvLargeAngleTetFixer
fixer	ma/maShape.cc	/^    FixBySwap fixer;$/;"	m	class:ma::LargeAngleTetAligner	file:
fixer	ma/maShape.cc	/^    TetFixerBase* fixer;$/;"	m	class:ma::LargeAngleTetFixer	file:
flag	ma/maAdapt.h	/^  int flag;$/;"	m	struct:ma::HasFlag
flagCleaner	crv/crvAdapt.cc	/^static void flagCleaner(crv::Adapt* a)$/;"	f	namespace:crv
flagLayerTop	ma/maCrawler.cc	/^void flagLayerTop(Adapt* a)$/;"	f	namespace:ma
flagQuad	ma/maTetrahedronize.cc	/^static Entity* flagQuad(Adapt* a, Entity* q, Entity* e)$/;"	f	namespace:ma
flagQuadDiagonals	ma/maTetrahedronize.cc	/^static void flagQuadDiagonals(Adapt* a)$/;"	f	namespace:ma
flagsTag	ma/maAdapt.h	/^    Tag* flagsTag;$/;"	m	class:ma::Adapt
flatAngle	ma/maRegionCollapse.h	/^    double flatAngle;$/;"	m	class:ma::RegionCollapse
flat_data	ma/maExtrude.cc	/^  std::vector<FieldData> flat_data;$/;"	m	struct:ma::__anon28::AllFieldsData	file:
flat_z_data	ma/maExtrude.cc	/^  FieldData flat_z_data;$/;"	m	struct:ma::__anon28::AllFieldsData	file:
flip_tet_tri_edges	crv/crvTables.h	/^static bool const flip_tet_tri_edges[4][3] =$/;"	m	namespace:crv
floor_log2	pcu/pcu_coll.c	/^static int floor_log2(int n)$/;"	f	file:
forRotation	apf/apfGeometry.cc	/^Frame Frame::forRotation(Vector3 const& u, double a)$/;"	f	class:apf::Frame
forTranslation	apf/apfGeometry.cc	/^Frame Frame::forTranslation(Vector3 const& t)$/;"	f	class:apf::Frame
for_type_net	mds/mds_net.c	/^static void for_type_net(struct mds_net* net, struct mds* m,$/;"	f	file:
forcing	test/poisson.cc	/^static double forcing(apf::Vector3 const& p, int d) {$/;"	f	namespace:__anon17
forgetNewEntities	ma/maRefine.cc	/^void forgetNewEntities(Refine* r)$/;"	f	namespace:ma
formCountMap	apf/apfMesh.cc	/^void MatchedSharing::formCountMap()$/;"	f	class:apf::MatchedSharing
formEdges	phasta/phInput.h	/^    int formEdges;$/;"	m	class:ph::Input
formElementGraph	phasta/phInput.h	/^    int formElementGraph;$/;"	m	class:ph::Input
formFactories	phasta/phAttrib.cc	/^static void formFactories(BCFactories& fs)$/;"	f	file:
formIENNEIGH	phasta/phLinks.cc	/^int* formIENNEIGH(apf::Numbering* ln)$/;"	f	namespace:ph
formMaps	phasta/phInput.cc	/^static void formMaps(Input& in, StringMap& stringMap, IntMap& intMap, DblMap& dblMap)$/;"	f	namespace:ph
formModelTable	mds/apfBox.cc	/^void BoxBuilder::formModelTable()$/;"	f	class:apf::BoxBuilder
foundAnything	ma/maLayerSnap.cc	/^  bool foundAnything;$/;"	m	struct:ma::UnsnapChecker	file:
found_bad_arg	phasta/ph_convert.cc	/^bool found_bad_arg = false;$/;"	v
found_bad_arg	test/convert.cc	/^bool found_bad_arg = false;$/;"	v
found_bad_arg	test/rm_extrusion.cc	/^bool found_bad_arg = false;$/;"	v
fp	apf/apfVtk.cc	/^    std::ostream* fp;$/;"	m	class:apf::WriteIPField	file:
frameEval	ma/maSize.cc	/^  FrameEval frameEval;$/;"	m	struct:ma::AnisoSizeField	file:
free	mds/mds.h	/^  mds_id* free[MDS_TYPES];$/;"	m	struct:mds
freeEntry	pumi/GenTag.cc	/^static void freeEntry(Entry* e)$/;"	f	file:
freeIter	mds/apfMDS.cc	/^static void freeIter(MeshIterator* it)$/;"	f	namespace:apf
freeMesh	phasta/adaptLvlSet_loop.cc	/^  void freeMesh(apf::Mesh* m) {$/;"	f	namespace:__anon83
freeMesh	phasta/chef.cc	/^  void freeMesh(apf::Mesh* m) {$/;"	f	namespace:__anon88
freeMesh	phasta/chefStream.cc	/^  void freeMesh(apf::Mesh* m) {$/;"	f	namespace:__anon84
freeMesh	phasta/migrate_interface.cc	/^void freeMesh(apf::Mesh* m)$/;"	f	namespace:__anon78
freeMesh	phasta/readUrPrep.cc	/^  void freeMesh(apf::Mesh* m) {$/;"	f	namespace:__anon89
freeMesh	test/fieldReduce.cc	/^void freeMesh(apf::Mesh* m)$/;"	f	namespace:__anon15
freeMesh	test/ghost.cc	/^  void freeMesh(apf::Mesh* m)$/;"	f	namespace:__anon11
freeMesh	test/ghostEdge.cc	/^  void freeMesh(apf::Mesh* m)$/;"	f	namespace:__anon12
freeMesh	test/ghostMPAS.cc	/^  void freeMesh(apf::Mesh* m)$/;"	f	namespace:__anon9
freeMesh	test/ptnParma.cc	/^void freeMesh(apf::Mesh* m)$/;"	f	namespace:__anon10
freeMesh	test/repartition.cc	/^void freeMesh(apf::Mesh* m)$/;"	f	namespace:__anon22
freeMesh	test/split.cc	/^void freeMesh(apf::Mesh* m)$/;"	f	namespace:__anon13
freeMesh	test/viz.cc	/^  void freeMesh(apf::Mesh* m)$/;"	f	namespace:__anon2
freeMesh	test/writeVtxPtn.cc	/^  void freeMesh(apf::Mesh* m)$/;"	f	namespace:__anon1
freeMesh	test/zsplit.cc	/^void freeMesh(apf::Mesh* m)$/;"	f	namespace:__anon4
freeReader	mds/mdsGmsh.cc	/^void freeReader(Reader* r)$/;"	f	namespace:__anon96
freeReader	mds/mdsUgrid.cc	/^  void freeReader(Reader* r) {$/;"	f	namespace:__anon101
freeStkNumberings	stk/apfMeshSTK.cc	/^void freeStkNumberings(Mesh* m, GlobalNumbering* n[4])$/;"	f	namespace:apf
free_bdrys	gmi/agm.c	/^static void free_bdrys(struct bdrys* b)$/;"	f	file:
free_comm	pcu/pcu_msg.c	/^static void free_comm(pcu_msg* m)$/;"	f	file:
free_ctors	gmi/gmi.c	/^static void free_ctors(void)$/;"	f	file:
free_ent	mds/mds.c	/^static void free_ent(struct mds* m, mds_id e)$/;"	f	file:
free_ents	gmi/agm.c	/^static void free_ents(struct ents* e)$/;"	f	file:
free_message	pcu/pcu_order.c	/^static void free_message(struct message* m)$/;"	f	file:
free_messages	pcu/pcu_order.c	/^static void free_messages(pcu_aa_tree* t)$/;"	f	file:
free_peers	pcu/pcu_msg.c	/^static void free_peers(pcu_aa_tree* t)$/;"	f	file:
free_queue	mds/mds_order.c	/^static void free_queue(struct queue* q)$/;"	f	file:
free_tag	gmi/agm.c	/^static void free_tag(struct agm_tag* t)$/;"	f	file:
free_tags	gmi/agm.c	/^static void free_tags(struct agm_tags* t)$/;"	f	file:
free_uses	gmi/agm.c	/^static void free_uses(struct uses* u)$/;"	f	file:
freeze	apf/apf.cc	/^void freeze(Field* f)$/;"	f	namespace:apf
freezeFieldData	apf/apfArrayData.cc	/^void freezeFieldData(FieldBase* field)$/;"	f	namespace:apf
freezeLayer	ma/maLayer.cc	/^void freezeLayer(Adapt* a)$/;"	f	namespace:ma
from	apf/apfFieldData.cc	/^    FieldDataOf<T>* from;$/;"	m	class:apf::CopyOp	file:
from	apf/apfFieldData.cc	/^    FieldDataOf<T>* from;$/;"	m	class:apf::MultiplyOp	file:
from	apf/apfFieldOf.cc	/^    FieldOf<T>* from;$/;"	m	class:apf::Project	file:
from	apf/apfHierarchic.cc	/^    FieldOf<T>* from;$/;"	m	class:apf::Projector	file:
from	pcu/pcu_order.c	/^  int from;$/;"	m	struct:message	file:
from1	apf/apfFieldData.cc	/^    FieldDataOf<T>* from1;$/;"	m	class:apf::AddOp	file:
from2	apf/apfFieldData.cc	/^    FieldDataOf<T>* from2;$/;"	m	class:apf::AddOp	file:
fromArray	apf/apfVector.h	/^    void fromArray(const double* abc)$/;"	f	class:apf::Vector3
fromArray	mth/mthVector.h	/^    void fromArray(T const* abc)$/;"	f	class:mth::Vector3
fromElem	apf/apfHierarchic.cc	/^    ElementOf<T>* fromElem;$/;"	m	class:apf::Projector	file:
fromElement	apf/apfFieldOf.cc	/^    ElementOf<T>* fromElement;$/;"	m	class:apf::Project	file:
fromEnt	mds/apfMDS.cc	/^static mds_id fromEnt(MeshEntity* e)$/;"	f	namespace:apf
fromEntity	apf_cap/apfCAP.cc	/^M_MTopo fromEntity(MeshEntity* e)$/;"	f	namespace:apf
fromGmiEntity	gmi_cap/gmi_cap.cc	/^M_GTopo fromGmiEntity(gmi_ent* g)$/;"	f
fromIter	mds/apfMDS.cc	/^static mds_id fromIter(MeshIterator* it)$/;"	f	namespace:apf
fromMatrix	apf/apfDynamicMatrix.h	/^inline DynamicMatrix fromMatrix(Matrix<N,M> other)$/;"	f	namespace:apf
fromPoints	apf/apfGeometry.cc	/^Plane Plane::fromPoints(Vector3 const& a,$/;"	f	class:apf::Plane
fromVector	apf/apfDynamicVector.h	/^inline DynamicVector fromVector(Vector<N> other)$/;"	f	namespace:apf
fromVectors	test/eigen_test.cc	/^static void fromVectors(apf::Matrix3x3 & ev, apf::Vector3 & ew,$/;"	f	file:
from_dmg	gmi/gmi_mesh.c	/^static struct gmi_model* from_dmg(const char* filename)$/;"	f	file:
from_omega_h	omega_h/apfOmega_h.cc	/^void from_omega_h(apf::Mesh2* am, osh::Mesh* om)$/;"	f	namespace:apf
from_tess	gmi/gmi_mesh.c	/^static struct gmi_model* from_tess(const char* filename)$/;"	f	file:
ftnToC	mds/mdsUgrid.cc	/^  int ftnToC(long id) {$/;"	f	namespace:__anon101
full	parma/diffMC/parma_monitor.cc	/^  bool CircBuffer::full() { return (sz==len); }$/;"	f	class:parma::CircBuffer
function	apf/apfUserData.h	/^  Function* function;$/;"	m	struct:apf::UserData
function	ma/maSize.cc	/^  AnisotropicFunction* function;$/;"	m	struct:ma::BothEval	file:
function	ma/maSize.cc	/^  AnisotropicFunction* function;$/;"	m	struct:ma::LogMEval	file:
function	ma/maSize.cc	/^  IsotropicFunction* function;$/;"	m	struct:ma::IsoWrapper	file:
function	test/hierarchic.cc	/^static double function(int p_order, int d, apf::Vector3 const& p) {$/;"	f	namespace:__anon20
fusionAdapt	test/fusion.cc	/^static void fusionAdapt(apf::Mesh2* m)$/;"	f	file:
g	pumi/pumi.h	/^  gmi_model* g; $/;"	m	class:gModel
gEntities	pumi/mPartEntityContainer.h	/^    List gEntities[_DIMS_];$/;"	m	class:mPartEntityContainer
gEntities_map	pumi/mPartEntityContainer.h	/^    std::map<gmi_ent*, gEntity*> gEntities_map[_DIMS_]; \/\/ gmi_ent to gEntity$/;"	m	class:mPartEntityContainer
gEntity	pumi/mPartEntityContainer.h	/^class gEntity : public Taggable, public ListMember$/;"	c
gEntity	pumi/pumi_gentity.cc	/^gEntity::gEntity(gmi_ent* ent) : Taggable()$/;"	f	class:gEntity
gIter	pumi/pumi.h	/^typedef GenIterator<mPartEntityContainer::iter, gEntity>* gIter;$/;"	t
gModel	pumi/pumi.h	/^class gModel : public TagHolder$/;"	c
gModel	pumi/pumi_geom.cc	/^gModel::gModel(gmi_model* model) : TagHolder() $/;"	f	class:gModel
gSz	phasta/phstream.cc	/^    size_t gSz, rSz;$/;"	m	struct:GRStream	file:
g_index	crv/crvBezier.cc	/^static int g_index[3][2] = {{2,1},{0,2},{1,0}};$/;"	m	namespace:crv	file:
g_pairs	crv/crvBezier.cc	/^static int g_pairs[3][2] = {{0,5},{1,3},{2,4}};$/;"	m	namespace:crv	file:
gammaDist	phasta/phInput.h	/^    double gammaDist;$/;"	m	class:ph::Input
gammaSize	phasta/phInput.h	/^    double gammaSize;$/;"	m	class:ph::Input
gatherBaseFields	ma/maExtrude.cc	/^Fields gatherBaseFields(Mesh* m) {$/;"	f	namespace:ma::__anon28
gatherExtrudedFieldData	ma/maExtrude.cc	/^FieldData gatherExtrudedFieldData(DataGetter const& getter,$/;"	f	namespace:ma::__anon28
gatherExtrudedFields	ma/maExtrude.cc	/^Fields gatherExtrudedFields(Mesh* m) {$/;"	f	namespace:ma::__anon28
gatherExtrudedFieldsData	ma/maExtrude.cc	/^AllFieldsData gatherExtrudedFieldsData(Mesh* m, Layers const& layers,$/;"	f	namespace:ma::__anon28
gatherFlatFieldData	ma/maExtrude.cc	/^FieldData gatherFlatFieldData(Mesh* m, std::string const& extruded_name,$/;"	f	namespace:ma::__anon28
gatherFlatFieldsData	ma/maExtrude.cc	/^AllFieldsData gatherFlatFieldsData(Mesh* m, Fields const& base_fields,$/;"	f	namespace:ma::__anon28
gcflt	phasta/phOutput.h	/^  double* gcflt;$/;"	m	struct:ph::EnsaArrays
gcgr	phasta/phOutput.h	/^  double* gcgr;$/;"	m	struct:ph::EnsaArrays
generate	test/generate.cc	/^pParMesh generate(pGModel mdl, std::string meshCaseName) {$/;"	f	namespace:__anon19
generateGlobalIdsToEnts	stk/apfSTK.cc	/^static void generateGlobalIdsToEnts($/;"	f	namespace:apf
generateOutput	phasta/phOutput.cc	/^void generateOutput(Input& in, BCs& bcs, apf::Mesh* mesh, Output& o)$/;"	f	namespace:ph
generateRandomNumber	parma/diffMC/maximalIndependentSet/misLuby.cc	/^  int generateRandomNumber() {$/;"	f	namespace:__anon50
generate_globalid	pumi/pumi_mesh.cc	/^void generate_globalid(pMesh m, pMeshTag tag, int dim, pOwnership o)$/;"	f
geom	phasta/phstream.cc	/^    char *geom, *restart;$/;"	m	struct:GRStream	file:
geomInterface	apf_cap/apfCAP.h	/^    GeometryDatabaseInterface  *geomInterface;$/;"	m	class:apf::MeshCAP
geomInterface	gmi_cap/gmi_cap.cc	/^  GeometryDatabaseInterface* geomInterface;$/;"	m	struct:cap_model	file:
get	apf/apfArrayData.cc	/^    virtual void get(MeshEntity* e, T* data)$/;"	f	class:apf::ArrayDataOf
get	apf/apfCoordData.cc	/^void CoordData::get(MeshEntity* e, double* data)$/;"	f	class:apf::CoordData
get	apf/apfMesh.cc	/^MeshEntity* Migration::get(int i)$/;"	f	class:apf::Migration
get	apf/apfNumbering.cc	/^T NumberingOf<T>::get(MeshEntity* e, int node, int component)$/;"	f	class:apf::NumberingOf
get	apf/apfTagData.h	/^    virtual void get(MeshEntity* e, T* data)$/;"	f	class:apf::TagDataOf
get	apf/apfTagData.h	/^    void get(Mesh* m, MeshEntity* e, MeshTag* t, double* data)$/;"	f	class:apf::TagHelper
get	apf/apfTagData.h	/^    void get(Mesh* m, MeshEntity* e, MeshTag* t, int* data)$/;"	f	class:apf::TagHelper
get	apf/apfTagData.h	/^    void get(Mesh* m, MeshEntity* e, MeshTag* t, long* data)$/;"	f	class:apf::TagHelper
get	apf/apfUserData.cc	/^void UserData::get(MeshEntity* e, double* data)$/;"	f	class:apf::UserData
get	apf_cap/apfCAP.cc	/^    void get(MeshEntity* e, double* p)$/;"	f	class:apf::DoubleTagCAP
get	apf_cap/apfCAP.cc	/^    void get(MeshEntity* e, int* p)$/;"	f	class:apf::IntTagCAP
get	apf_cap/apfCAP.cc	/^    void* get(MeshEntity* e)$/;"	f	class:apf::TagCAP
get	apf_sim/apfSIM.cc	/^    void get(MeshEntity* e, double* p)$/;"	f	class:apf::DoubleTagSIM
get	apf_sim/apfSIM.cc	/^    void get(MeshEntity* e, int* p)$/;"	f	class:apf::IntTagSIM
get	apf_sim/apfSIM.cc	/^    void get(MeshEntity* e, long* p)$/;"	f	class:apf::LongTagSIM
get	apf_sim/apfSIM.cc	/^    void* get(MeshEntity* e)$/;"	f	class:apf::TagSIM
get	apf_sim/apfSIMDataOf.h	/^  virtual void get(MeshEntity * e, T * data)$/;"	f	class:apf::SIMDataOf
get	ma/maExtrude.cc	/^  virtual void get(Entity* e, double* data_out) const {$/;"	f	struct:ma::__anon28::FieldDataGetter
get	ma/maExtrude.cc	/^  virtual void get(Entity* v, double* data_out) const {$/;"	f	struct:ma::__anon28::ZDataGetter
get	parma/diffMC/parma_associative.h	/^      T get(int key) {$/;"	f	class:parma::Associative
get	parma/diffMC/parma_centroidSelector.cc	/^      double get(apf::MeshEntity* e, int to) {$/;"	f	class:__anon49::Distance
get	parma/diffMC/parma_monitor.cc	/^  double CircBuffer::get(unsigned int item) { $/;"	f	class:parma::CircBuffer
get	stk/apfSTK.cc	/^StkBridge* StkBridge::get($/;"	f	class:apf::StkBridge
get	zoltan/apfZoltanCallbacks.cc	/^static long get(MeshEntity* e, ZoltanMesh *zz)$/;"	f	namespace:apf
getAccuracy	apf/apfIntegrate.cc	/^        virtual int getAccuracy() const {return 11;}$/;"	f	class:apf::EdgeIntegration::N6
getAccuracy	apf/apfIntegrate.cc	/^        virtual int getAccuracy() const {return 1;} \/\/sort of$/;"	f	class:apf::PyramidIntegration::N1
getAccuracy	apf/apfIntegrate.cc	/^        virtual int getAccuracy() const {return 1;}$/;"	f	class:apf::EdgeIntegration::N1
getAccuracy	apf/apfIntegrate.cc	/^        virtual int getAccuracy() const {return 1;}$/;"	f	class:apf::HexahedronIntegration::N1
getAccuracy	apf/apfIntegrate.cc	/^        virtual int getAccuracy() const {return 1;}$/;"	f	class:apf::PrismIntegration::N1
getAccuracy	apf/apfIntegrate.cc	/^        virtual int getAccuracy() const {return 1;}$/;"	f	class:apf::QuadIntegration::N1
getAccuracy	apf/apfIntegrate.cc	/^        virtual int getAccuracy() const {return 1;}$/;"	f	class:apf::TetrahedronIntegration::N1
getAccuracy	apf/apfIntegrate.cc	/^        virtual int getAccuracy() const {return 1;}$/;"	f	class:apf::TriangleIntegration::N1
getAccuracy	apf/apfIntegrate.cc	/^        virtual int getAccuracy() const {return 2;}$/;"	f	class:apf::TetrahedronIntegration::N2
getAccuracy	apf/apfIntegrate.cc	/^        virtual int getAccuracy() const {return 2;}$/;"	f	class:apf::TriangleIntegration::N2
getAccuracy	apf/apfIntegrate.cc	/^        virtual int getAccuracy() const {return 3;}$/;"	f	class:apf::EdgeIntegration::N2
getAccuracy	apf/apfIntegrate.cc	/^        virtual int getAccuracy() const {return 3;}$/;"	f	class:apf::HexahedronIntegration::N2
getAccuracy	apf/apfIntegrate.cc	/^        virtual int getAccuracy() const {return 3;}$/;"	f	class:apf::QuadIntegration::N2
getAccuracy	apf/apfIntegrate.cc	/^        virtual int getAccuracy() const {return 3;}$/;"	f	class:apf::TetrahedronIntegration::N3
getAccuracy	apf/apfIntegrate.cc	/^        virtual int getAccuracy() const {return 3;}$/;"	f	class:apf::TriangleIntegration::N3
getAccuracy	apf/apfIntegrate.cc	/^        virtual int getAccuracy() const {return 4;}$/;"	f	class:apf::TetrahedronIntegration::N4
getAccuracy	apf/apfIntegrate.cc	/^        virtual int getAccuracy() const {return 4;}$/;"	f	class:apf::TriangleIntegration::N4
getAccuracy	apf/apfIntegrate.cc	/^        virtual int getAccuracy() const {return 5;}$/;"	f	class:apf::EdgeIntegration::N3
getAccuracy	apf/apfIntegrate.cc	/^        virtual int getAccuracy() const {return 5;}$/;"	f	class:apf::QuadIntegration::N3
getAccuracy	apf/apfIntegrate.cc	/^        virtual int getAccuracy() const {return 5;}$/;"	f	class:apf::TetrahedronIntegration::N5
getAccuracy	apf/apfIntegrate.cc	/^        virtual int getAccuracy() const {return 5;}$/;"	f	class:apf::TriangleIntegration::N5
getAccuracy	apf/apfIntegrate.cc	/^        virtual int getAccuracy() const {return 6;}$/;"	f	class:apf::TetrahedronIntegration::N6
getAccuracy	apf/apfIntegrate.cc	/^        virtual int getAccuracy() const {return 6;}$/;"	f	class:apf::TriangleIntegration::N6
getAccuracy	apf/apfIntegrate.cc	/^        virtual int getAccuracy() const {return 7;}$/;"	f	class:apf::EdgeIntegration::N4
getAccuracy	apf/apfIntegrate.cc	/^        virtual int getAccuracy() const {return 7;}$/;"	f	class:apf::TetrahedronIntegration::N7
getAccuracy	apf/apfIntegrate.cc	/^        virtual int getAccuracy() const {return 9;}$/;"	f	class:apf::EdgeIntegration::N5
getAccurate	apf/apfIntegrate.cc	/^Integration const* EntityIntegration::getAccurate(int minimumAccuracy) const$/;"	f	class:apf::EntityIntegration
getAdapt	ma/maCoarsen.cc	/^    Adapt* getAdapt() {return collapse.adapt;}$/;"	f	class:ma::AllEdgeCollapser
getAdapt	ma/maCoarsen.cc	/^    Adapt* getAdapt() {return collapse.adapt;}$/;"	f	class:ma::CollapseChecker
getAdapt	ma/maCoarsen.cc	/^    Adapt* getAdapt() {return collapse.adapt;}$/;"	f	class:ma::MatchedEdgeCollapser
getAdapt	ma/maDoubleSplitCollapse.cc	/^Adapt* DoubleSplitCollapse::getAdapt()$/;"	f	class:ma::DoubleSplitCollapse
getAdapt	ma/maFaceSplit.h	/^    Adapt* getAdapt() {return adapter;}$/;"	f	class:ma::FaceSplit
getAdapt	ma/maFaceSplitCollapse.cc	/^  Adapt* FaceSplitCollapse::getAdapt()$/;"	f	class:ma::FaceSplitCollapse
getAdapt	ma/maSplits.h	/^    Adapt* getAdapt() {return refiner->adapt;}$/;"	f	class:ma::Splits
getAdjacent	apf_cap/apfCAP.cc	/^void MeshCAP::getAdjacent(MeshEntity* e,$/;"	f	class:apf::MeshCAP
getAdjacent	apf_sim/apfSIM.cc	/^void MeshSIM::getAdjacent(MeshEntity* e,$/;"	f	class:apf::MeshSIM
getAdjacent	mds/apfMDS.cc	/^    void getAdjacent(MeshEntity* e, int dimension, Adjacent& adjacent)$/;"	f	class:apf::MeshMDS
getAdjacent	pumi/pumi_gentity.cc	/^void getAdjacent (pGeom g, pGeomEnt ge, int target_dim, std::set<pGeomEnt>& result)$/;"	f
getAdjacentElements	parma/diffMC/parma_centroidSelector.cc	/^  int getAdjacentElements(apf::Mesh* m, apf::MeshEntity* e, apf::Downward oe) {$/;"	f	namespace:__anon49
getAdjacentParts	mds/apfPM.cc	/^static void getAdjacentParts(apf::Mesh* m, PM& ps, apf::Parts& ids)$/;"	f	namespace:apf
getAffected	apf/apfMigrate.cc	/^static void getAffected($/;"	f	namespace:apf
getAlignment	apf/apfMesh.cc	/^void getAlignment(Mesh* m, MeshEntity* elem, MeshEntity* boundary,$/;"	f	namespace:apf
getAll	apf/apfNumbering.cc	/^void NumberingOf<T>::getAll(MeshEntity* e, T* dat)$/;"	f	class:apf::NumberingOf
getAllBlocks	phasta/phBlock.cc	/^void getAllBlocks(apf::Mesh* m, BCs& bcs, AllBlocks& b)$/;"	f	namespace:ph
getAllCopies	apf/apfVerify.cc	/^static Copies getAllCopies(Mesh* m, MeshEntity* e)$/;"	f	namespace:apf
getAllowedDiagonals	ma/maTetrahedronize.cc	/^  int getAllowedDiagonals()$/;"	f	struct:ma::UnsafePrismOverride
getAmbiguousTri	ma/maLayerRefine.cc	/^static bool getAmbiguousTri(Adapt* a, Entity* t, Entity** v)$/;"	f	namespace:ma
getAngle	apf/apfGeometry.cc	/^double getAngle(Vector3 const& a, Vector3 const& b)$/;"	f	namespace:apf
getAngleBC	phasta/phAxisymmetry.cc	/^static double* getAngleBC(gmi_model* gm, BCs& bcs, gmi_ent* e)$/;"	f	namespace:ph
getAnyPointOnFace	phasta/phModelGeometry.cc	/^apf::Vector3 getAnyPointOnFace(gmi_model* gm, gmi_ent* f)$/;"	f	namespace:ph
getArgs	test/box.cc	/^void getArgs(char** argv)$/;"	f	namespace:__anon8
getArrayData	apf/apfArrayData.cc	/^double* getArrayData(Field* f) {$/;"	f	namespace:apf
getAttributeMatching	phasta/phFilterMatching.cc	/^static void getAttributeMatching(gmi_model* gm, BCs& bcs, ModelMatching& mm)$/;"	f	namespace:ph
getAverageEdgeLength	ma/maSize.cc	/^double getAverageEdgeLength(Mesh* m)$/;"	f	namespace:ma
getAverageElementSize	ma/maMesh.cc	/^double getAverageElementSize(Mesh* m)$/;"	f	namespace:ma
getAveragePartDensity	phasta/phAdapt.cc	/^static double getAveragePartDensity(apf::Mesh* m) {$/;"	f	namespace:ph
getAvg	parma/extractParmaResults.py	/^getAvg = lambda s: float(s.split()[-1])$/;"	v
getAvgWeight	parma/diffMC/parma_entWeights.cc	/^  double getAvgWeight(apf::Mesh* m, apf::MeshTag* w, int entDim) {$/;"	f	namespace:parma
getAxisymmetry	phasta/phAxisymmetry.cc	/^bool getAxisymmetry(gmi_model* gm, gmi_ent* f, gmi_ent* of,$/;"	f	namespace:ph
getBCValue	phasta/phBC.cc	/^double* getBCValue(gmi_model* gm, FieldBCs& bcs, gmi_ent* ge,$/;"	f	namespace:ph
getBF	apf/apf.cc	/^void getBF(FieldShape* s, MeshElement* e, Vector3 const& p,$/;"	f	namespace:apf
getBase	ma/maExtrude.cc	/^Crawler::Layer getBase(Mesh* m, ModelSet const& bottoms, int d)$/;"	f	namespace:ma::__anon28
getBase64Char	lion/lionBase64.cc	/^unsigned char getBase64Char (int index)$/;"	f	namespace:lion
getBdry	parma/diffMC/parma_components.cc	/^  Level* DCC::getBdry(unsigned i) { PCU_ALWAYS_ASSERT(i<n); return &(bdry[i]); }$/;"	f	class:parma::DCC
getBdryVtx	parma/diffMC/parma_graphDist.cc	/^  void getBdryVtx(apf::Mesh* m, apf::MeshTag* dist,$/;"	f	namespace:__anon74
getBestElement	ma/maSolutionTransfer.cc	/^    int getBestElement($/;"	f	class:ma::CavityTransfer
getBezier	crv/crvBezier.cc	/^apf::FieldShape* getBezier(int order)$/;"	f	namespace:crv
getBezierEdgePoint	ma/maQuality.cc	/^static Vector getBezierEdgePoint($/;"	f	namespace:ma
getBezierJacobianDetSubdivisionCoefficients	crv/crvBezierPoints.cc	/^void getBezierJacobianDetSubdivisionCoefficients(int P, int type,$/;"	f	namespace:crv
getBezierNodeXi	crv/crvBezierPoints.cc	/^void getBezierNodeXi(int type, int P, int node, apf::Vector3& xi)$/;"	f	namespace:crv
getBezierTransformationCoefficients	crv/crvBezierPoints.cc	/^void getBezierTransformationCoefficients(int P, int type,$/;"	f	namespace:crv
getBezierTransformationMatrix	crv/crvBezierShapes.cc	/^void getBezierTransformationMatrix(int parentType,$/;"	f	namespace:crv
getBezierTransformationMatrix	crv/crvBezierShapes.cc	/^void getBezierTransformationMatrix(int type, int P,$/;"	f	namespace:crv
getBisectionNormal	parma/rib/parma_rib.cc	/^static mth::Vector3<double> getBisectionNormal(Bodies const* b)$/;"	f	namespace:parma
getBlendedGregoryTetTransform	crv/crvG1Points.cc	/^static void getBlendedGregoryTetTransform(int blend,$/;"	f	namespace:crv
getBlendedGregoryTriangleTransform	crv/crvG1Points.cc	/^static void getBlendedGregoryTriangleTransform(int blend,$/;"	f	namespace:crv
getBlendingOrder	crv/crvBlended.cc	/^int getBlendingOrder(const int type)$/;"	f	namespace:crv
getBlockKeyCommon	phasta/phBlock.cc	/^static void getBlockKeyCommon(apf::Mesh* m, apf::MeshEntity* e, BlockKey& k)$/;"	f	namespace:ph
getBlockKeyPhrase	phasta/phBlock.cc	/^std::string getBlockKeyPhrase$/;"	f	namespace:ph
getBlockKeyPhraseInterface	phasta/phBlock.cc	/^std::string getBlockKeyPhraseInterface$/;"	f	namespace:ph
getBool	parma/diffMC/maximalIndependentSet/test/testMIS.cc	/^bool getBool(int& isDebug) {$/;"	f
getBottomModels	ma/maExtrude.cc	/^void getBottomModels(ModelExtrusions const& model_extrusions,$/;"	f	namespace:ma::__anon28
getBoundary	phasta/phOutput.cc	/^static void getBoundary(Output& o, BCs& bcs, apf::Numbering* n)$/;"	f	namespace:ph
getBoundaryBlockKey	phasta/phBlock.cc	/^void getBoundaryBlockKey(apf::Mesh* m, apf::MeshEntity* e,$/;"	f	namespace:ph
getBoundaryBlocks	phasta/phBlock.cc	/^void getBoundaryBlocks(apf::Mesh* m, BCs& bcs, Blocks& b)$/;"	f	namespace:ph
getBoundaryConnectivity	phasta/phGeomBC.cc	/^void getBoundaryConnectivity(Output& o, int block, apf::DynamicArray<int>& c)$/;"	f	namespace:ph
getBoundaryElements	phasta/phOutput.cc	/^static void getBoundaryElements(Output& o)$/;"	f	namespace:ph
getBoundaryMaterialType	phasta/phGeomBC.cc	/^void getBoundaryMaterialType$/;"	f	namespace:ph
getBoundaryVertices	phasta/phAdjacent.cc	/^void getBoundaryVertices(apf::Mesh* m, apf::MeshEntity* e, apf::MeshEntity* f,$/;"	f	namespace:ph
getBoundingBox	ma/maMesh.cc	/^void getBoundingBox(Mesh* m, Vector& lower, Vector& upper)$/;"	f	namespace:ma
getBridgeAdjacent	apf/apfMesh.cc	/^void getBridgeAdjacent(Mesh* m, MeshEntity* origin,$/;"	f	namespace:apf
getBytes	pumi/GenTag.h	/^    size_t getBytes() {return bytes;}$/;"	f	class:TagHandle
getCachedQuality	ma/maAdapt.cc	/^double getCachedQuality(Adapt* a, Entity* e)$/;"	f	namespace:ma
getCandidateEdges	ma/maSnapper.cc	/^void FirstProblemPlane::getCandidateEdges(std::vector<Entity*> &edges)$/;"	f	class:ma::FirstProblemPlane
getCandidateParts	apf/apfMesh2.cc	/^static void getCandidateParts(Mesh* m, MeshEntity* e, Parts& parts)$/;"	f	namespace:apf
getCandidateParts	apf/apfVerify.cc	/^static Parts getCandidateParts(Mesh* m, MeshEntity* e)$/;"	f	namespace:apf
getCapGeomType	apf_cap/apfCAP.cc	/^static GeometryTopoType getCapGeomType(int d)$/;"	f	namespace:apf
getCapShape	apf_cap/apfCAP.cc	/^static MeshShape getCapShape(int type)$/;"	f	namespace:apf
getCavity	parma/diffMC/parma_dijkstra.cc	/^  void getCavity(apf::Mesh* m, apf::MeshEntity* v, apf::Up& cavity) {$/;"	f	namespace:__anon70
getCavity	parma/diffMC/parma_shapeSelector.cc	/^  void getCavity(apf::Mesh* m, apf::MeshEntity* v, apf::Migration* plan,$/;"	f	namespace:__anon57
getCavity	parma/diffMC/parma_vtxSelector.cc	/^  void getCavity(apf::Mesh* m, apf::MeshEntity* v, apf::Migration* plan,$/;"	f	namespace:__anon59
getCavityEdges	parma/diffMC/parma_dijkstra.cc	/^  CavEnts* getCavityEdges(apf::Mesh* m, parma::DijkstraContains* c, $/;"	f	namespace:__anon70
getCavityFaces	parma/diffMC/parma_vtxSelector.cc	/^  meu* getCavityFaces(apf::Mesh* m, apf::Up& cavity) {$/;"	f	namespace:__anon59
getCavityPeers	parma/diffMC/parma_shapeSelector.cc	/^  void getCavityPeers(apf::Mesh* m, apf::MeshEntity* v, UintArr* peers) {$/;"	f	namespace:__anon57
getCavityPeers	parma/diffMC/parma_vtxSelector.cc	/^  UintArr* getCavityPeers(apf::Mesh* m, apf::MeshEntity* v) {$/;"	f	namespace:__anon59
getCellTopology	stk/apfSTK.cc	/^const CellTopologyData* getCellTopology(Mesh* m)$/;"	f	namespace:apf
getCenter	ma/maSnapper.cc	/^Vector getCenter(Mesh* mesh, Entity* face)$/;"	f	namespace:ma
getCenter	phasta/phModelGeometry.cc	/^apf::Vector3 getCenter(gmi_model* gm, gmi_ent* e)$/;"	f	namespace:ph
getCenterOfGravity	parma/rib/parma_rib.cc	/^static mth::Vector3<double> getCenterOfGravity(Bodies const* b)$/;"	f	namespace:parma
getCentroid	ma/maMesh.cc	/^Vector getCentroid(Mesh* m)$/;"	f	namespace:ma
getCentroid	zoltan/apfZoltanCallbacks.cc	/^void getCentroid(void *data, int, int,$/;"	f	namespace:apf
getClosestPair	ma/maAdapt.cc	/^int getClosestPair(Adapt* a, Entity* (*pairs)[2], int n)$/;"	f	namespace:ma
getClosestPoint	apf/apfMesh.cc	/^void Mesh::getClosestPoint(ModelEntity* g, Vector3 const& from,$/;"	f	class:apf::Mesh
getClosestPointParametricCoordinates	ma/maSnap.cc	/^void getClosestPointParametricCoordinates($/;"	f	namespace:ma
getClosestPointParametricCoordinates	ma/maSnap_mohara.cc	/^void getClosestPointParametricCoordinates($/;"	f	namespace:ma
getClosestPtIdx	apf/apfIPShape.cc	/^        int getClosestPtIdx(Vector3 const& p) const$/;"	f	class:apf::VoronoiShape::Element
getClosureEntitiesWithNodes	apf/apfNumbering.cc	/^static void getClosureEntitiesWithNodes($/;"	f	namespace:apf
getCofactor	apf/apfMatrix.cc	/^double getCofactor(Matrix<M,N> const& A, std::size_t i, std::size_t j)$/;"	f	namespace:apf
getColumn	apf/apfDynamicMatrix.h	/^    void getColumn(std::size_t j, DynamicVector& r) const$/;"	f	class:apf::DynamicMatrix
getColumns	apf/apfDynamicMatrix.h	/^    std::size_t getColumns() const {return columns;}$/;"	f	class:apf::DynamicMatrix
getCompPeer	parma/diffMC/parma_dcpart.cc	/^unsigned dcPart::getCompPeer(unsigned i) {$/;"	f	class:dcPart
getCompSize	parma/diffMC/parma_dcpart.cc	/^unsigned dcPart::getCompSize(unsigned i) {$/;"	f	class:dcPart
getComponents	apf/apf.cc	/^void getComponents(Element* e, Vector3 const& param, double* components)$/;"	f	namespace:apf
getComponents	apf/apf.cc	/^void getComponents(Field* f, MeshEntity* e, int node, double* components)$/;"	f	namespace:apf
getComponents	apf/apfElement.cc	/^void Element::getComponents(Vector3 const& xi, double* c)$/;"	f	class:apf::Element
getConfig	phasta/migrate_interface.cc	/^void getConfig(int argc, char** argv)$/;"	f	namespace:__anon78
getConfig	phasta/ph_convert.cc	/^void getConfig(int argc, char** argv) {$/;"	f
getConfig	test/collapse.cc	/^  void getConfig(int argc, char** argv)$/;"	f	namespace:__anon6
getConfig	test/convert.cc	/^void getConfig(int argc, char** argv) {$/;"	f
getConfig	test/degenerateSurfs.cc	/^void getConfig(int argc, char** argv)$/;"	f
getConfig	test/fieldReduce.cc	/^void getConfig(int argc, char** argv)$/;"	f	namespace:__anon15
getConfig	test/generate.cc	/^void getConfig(int argc, char** argv) {$/;"	f	namespace:__anon19
getConfig	test/ghost.cc	/^  void getConfig(int argc, char** argv)$/;"	f	namespace:__anon11
getConfig	test/ghostEdge.cc	/^  void getConfig(int argc, char** argv)$/;"	f	namespace:__anon12
getConfig	test/ghostMPAS.cc	/^  void getConfig(int argc, char** argv)$/;"	f	namespace:__anon9
getConfig	test/ptnParma.cc	/^void getConfig(int argc, char** argv)$/;"	f	namespace:__anon10
getConfig	test/pumi.cc	/^void getConfig(int argc, char** argv)$/;"	f
getConfig	test/quality.cc	/^static void getConfig(int argc, char** argv)$/;"	f	namespace:__anon21
getConfig	test/repartition.cc	/^void getConfig(int argc, char** argv)$/;"	f	namespace:__anon22
getConfig	test/rm_extrusion.cc	/^void getConfig(int argc, char** argv) {$/;"	f
getConfig	test/split.cc	/^void getConfig(int argc, char** argv)$/;"	f	namespace:__anon13
getConfig	test/uniform.cc	/^void getConfig(int argc, char** argv)$/;"	f
getConfig	test/viz.cc	/^  void getConfig(int argc, char** argv)$/;"	f	namespace:__anon2
getConfig	test/writeVtxPtn.cc	/^  void getConfig(int argc, char** argv)$/;"	f	namespace:__anon1
getConfig	test/xgc_split.cc	/^void getConfig(int argc, char** argv)$/;"	f
getConfig	test/zsplit.cc	/^void getConfig(int argc, char** argv)$/;"	f	namespace:__anon4
getConnectedVtx	parma/diffMC/parma_dijkstra.cc	/^  void getConnectedVtx(apf::Mesh* m, parma::DijkstraContains* c, $/;"	f	namespace:__anon70
getConstant	apf/apfShape.cc	/^FieldShape* getConstant(int dimension)$/;"	f	namespace:apf
getCoordinateField	apf/apfMesh.h	/^    Field* getCoordinateField() {return coordinateField;}$/;"	f	class:apf::Mesh
getCoordinates	phasta/phOutput.cc	/^static void getCoordinates(Output& o)$/;"	f	namespace:ph
getCopies	apf/apfMesh.cc	/^void MatchedSharing::getCopies(MeshEntity* e,$/;"	f	class:apf::MatchedSharing
getCopies	apf/apfMesh.cc	/^void NormalSharing::getCopies(MeshEntity* e,$/;"	f	class:apf::NormalSharing
getCopies	apf/apfNumbering.cc	/^  virtual void getCopies(MeshEntity*, CopyArray&) {}$/;"	f	struct:apf::NoSharing
getCopies	phasta/phLinks.cc	/^  void getCopies(apf::MeshEntity* e,$/;"	f	struct:ph::PhastaSharing
getCopies	test/pumi.cc	/^  void getCopies(pMeshEnt e, CopyArray& copies)$/;"	f	struct:testOwnership
getCore	parma/diffMC/parma_components.cc	/^  Level* DCC::getCore(unsigned i) { PCU_ALWAYS_ASSERT(i<n); return &(core[i]); }$/;"	f	class:parma::DCC
getCore	parma/diffMC/parma_components.cc	/^  apf::MeshEntity* dcComponents::getCore(unsigned i) { return c->getCoreVtx(i); }$/;"	f	class:parma::dcComponents
getCoreVerts	parma/diffMC/parma_components.cc	/^  void DCC::getCoreVerts() {$/;"	f	class:parma::DCC
getCoreVtx	parma/diffMC/parma_components.cc	/^  apf::MeshEntity* DCC::getCoreVtx(unsigned i) {$/;"	f	class:parma::DCC
getCoreVtx	parma/diffMC/parma_components.cc	/^  void DCC::getCoreVtx() {$/;"	f	class:parma::DCC
getCount	test/test_integrator.cc	/^    unsigned int getCount() {return numEnt;}$/;"	f	class:CountIntegrator
getCountMap	mds/apfPM.cc	/^static void getCountMap(apf::Mesh* m, PM& ps, CountMap& mp)$/;"	f	namespace:apf
getCounts	phasta/phOutput.cc	/^static void getCounts(Output& o)$/;"	f	namespace:ph
getCrvSliverCode	crv/crvShapeFixer.cc	/^int getCrvSliverCode($/;"	f	namespace:crv
getCurl	apf/apf.cc	/^void getCurl(Element* e, Vector3 const& param, Vector3& c)$/;"	f	namespace:apf
getCurrentSize	spr/sprEstimateError.cc	/^static double getCurrentSize(apf::Mesh* m, apf::MeshEntity* e)$/;"	f	namespace:spr
getCurrentSize	spr/sprEstimateTargetError.cc	/^static double getCurrentSize(apf::Mesh* m, apf::MeshEntity* e)$/;"	f	namespace:spr::target
getDV	apf/apf.cc	/^double getDV(MeshElement* e, Vector3 const& param)$/;"	f	namespace:apf
getDV	apf/apfVectorElement.cc	/^double VectorElement::getDV(Vector3 const& xi)$/;"	f	class:apf::VectorElement
getData	apf/apfField.cc	/^FieldDataOf<double>* Field::getData()$/;"	f	class:apf::Field
getData	apf/apfField.h	/^    FieldData* getData() {return data;}$/;"	f	class:apf::FieldBase
getData	apf/apfNumbering.cc	/^FieldDataOf<T>* NumberingOf<T>::getData()$/;"	f	class:apf::NumberingOf
getDataArray	apf/apfArrayData.cc	/^    T* getDataArray() {$/;"	f	class:apf::ArrayDataOf
getDecodedBase64Char	lion/lionBase64.cc	/^unsigned char getDecodedBase64Char (unsigned char c)$/;"	f	namespace:lion
getDepth	parma/diffMC/parma_components.cc	/^  unsigned DCC::getDepth(unsigned i) { PCU_ALWAYS_ASSERT(i<n); return depth[i]; }$/;"	f	class:parma::DCC
getDesiredSize	spr/sprEstimateError.cc	/^static double getDesiredSize(Estimation* e, apf::MeshEntity* entity)$/;"	f	namespace:spr
getDeterminant	apf/apfMatrix.cc	/^double getDeterminant(Matrix<1,1> const& A)$/;"	f	namespace:apf
getDeterminant	apf/apfMatrix.cc	/^double getDeterminant(Matrix<M,N> const& A)$/;"	f	namespace:apf
getDgCopies	apf_cap/apfCAP.cc	/^void MeshCAP::getDgCopies(MeshEntity* e, DgCopies& dgCopies, ModelEntity* me)$/;"	f	class:apf::MeshCAP
getDgCopies	apf_sim/apfSIM.cc	/^void MeshSIM::getDgCopies(MeshEntity* e, DgCopies& dgCopies, ModelEntity* me)$/;"	f	class:apf::MeshSIM
getDgCopies	mds/apfMDS.cc	/^    void getDgCopies(MeshEntity* e, DgCopies& dgCopies, ModelEntity* me)$/;"	f	class:apf::MeshMDS
getDiagonalFromFlag	ma/maTetrahedronize.cc	/^int getDiagonalFromFlag(Adapt* a, Entity* e)$/;"	f	namespace:ma
getDimTopology	stk/apfSTK.cc	/^const CellTopologyData* getDimTopology(Mesh* m, int dim)$/;"	f	namespace:apf
getDimension	apf/apf.cc	/^int getDimension(MeshElement* me)$/;"	f	namespace:apf
getDimension	apf/apfElement.h	/^    int getDimension() {return Mesh::typeDimension[getType()];}$/;"	f	class:apf::Element
getDimension	apf/apfMesh.cc	/^int getDimension(Mesh* m, MeshEntity* e)$/;"	f	namespace:apf
getDimension	apf/apfShape.cc	/^        int getDimension() const {return D;}$/;"	f	class:apf::Constant::Element
getDimension	apf_cap/apfCAP.cc	/^int MeshCAP::getDimension()$/;"	f	class:apf::MeshCAP
getDimension	apf_sim/apfSIM.cc	/^int MeshSIM::getDimension()$/;"	f	class:apf::MeshSIM
getDimension	mds/apfMDS.cc	/^    int getDimension()$/;"	f	class:apf::MeshMDS
getDimensionBase	ma/maCrawler.cc	/^void getDimensionBase(Adapt* a, int d, Crawler::Layer& base)$/;"	f	namespace:ma
getDistTag	parma/diffMC/parma_graphDist.cc	/^  apf::MeshTag* getDistTag(apf::Mesh* m) {$/;"	f	namespace:parma
getDistance	apf/apfGeometry.cc	/^double getDistance(LineSegment const& ls, Vector3 const& p)$/;"	f	namespace:apf
getDistance	ma/maAdapt.cc	/^double getDistance(Adapt* a, Entity* v0, Entity* v1)$/;"	f	namespace:ma
getDistance	ma/maAdapt.cc	/^double getDistance(Adapt* a, Entity* v[2])$/;"	f	namespace:ma
getDistanceWithFrame	phasta/phFilterMatching.cc	/^static double getDistanceWithFrame(gmi_model* gm, gmi_ent* e, gmi_ent* oe,$/;"	f	namespace:ph
getDiv	apf/apf.cc	/^double getDiv(Element* e, Vector3 const& param)$/;"	f	namespace:apf
getDoubleTag	apf_cap/apfCAP.cc	/^void MeshCAP::getDoubleTag(MeshEntity* e, MeshTag* tag, double* data)$/;"	f	class:apf::MeshCAP
getDoubleTag	apf_sim/apfSIM.cc	/^void MeshSIM::getDoubleTag(MeshEntity* e, MeshTag* tag, double* data)$/;"	f	class:apf::MeshSIM
getDoubleTag	mds/apfMDS.cc	/^    void getDoubleTag(MeshEntity* e, MeshTag* tag, double* data)$/;"	f	class:apf::MeshMDS
getDownBridgeAdjacent	apf/apfMesh.cc	/^static void getDownBridgeAdjacent(Mesh* m, MeshEntity* origin,$/;"	f	namespace:apf
getDownIndex	ma/maMesh.cc	/^int getDownIndex(Mesh* m, Entity* e, Entity* de)$/;"	f	namespace:ma
getDownward	apf_cap/apfCAP.cc	/^int MeshCAP::getDownward(MeshEntity* e,$/;"	f	class:apf::MeshCAP
getDownward	apf_sim/apfSIM.cc	/^int MeshSIM::getDownward(MeshEntity* e,$/;"	f	class:apf::MeshSIM
getDownward	mds/apfMDS.cc	/^    int getDownward(MeshEntity* e, int dimension, MeshEntity** adjacent)$/;"	f	class:apf::MeshMDS
getDwn2ndAdj	parma/diffMC/parma_meshaux.h	/^void getDwn2ndAdj(apf::Mesh* m, apf::MeshEntity* ent, apf::Adjacent& adj) {$/;"	f
getEdgeAdjVtx	parma/diffMC/parma_meshaux.h	/^void getEdgeAdjVtx(apf::Mesh* m, apf::MeshEntity* v, apf::Adjacent& adj) {$/;"	f
getEdgeCenter	phasta/phModelGeometry.cc	/^static apf::Vector3 getEdgeCenter(gmi_model* gm, gmi_ent* e)$/;"	f	namespace:ph
getEdgeDirection	ma/maTetrahedronize.cc	/^static bool getEdgeDirection(apf::GlobalNumbering* n, Entity* e)$/;"	f	namespace:ma
getEdgeIdInFace	mds/apfMDS.cc	/^static int getEdgeIdInFace(apf::Mesh* mesh, apf::MeshEntity* face,$/;"	f	namespace:apf
getEdgeLenAndCnt	sam/samSz.cc	/^void getEdgeLenAndCnt(apf::Mesh* m, apf::MeshEntity* v, double& len, int& cnt) {$/;"	f	namespace:__anon23
getEdgeLenAndCnt	test/refine2x.cc	/^    void getEdgeLenAndCnt(ma::Entity* v, double& len, int& cnt) {$/;"	f	class:AnisotropicX	file:
getEdgeLength	apf/apfSimplexAngleCalcs.cc	/^static double getEdgeLength(Mesh* m, MeshEntity* e)$/;"	f	namespace:apf
getEdgeLengthsInMetricSpace	ma/maStats.cc	/^void getEdgeLengthsInMetricSpace(ma::Mesh* m, ma::SizeField* sf,$/;"	f	namespace:ma
getEdgeLengthsInPhysicalSpace	ma/maStats.cc	/^void getEdgeLengthsInPhysicalSpace(ma::Mesh* m,$/;"	f	namespace:ma
getEdgeMap	ma/maMap.cc	/^Affine getEdgeMap(apf::Mesh* m, Entity* e)$/;"	f	namespace:ma
getEdgeSplitCode	ma/maRefine.cc	/^static int getEdgeSplitCode(Adapt* a, Entity* e)$/;"	f	namespace:ma
getEdgeVert	ma/maEdgeSwap.cc	/^    Entity* getEdgeVert(int i) {return edge_verts[i];}$/;"	f	class:ma::SwapLoop
getEdgeVertOppositeVert	apf/apfMesh.cc	/^MeshEntity* getEdgeVertOppositeVert(Mesh* m, MeshEntity* edge, MeshEntity* v)$/;"	f	namespace:apf
getEdges	ma/maVertRemover.h	/^    apf::Up& getEdges() {return edges;}$/;"	f	class:ma::VertRemover
getEdges	phasta/phOutput.cc	/^static void getEdges(Output& o, apf::Numbering* vn, apf::Numbering* rn, BCs& bcs)$/;"	f	namespace:ph
getElemDest	ma/maLayerCoarsen.cc	/^  int getElemDest(Entity* e)$/;"	f	struct:ma::CurveLocalizer
getElemSizeField	spr/sprEstimateTargetError.cc	/^static void getElemSizeField(Estimation* e)$/;"	f	namespace:spr::target
getElement	apf/apfMatrixField.cc	/^Element* MatrixField::getElement(VectorElement* e)$/;"	f	class:apf::MatrixField
getElement	apf/apfPackedField.cc	/^Element* PackedField::getElement(VectorElement* e)$/;"	f	class:apf::PackedField
getElement	apf/apfScalarField.cc	/^Element* ScalarField::getElement(VectorElement* e)$/;"	f	class:apf::ScalarField
getElement	apf/apfVectorField.cc	/^Element* VectorField::getElement(VectorElement* e)$/;"	f	class:apf::VectorField
getElementBytes	apf/apfMesh.h	/^    virtual double getElementBytes(int) {return 1.0;}$/;"	f	class:apf::Mesh
getElementBytes	mds/apfMDS.cc	/^    double getElementBytes(int type)$/;"	f	class:apf::MeshMDS
getElementData	apf/apfFieldData.cc	/^int FieldDataOf<T>::getElementData(MeshEntity* entity, NewArray<T>& data)$/;"	f	class:apf::FieldDataOf
getElementGid	zoltan/apfInterElement.cc	/^static long getElementGid(GlobalNumbering* gn, MeshEntity* e)$/;"	f	namespace:apf
getElementGraph	phasta/phOutput.cc	/^static void getElementGraph(Output& o, apf::Numbering* rn, BCs& bcs)$/;"	f	namespace:ph
getElementNumbers	apf/apfMixedNumbering.cc	/^void getElementNumbers($/;"	f	namespace:apf
getElementNumbers	apf/apfNumbering.cc	/^int getElementNumbers(GlobalNumbering* n, MeshEntity* e,$/;"	f	namespace:apf
getElementNumbers	apf/apfNumbering.cc	/^int getElementNumbers(Numbering* n, MeshEntity* e, NewArray<int>& numbers)$/;"	f	namespace:apf
getElementSizeField	spr/sprEstimateError.cc	/^static void getElementSizeField(Estimation* e)$/;"	f	namespace:spr
getElementToElement	zoltan/apfInterElement.cc	/^int* getElementToElement(apf::Mesh* m)$/;"	f	namespace:apf
getElementType	phasta/phBlock.cc	/^std::string getElementType$/;"	f	namespace:ph
getElementWeight	ma/maBalance.cc	/^double getElementWeight(Adapt* a, Entity* e)$/;"	f	namespace:ma
getElementWeights	ma/maBalance.cc	/^Tag* getElementWeights(Adapt* a)$/;"	f	namespace:ma
getElements	zoltan/apfZoltanMesh.cc	/^static void getElements(ZoltanMesh* b)$/;"	f	namespace:apf
getElmAdjVtx	parma/diffMC/parma_meshaux.h	/^void getElmAdjVtx(apf::Mesh* m, apf::MeshEntity* v, apf::Adjacent& adj) {$/;"	f
getElmType	test/icesheet.cc	/^unsigned getElmType(int numVtxPerElm) {$/;"	f
getEntWeight	parma/diffMC/parma_centroids.cc	/^  double getEntWeight(apf::Mesh* m, apf::MeshTag* w, apf::MeshEntity* e) {$/;"	f	namespace:__anon63
getEntWeight	parma/diffMC/parma_entWeights.cc	/^  double EntWeights::getEntWeight(apf::Mesh* m, apf::MeshEntity* e, $/;"	f	class:parma::EntWeights
getEntWeight	parma/diffMC/parma_entWeights.cc	/^  double getEntWeight(apf::Mesh* m, apf::MeshEntity* e, apf::MeshTag* w) {$/;"	f	namespace:parma
getEntWeight	parma/parma.cc	/^  double getEntWeight(apf::Mesh* m, apf::MeshEntity* e, apf::MeshTag* w) {$/;"	f	namespace:__anon75
getEntity	apf/apfElement.h	/^    MeshEntity* getEntity() {return entity;}$/;"	f	class:apf::Element
getEntityShape	apf/apfHierarchic.cc	/^    EntityShape* getEntityShape(int type) {$/;"	f	class:apf::Hierarchic2
getEntityShape	apf/apfHierarchic.cc	/^    EntityShape* getEntityShape(int type)$/;"	f	class:apf::Hierarchic3
getEntityShape	apf/apfIPShape.cc	/^    EntityShape* getEntityShape(int type)$/;"	f	class:apf::ConstantIPFit
getEntityShape	apf/apfIPShape.cc	/^    EntityShape* getEntityShape(int type)$/;"	f	class:apf::LinearIPFit
getEntityShape	apf/apfIPShape.cc	/^    EntityShape* getEntityShape(int type)$/;"	f	class:apf::VoronoiShape
getEntityShape	apf/apfIPShape.cc	/^    EntityShape* getEntityShape(int) {return 0;}$/;"	f	class:apf::IPBase
getEntityShape	apf/apfShape.cc	/^    EntityShape* getEntityShape(int type)$/;"	f	class:apf::Constant
getEntityShape	apf/apfShape.cc	/^    EntityShape* getEntityShape(int type)$/;"	f	class:apf::LagrangeCubic
getEntityShape	apf/apfShape.cc	/^    EntityShape* getEntityShape(int type)$/;"	f	class:apf::LagrangeQuadratic
getEntityShape	apf/apfShape.cc	/^    EntityShape* getEntityShape(int type)$/;"	f	class:apf::Linear
getEntityShape	apf/apfShape.cc	/^    EntityShape* getEntityShape(int type)$/;"	f	class:apf::QuadraticBase
getEntityShape	apf/apfShape.cc	/^    EntityShape* getEntityShape(int type)$/;"	f	class:apf::SerendipityQuadratic
getEntityShape	crv/crvBezier.cc	/^  apf::EntityShape* getEntityShape(int type)$/;"	f	class:crv::Bezier
getEntityShape	crv/crvBezier.cc	/^  apf::EntityShape* getEntityShape(int type)$/;"	f	class:crv::GregorySurface4
getEssentialBCValues	phasta/phGeomBC.cc	/^void getEssentialBCValues(Output& o, apf::DynamicArray<double>& values)$/;"	f	namespace:ph
getEssentialBCs	phasta/phOutput.cc	/^static void getEssentialBCs(BCs& bcs, Output& o)$/;"	f	namespace:ph
getExport	zoltan/apfZoltanCallbacks.cc	/^void ZoltanData::getExport(int ind, int *localId, int *export_part)$/;"	f	class:apf::ZoltanData
getExtrudedName	ma/maExtrude.cc	/^std::string getExtrudedName(std::string const& flat_name) {$/;"	f	namespace:ma::__anon28
getFaceCoords	ma/maSnapper.cc	/^void getFaceCoords(Mesh* m, Entity* face, std::vector<Vector>& coords)$/;"	f	namespace:ma
getFaceEdgesAndDirections	ma/maMesh.cc	/^void getFaceEdgesAndDirections($/;"	f	namespace:ma
getFaceIdInRegion	mds/apfMDS.cc	/^static int getFaceIdInRegion(apf::Mesh* mesh, apf::MeshEntity* region,$/;"	f	namespace:apf
getFacePlane	phasta/phModelGeometry.cc	/^apf::Plane getFacePlane(gmi_model* gm, gmi_ent* f)$/;"	f	namespace:ph
getField	apf/apfFieldData.h	/^    FieldBase* getField() {return field;}$/;"	f	class:apf::FieldData
getField	apf/apfMesh.cc	/^Field* Mesh::getField(int i)$/;"	f	class:apf::Mesh
getField	apf/apfNumbering.cc	/^Field* NumberingOf<T>::getField() {return field;}$/;"	f	class:apf::NumberingOf
getField	apf/apfNumbering.cc	/^Field* getField(GlobalNumbering* n) { return n->getField(); }$/;"	f	namespace:apf
getField	apf/apfNumbering.cc	/^Field* getField(Numbering* n)$/;"	f	namespace:apf
getFieldNodes	apf/apfNumbering.cc	/^static void getFieldNodes(FieldBase* f, DynamicArray<Node>& nodes)$/;"	f	namespace:apf
getFileName	phasta/phiotimer.cc	/^static const char* getFileName() {$/;"	f	file:
getFileNameAndPathVtu	apf/apfVtk.cc	/^static std::string getFileNameAndPathVtu(const char* prefix,$/;"	f	namespace:apf
getFirstDerivative	apf/apfMesh.cc	/^void Mesh::getFirstDerivative(ModelEntity* g, Vector3 const& p,$/;"	f	class:apf::Mesh
getFirstType	apf/apfMesh.cc	/^int getFirstType(Mesh* m, int dim)$/;"	f	namespace:apf
getFlag	ma/maAdapt.cc	/^bool getFlag(Adapt* a, Entity* e, int flag)$/;"	f	namespace:ma
getFlagFromDiagonal	ma/maTetrahedronize.cc	/^int getFlagFromDiagonal(int diagonal)$/;"	f	namespace:ma
getFlags	ma/maAdapt.cc	/^int getFlags(Adapt* a, Entity* e)$/;"	f	namespace:ma
getFlatName	ma/maExtrude.cc	/^std::string getFlatName(std::string const& extruded_name, size_t layer) {$/;"	f	namespace:ma
getFrame	apf/apfMatrix.cc	/^Matrix3x3 getFrame(Vector3 const& v)$/;"	f	namespace:apf
getFrame	ma/maSize.cc	/^  void getFrame(Entity* v, Matrix& f)$/;"	f	struct:ma::BothEval
getFullAttributeMatching	phasta/phFilterMatching.cc	/^void getFullAttributeMatching(gmi_model* m, BCs& bcs, ModelMatching& mm)$/;"	f	namespace:ph
getFullFlatLayer	ma/maExtrude.cc	/^FullLayer getFullFlatLayer(Mesh* m) {$/;"	f	namespace:ma::__anon28
getFullRepFromBlended	crv/crvBezier.cc	/^void getFullRepFromBlended(int type,$/;"	f	namespace:crv
getFun3dW	test/ghost.cc	/^  double getFun3dW(int type) {$/;"	f	namespace:__anon11
getFunction	apf/apfUserData.h	/^  Function const* getFunction() const { return function; }$/;"	f	struct:apf::UserData
getGCEssentialBCs	phasta/phOutput.cc	/^static void getGCEssentialBCs(Output& o, apf::Numbering* n)$/;"	f	namespace:ph
getGaussPoint	apf/apf.cc	/^void getGaussPoint(int type, int order, int point, Vector3& param)$/;"	f	namespace:apf
getGeomDim	zoltan/apfZoltanCallbacks.cc	/^int getGeomDim(void *, int *)$/;"	f	namespace:apf
getGeomEnt	pumi/mPartEntityContainer.cc	/^gEntity* mPartEntityContainer::getGeomEnt(int d, gmi_ent* e)$/;"	f	class:mPartEntityContainer
getGeomEnt	pumi/pumi_geom.cc	/^gEntity* gModel::getGeomEnt(int d, gmi_ent* ge)$/;"	f	class:gModel
getGhostingPlan	test/pumi.cc	/^Ghosting* getGhostingPlan(pMesh m)$/;"	f
getGhosts	apf_cap/apfCAP.h	/^    int getGhosts(MeshEntity*, Copies&) { return 0; }$/;"	f	class:apf::MeshCAP
getGhosts	apf_sim/apfSIM.h	/^    int getGhosts(MeshEntity*, Copies&) { return 0; }$/;"	f	class:apf::MeshSIM
getGhosts	mds/apfMDS.cc	/^    int getGhosts(MeshEntity* e, Copies& ghosts)$/;"	f	class:apf::MeshMDS
getGlobal	phasta/phOutput.cc	/^static void getGlobal(Output& o)$/;"	f	namespace:ph
getGlobalGradients	apf/apfElement.cc	/^void Element::getGlobalGradients(Vector3 const& local,$/;"	f	class:apf::Element
getGlobalNumbering	apf/apfMesh.cc	/^GlobalNumbering* Mesh::getGlobalNumbering(int i)$/;"	f	class:apf::Mesh
getGmi	pumi/mPartEntityContainer.h	/^  gmi_ent* getGmi() {return e;}  $/;"	f	class:gEntity
getGmi	pumi/pumi.h	/^  gmi_model* getGmi() {return g; }$/;"	f	class:gModel
getGrad	apf/apf.cc	/^void getGrad(Element* e, Vector3 const& param, Vector3& g)$/;"	f	namespace:apf
getGradBF	apf/apf.cc	/^void getGradBF(FieldShape* s, MeshElement* e, Vector3 const& p,$/;"	f	namespace:apf
getGradIPField	spr/sprGetGradIPField.cc	/^apf::Field* getGradIPField(apf::Field* f, const char* name, int order)$/;"	f	namespace:spr
getGradient	apf/apfGradientByVolume.cc	/^    GetGradient<T> getGradient;$/;"	m	class:apf::GradientIntegrator	file:
getGraphDistance	dsp/dspGraphDistance.cc	/^apf::Numbering* getGraphDistance(apf::Mesh* m, Boundary& seed,$/;"	f	namespace:dsp
getGregory	crv/crvBezier.cc	/^apf::FieldShape* getGregory()$/;"	f	namespace:crv
getGregoryBlendedTransformationCoefficients	crv/crvG1Points.cc	/^void getGregoryBlendedTransformationCoefficients(int blend, int type,$/;"	f	namespace:crv
getGregoryTetTransform	crv/crvG1Points.cc	/^static void getGregoryTetTransform(apf::NewArray<double> & c)$/;"	f	namespace:crv
getGregoryTransformationCoefficients	crv/crvG1Points.cc	/^void getGregoryTransformationCoefficients(int type,$/;"	f	namespace:crv
getGregoryTriangleTransform	crv/crvG1Points.cc	/^static void getGregoryTriangleTransform(apf::NewArray<double> & c)$/;"	f	namespace:crv
getGrowthCurves	phasta/phGrowthCurves.cc	/^void getGrowthCurves(Output& o)$/;"	f	namespace:ph
getGrowthCurves	phasta/phGrowthCurves_empty.cc	/^  void getGrowthCurves(Output& o) {$/;"	f	namespace:ph
getHg	zoltan/apfZoltanCallbacks.cc	/^void getHg(void* data, int ngid, int, int totAdjVtx, int,$/;"	f	namespace:apf
getHgSize	zoltan/apfZoltanCallbacks.cc	/^void getHgSize(void* data,$/;"	f	namespace:apf
getHierarchic	apf/apfHierarchic.cc	/^FieldShape* getHierarchic(int o)$/;"	f	namespace:apf
getHigherBezierNodeXi	crv/crvBezierPoints.cc	/^static void getHigherBezierNodeXi(int type, int P, int node, apf::Vector3& xi)$/;"	f	namespace:crv
getIPFitShape	apf/apfIPShape.cc	/^FieldShape* getIPFitShape(int dimension, int order)$/;"	f	namespace:apf
getIPName	apf/apfVtk.cc	/^static std::string getIPName(FieldBase* f, int point)$/;"	f	namespace:apf
getIPShape	apf/apfIPShape.cc	/^FieldShape* getIPShape(int dimension, int order)$/;"	f	namespace:apf
getId	apf_cap/apfCAP.cc	/^int MeshCAP::getId()$/;"	f	class:apf::MeshCAP
getId	apf_sim/apfSIM.cc	/^int MeshSIM::getId()$/;"	f	class:apf::MeshSIM
getId	mds/apfMDS.cc	/^    int getId()$/;"	f	class:apf::MeshMDS
getId	parma/diffMC/parma_components.cc	/^  unsigned DCC::getId(apf::MeshEntity* e) {$/;"	f	class:parma::DCC
getId	parma/diffMC/parma_components.cc	/^  unsigned dcComponents::getId(apf::MeshEntity* e) { return c->getId(e); }$/;"	f	class:parma::dcComponents
getIdChecksum	parma/diffMC/parma_components.cc	/^  unsigned DCC::getIdChecksum() {$/;"	f	class:parma::DCC
getIdChecksum	parma/diffMC/parma_components.cc	/^  unsigned dcComponents::getIdChecksum() { return c->getIdChecksum(); }$/;"	f	class:parma::dcComponents
getImbalance	parma/diffMC/parma_entWeights.cc	/^  void getImbalance(Weights* w, double& imb, double& avg) {$/;"	f	namespace:parma
getIndependentSet	apf/apfMIS.cc	/^  bool getIndependentSet(MIS* mis) {$/;"	f	namespace:apf
getInertiaContribution	parma/rib/parma_rib.cc	/^static mth::Matrix3x3<double> getInertiaContribution(Body const* b)$/;"	f	namespace:parma
getInertiaMatrix	parma/rib/parma_rib.cc	/^static mth::Matrix3x3<double> getInertiaMatrix(Bodies const* b)$/;"	f	namespace:parma
getInitialConditions	phasta/phOutput.cc	/^static void getInitialConditions(BCs& bcs, Output& o)$/;"	f	namespace:ph
getInitialPatch	spr/sprRecoverField.cc	/^static bool getInitialPatch(Patch* p, apf::CavityOp* o)$/;"	f	namespace:spr
getInnerProduct	apf/apfMatrix.h	/^double getInnerProduct(Matrix<M,N> const& a,$/;"	f	namespace:apf
getInsideness	ma/maMap.cc	/^double getInsideness(apf::Mesh* m, Entity* e, Vector const& xi)$/;"	f	namespace:ma
getInsphere	ma/maQuality.cc	/^double getInsphere(Mesh* m, Entity* e)$/;"	f	namespace:ma
getIntPoint	apf/apf.cc	/^void getIntPoint(MeshElement* e, int order, int point, Vector3& param)$/;"	f	namespace:apf
getIntTag	apf_cap/apfCAP.cc	/^void MeshCAP::getIntTag(MeshEntity* e, MeshTag* tag, int* data)$/;"	f	class:apf::MeshCAP
getIntTag	apf_sim/apfSIM.cc	/^void MeshSIM::getIntTag(MeshEntity* e, MeshTag* tag, int* data)$/;"	f	class:apf::MeshSIM
getIntTag	mds/apfMDS.cc	/^    void getIntTag(MeshEntity* e, MeshTag* tag, int* data)$/;"	f	class:apf::MeshMDS
getIntWeight	apf/apf.cc	/^double getIntWeight(MeshElement* e, int order, int point)$/;"	f	namespace:apf
getIntegration	apf/apfIntegrate.cc	/^    virtual Integration const* getIntegration(int i) const$/;"	f	class:apf::EdgeIntegration
getIntegration	apf/apfIntegrate.cc	/^    virtual Integration const* getIntegration(int i) const$/;"	f	class:apf::HexahedronIntegration
getIntegration	apf/apfIntegrate.cc	/^    virtual Integration const* getIntegration(int i) const$/;"	f	class:apf::QuadIntegration
getIntegration	apf/apfIntegrate.cc	/^    virtual Integration const* getIntegration(int i) const$/;"	f	class:apf::TetrahedronIntegration
getIntegration	apf/apfIntegrate.cc	/^    virtual Integration const* getIntegration(int i) const$/;"	f	class:apf::TriangleIntegration
getIntegration	apf/apfIntegrate.cc	/^    virtual Integration const* getIntegration(int) const$/;"	f	class:apf::PrismIntegration
getIntegration	apf/apfIntegrate.cc	/^    virtual Integration const* getIntegration(int) const$/;"	f	class:apf::PyramidIntegration
getIntegration	apf/apfIntegrate.cc	/^EntityIntegration const* getIntegration(int meshEntityType)$/;"	f	namespace:apf
getIntegrationPoints	apf/apfIPShape.cc	/^static void getIntegrationPoints($/;"	f	namespace:apf
getInterface	phasta/phOutput.cc	/^static void getInterface$/;"	f	namespace:ph
getInterfaceBlockKey	phasta/phBlock.cc	/^void getInterfaceBlockKey$/;"	f	namespace:ph
getInterfaceBlocks	phasta/phBlock.cc	/^void getInterfaceBlocks(apf::Mesh* m, BCs& bcs, BlocksInterface& b)$/;"	f	namespace:ph
getInterfaceConnectivity	phasta/phGeomBC.cc	/^void getInterfaceConnectivity$/;"	f	namespace:ph
getInterfaceElements	phasta/phOutput.cc	/^static void getInterfaceElements(Output& o)$/;"	f	namespace:ph
getInterfaceFlag	phasta/phOutput.cc	/^static void getInterfaceFlag(Output& o, BCs& bcs) {$/;"	f	namespace:ph
getInterfaceMaterialType	phasta/phGeomBC.cc	/^void getInterfaceMaterialType$/;"	f	namespace:ph
getInterior	phasta/phOutput.cc	/^static void getInterior(Output& o, BCs& bcs, apf::Numbering* n)$/;"	f	namespace:ph
getInteriorBlockKey	phasta/phBlock.cc	/^void getInteriorBlockKey(apf::Mesh* m, apf::MeshEntity* e, BlockKey& k)$/;"	f	namespace:ph
getInteriorBlocks	phasta/phBlock.cc	/^static void getInteriorBlocks(apf::Mesh* m, Blocks& b)$/;"	f	namespace:ph
getInteriorConnectivity	phasta/phGeomBC.cc	/^void getInteriorConnectivity(Output& o, int block, apf::DynamicArray<int>& c)$/;"	f	namespace:ph
getInteriorMaterialType	phasta/phGeomBC.cc	/^void getInteriorMaterialType$/;"	f	namespace:ph
getInternalBezierTransformationCoefficients	crv/crvBezierPoints.cc	/^void getInternalBezierTransformationCoefficients(apf::Mesh* m, int P, int blend,$/;"	f	namespace:crv
getIsoLengthScalar	sam/samElementCount.cc	/^double getIsoLengthScalar(apf::Field* iso_field, double targetElementCount) {$/;"	f	namespace:sam
getIsoSize	sam/samSz.cc	/^apf::Field* getIsoSize(apf::Mesh* m, apf::Field* fLen, apf::Field* fCnt) {$/;"	f	namespace:__anon23
getJacDetByElevation	crv/crvQuality.cc	/^static void getJacDetByElevation(int type, int P,$/;"	f	namespace:crv
getJacDetBySubdivision	crv/crvQuality.cc	/^static void getJacDetBySubdivision(int type, int P,$/;"	f	namespace:crv
getJacDetBySubdivisionMatrices	crv/crvQuality.cc	/^static void getJacDetBySubdivisionMatrices(int type, int P,$/;"	f	namespace:crv
getJacobian	apf/apf.cc	/^void getJacobian(MeshElement* e, Vector3 const& local, Matrix3x3& j)$/;"	f	namespace:apf
getJacobian	apf/apfVectorElement.cc	/^void VectorElement::getJacobian(Vector3 const& xi, Matrix3x3& J)$/;"	f	class:apf::VectorElement
getJacobianDeterminant	apf/apfVectorElement.cc	/^double getJacobianDeterminant(Matrix3x3 const& J, int dimension)$/;"	f	namespace:apf
getJacobianInMetric	apf/apfSimplexAngleCalcs.cc	/^static Matrix3x3 getJacobianInMetric(const Matrix3x3& J, const Matrix3x3& Q)$/;"	f	namespace:apf
getJacobianInv	apf/apf.cc	/^void getJacobianInv(MeshElement* e, Vector3 const& local, Matrix3x3& jinv)$/;"	f	namespace:apf
getJacobianInverse	apf/apfElement.cc	/^Matrix3x3 getJacobianInverse(Matrix3x3 J, int dim)$/;"	f	namespace:apf
getLagrange	apf/apfShape.cc	/^FieldShape* getLagrange(int order)$/;"	f	namespace:apf
getLambdaMax	test/capStoneAttachSolution.cc	/^void getLambdaMax(apf::Mesh* mesh,apf::Field* hessianField,apf::Field* lambdaMaxField)$/;"	f
getLargetsSize	test/visualizeAnisoSizes.cc	/^double getLargetsSize($/;"	f
getLength	apf/apfDynamicVector.h	/^    double getLength() {return sqrt((*this)*(*this));}$/;"	f	class:apf::DynamicVector
getLength	apf/apfVector.h	/^    double getLength() const {return sqrt((*this)*(*this));}$/;"	f	class:apf::Vector
getLength	mth/mthVector.h	/^    T getLength() const {return sqrt((*this)*(*this));}$/;"	f	class:mth::Vector
getLengthScalar	sam/samElementCount.cc	/^double getLengthScalar(int dim, double targetElementCount,$/;"	f	namespace:sam
getLengthScalar	sam/samElementCount.cc	/^double getLengthScalar(int dim, double volumeScalar) {$/;"	f	namespace:sam
getLine	mds/mdsGmsh.cc	/^void getLine(Reader* r)$/;"	f	namespace:__anon96
getLinearCentroid	apf/apfMesh.cc	/^Vector3 getLinearCentroid(Mesh* m, MeshEntity* e)$/;"	f	namespace:apf
getLinearQualitiesInMetricSpace	ma/maStats.cc	/^void getLinearQualitiesInMetricSpace(ma::Mesh* m, ma::SizeField* sf,$/;"	f	namespace:ma
getLinearQualitiesInPhysicalSpace	ma/maStats.cc	/^void getLinearQualitiesInPhysicalSpace(ma::Mesh* m,$/;"	f	namespace:ma
getLink	ma/maLayerSnap.cc	/^  void getLink(Entity* v, int& peer, int& idx)$/;"	f	struct:ma::BaseTopLinker
getLinks	phasta/phLinks.cc	/^void getLinks(apf::Mesh* m, int dim, Links& links, BCs& bcs)$/;"	f	namespace:ph
getLocalClass	ma/maExtrude.cc	/^ModelExtrusion getLocalClass(Mesh* m, Entity* prev_ent,$/;"	f	namespace:ma::__anon28
getLocalGradients	apf/apfHierarchic.cc	/^    void getLocalGradients($/;"	f	class:apf::HEdge2
getLocalGradients	apf/apfHierarchic.cc	/^    void getLocalGradients($/;"	f	class:apf::HEdge3
getLocalGradients	apf/apfHierarchic.cc	/^    void getLocalGradients($/;"	f	class:apf::HTetrahedron2
getLocalGradients	apf/apfHierarchic.cc	/^    void getLocalGradients($/;"	f	class:apf::HTriangle2
getLocalGradients	apf/apfHierarchic.cc	/^    void getLocalGradients($/;"	f	class:apf::HTriangle3
getLocalGradients	apf/apfHierarchic.cc	/^    void getLocalGradients($/;"	f	class:apf::HVertex
getLocalGradients	apf/apfIPShape.cc	/^        void getLocalGradients(Mesh*, MeshEntity*,$/;"	f	class:apf::ConstantIPFit::Tetrahedron
getLocalGradients	apf/apfIPShape.cc	/^        void getLocalGradients(Mesh*, MeshEntity*,$/;"	f	class:apf::ConstantIPFit::Triangle
getLocalGradients	apf/apfIPShape.cc	/^        void getLocalGradients(Mesh*, MeshEntity*,$/;"	f	class:apf::LinearIPFit::Tetrahedron
getLocalGradients	apf/apfIPShape.cc	/^        void getLocalGradients(Mesh*, MeshEntity*,$/;"	f	class:apf::LinearIPFit::Triangle
getLocalGradients	apf/apfIPShape.cc	/^        void getLocalGradients(Mesh*, MeshEntity*,$/;"	f	class:apf::VoronoiShape::Element
getLocalGradients	apf/apfShape.cc	/^        void getLocalGradients(Mesh*, MeshEntity*,$/;"	f	class:apf::Constant::Element
getLocalGradients	apf/apfShape.cc	/^        void getLocalGradients(Mesh*, MeshEntity*,$/;"	f	class:apf::LagrangeCubic::Edge
getLocalGradients	apf/apfShape.cc	/^        void getLocalGradients(Mesh*, MeshEntity*,$/;"	f	class:apf::LagrangeCubic::Tetrahedron
getLocalGradients	apf/apfShape.cc	/^        void getLocalGradients(Mesh*, MeshEntity*,$/;"	f	class:apf::LagrangeCubic::Triangle
getLocalGradients	apf/apfShape.cc	/^        void getLocalGradients(Mesh*, MeshEntity*,$/;"	f	class:apf::LagrangeCubic::Vertex
getLocalGradients	apf/apfShape.cc	/^        void getLocalGradients(Mesh*, MeshEntity*,$/;"	f	class:apf::LagrangeQuadratic::Quad
getLocalGradients	apf/apfShape.cc	/^        void getLocalGradients(Mesh*, MeshEntity*,$/;"	f	class:apf::Linear::Edge
getLocalGradients	apf/apfShape.cc	/^        void getLocalGradients(Mesh*, MeshEntity*,$/;"	f	class:apf::Linear::Hexahedron
getLocalGradients	apf/apfShape.cc	/^        void getLocalGradients(Mesh*, MeshEntity*,$/;"	f	class:apf::Linear::Prism
getLocalGradients	apf/apfShape.cc	/^        void getLocalGradients(Mesh*, MeshEntity*,$/;"	f	class:apf::Linear::Pyramid
getLocalGradients	apf/apfShape.cc	/^        void getLocalGradients(Mesh*, MeshEntity*,$/;"	f	class:apf::Linear::Quad
getLocalGradients	apf/apfShape.cc	/^        void getLocalGradients(Mesh*, MeshEntity*,$/;"	f	class:apf::Linear::Tetrahedron
getLocalGradients	apf/apfShape.cc	/^        void getLocalGradients(Mesh*, MeshEntity*,$/;"	f	class:apf::Linear::Triangle
getLocalGradients	apf/apfShape.cc	/^        void getLocalGradients(Mesh*, MeshEntity*,$/;"	f	class:apf::Linear::Vertex
getLocalGradients	apf/apfShape.cc	/^        void getLocalGradients(Mesh*, MeshEntity*,$/;"	f	class:apf::QuadraticBase::Edge
getLocalGradients	apf/apfShape.cc	/^        void getLocalGradients(Mesh*, MeshEntity*,$/;"	f	class:apf::QuadraticBase::Tetrahedron
getLocalGradients	apf/apfShape.cc	/^        void getLocalGradients(Mesh*, MeshEntity*,$/;"	f	class:apf::QuadraticBase::Triangle
getLocalGradients	apf/apfShape.cc	/^      void getLocalGradients(Mesh*, MeshEntity*,$/;"	f	class:apf::SerendipityQuadratic::Quad
getLocalGradients	crv/crvBezier.cc	/^    void getLocalGradients(apf::Mesh* \/*m*\/, apf::MeshEntity* \/*e*\/,$/;"	f	class:crv::Bezier::Edge
getLocalGradients	crv/crvBezier.cc	/^    void getLocalGradients(apf::Mesh* m, apf::MeshEntity* e, apf::Vector3 const& xi,$/;"	f	class:crv::Bezier::Triangle
getLocalGradients	crv/crvBezier.cc	/^    void getLocalGradients(apf::Mesh* m, apf::MeshEntity* e,$/;"	f	class:crv::Bezier::Tetrahedron
getLocalGradients	crv/crvBezier.cc	/^    void getLocalGradients(apf::Mesh* m, apf::MeshEntity* e,$/;"	f	class:crv::GregorySurface4::Tetrahedron
getLocalGradients	crv/crvBezier.cc	/^    void getLocalGradients(apf::Mesh* m, apf::MeshEntity* e,$/;"	f	class:crv::GregorySurface4::Triangle
getLocalGradients	crv/crvBezier.cc	/^    void getLocalGradients(apf::Mesh*, apf::MeshEntity*,$/;"	f	class:crv::Bezier::Vertex
getLocalPeriodicMaster	phasta/phOutput.cc	/^static apf::MeshEntity* getLocalPeriodicMaster(apf::MatchedSharing* sh,$/;"	f	namespace:ph
getLocalPeriodicMasters	phasta/phOutput.cc	/^static void getLocalPeriodicMasters(Output& o, apf::Numbering* n, BCs& bcs)$/;"	f	namespace:ph
getLocalSideId	stk/apfMeshSTK.cc	/^int getLocalSideId(Mesh* m, MeshEntity* e,$/;"	f	namespace:apf
getLogM	ma/maSize.cc	/^  void getLogM(Entity* v, Matrix& f)$/;"	f	struct:ma::LogMEval
getLong	mds/mdsGmsh.cc	/^long getLong(Reader* r)$/;"	f	namespace:__anon96
getLongTag	apf_cap/apfCAP.cc	/^void MeshCAP::getLongTag(MeshEntity* e, MeshTag* tag, long* data)$/;"	f	class:apf::MeshCAP
getLongTag	apf_sim/apfSIM.cc	/^void MeshSIM::getLongTag(MeshEntity* e, MeshTag* tag, long* data)$/;"	f	class:apf::MeshSIM
getLongTag	mds/apfMDS.cc	/^    void getLongTag(MeshEntity* e, MeshTag* tag, long* data)$/;"	f	class:apf::MeshMDS
getM2GFields	phasta/phOutput.cc	/^static void getM2GFields(Output& o) {$/;"	f	namespace:ph
getMap	ma/maMap.cc	/^Affine getMap(apf::Mesh* m, Entity* e)$/;"	f	namespace:ma
getMatches	apf_cap/apfCAP.cc	/^void MeshCAP::getMatches(MeshEntity* e, Matches& m)$/;"	f	class:apf::MeshCAP
getMatches	apf_sim/apfSIM.cc	/^void MeshSIM::getMatches(MeshEntity* e, Matches& m)$/;"	f	class:apf::MeshSIM
getMatches	mds/apfMDS.cc	/^    void getMatches(MeshEntity* e, Matches& m)$/;"	f	class:apf::MeshMDS
getMatrix	apf/apf.cc	/^void getMatrix(Element* e, Vector3 const& param, Matrix3x3& value)$/;"	f	namespace:apf
getMatrix	apf/apf.cc	/^void getMatrix(Field* f, MeshEntity* e, int node, Matrix3x3& value)$/;"	f	namespace:apf
getMatrixGrad	apf/apf.cc	/^void getMatrixGrad(Element* e, Vector3 const& param, Vector<27>& deriv)$/;"	f	namespace:apf
getMatrixNodes	apf/apf.cc	/^void getMatrixNodes(Element* e, NewArray<Matrix3x3>& values)$/;"	f	namespace:apf
getMax	apf/apfConstruct.cc	/^static Gid getMax(const GlobalToVert& globalToVert)$/;"	f	namespace:apf
getMax	parma/extractParmaResults.py	/^getMax = lambda s: int(float(s.split()[-3])) #ehhhhh trim off the decimal$/;"	v
getMaxAndAvg	mds/mdsUgrid.cc	/^  void getMaxAndAvg(T* cnt, int numparts, double& max, double& avg) {$/;"	f	namespace:__anon101
getMaxAndAvg	mds/mdsUgrid.cc	/^  void getMaxAndAvg(std::set<int>*& cnt, int numparts, int& max, double& avg) {$/;"	f	namespace:__anon101
getMaxDist	parma/diffMC/parma_graphDist.cc	/^  unsigned* getMaxDist(apf::Mesh* m, parma::dcComponents& c, apf::MeshTag* dt) {$/;"	f	namespace:__anon74
getMaxDistSeed	parma/diffMC/parma_graphDist.cc	/^  apf::MeshEntity* getMaxDistSeed(apf::Mesh* m, CompContains* c,$/;"	f	namespace:parma_ordering
getMaxEdgeLength	ma/maQuality.cc	/^Entity* getMaxEdgeLength(Adapt* a, EntityArray& ents, double& maxLength)$/;"	f	namespace:ma
getMaxElementNodes	phasta/phOutput.cc	/^static void getMaxElementNodes(Output& o)$/;"	f	namespace:ph
getMaxNb	parma/diffMC/parma_shapeOptimizer.cc	/^  int getMaxNb(parma::Sides* s) {$/;"	f	namespace:__anon47
getMaxWeight	parma/diffMC/parma_entWeights.cc	/^  double getMaxWeight(Weights* w) {$/;"	f	namespace:parma
getMaxWeight	parma/diffMC/parma_entWeights.cc	/^  double getMaxWeight(apf::Mesh* m, apf::MeshTag* w, int entDim) {$/;"	f	namespace:parma
getMaximumEdgeLength	ma/maSize.cc	/^double getMaximumEdgeLength(Mesh* m, SizeField* sf)$/;"	f	namespace:ma
getMdlEdge	test/icesheet.cc	/^apf::ModelEntity* getMdlEdge(apf::Mesh2* mesh, int tag) {$/;"	f
getMdlFace	test/icesheet.cc	/^apf::ModelEntity* getMdlFace(apf::Mesh2* mesh, int tag) {$/;"	f
getMdlRgn	test/icesheet.cc	/^apf::ModelEntity* getMdlRgn(gmi_model* model) {$/;"	f
getMdsEntity	mds/apfMDS.cc	/^MeshEntity* getMdsEntity(Mesh2* in, int dimension, int index)$/;"	f	namespace:apf
getMdsIndex	mds/apfMDS.cc	/^int getMdsIndex(Mesh2* in, MeshEntity* e)$/;"	f	namespace:apf
getMesh	apf/apf.cc	/^Mesh* getMesh(Field* f)$/;"	f	namespace:apf
getMesh	apf/apfElement.h	/^    Mesh* getMesh() {return mesh;}$/;"	f	class:apf::Element
getMesh	apf/apfField.h	/^    Mesh* getMesh() {return mesh;}$/;"	f	class:apf::FieldBase
getMesh	apf/apfMesh.h	/^    Mesh* getMesh() {return mesh;}$/;"	f	class:apf::Migration
getMesh	apf/apfNumbering.cc	/^Mesh* getMesh(GlobalNumbering* n)$/;"	f	namespace:apf
getMesh	apf/apfNumbering.cc	/^Mesh* getMesh(Numbering* n)$/;"	f	namespace:apf
getMesh	apf_cap/apfCAP.h	/^    MeshDatabaseInterface* getMesh() { return meshInterface; }$/;"	f	class:apf::MeshCAP
getMesh	apf_sim/apfSIM.h	/^    pParMesh getMesh() { return mesh; }$/;"	f	class:apf::MeshSIM
getMesh	pumi/pumi.h	/^    pMesh getMesh() {return m;}$/;"	f	class:Distribution
getMesh	pumi/pumi.h	/^    pMesh getMesh() {return m;}$/;"	f	class:Ghosting
getMeshEdgeTags	test/icesheet.cc	/^void getMeshEdgeTags(apf::Mesh2* mesh, apf::MeshEntity* edge,$/;"	f
getMeshElement	apf/apf.cc	/^MeshElement* getMeshElement(Element* e)$/;"	f	namespace:apf
getMeshEntity	apf/apf.cc	/^MeshEntity* getMeshEntity(Element* e)$/;"	f	namespace:apf
getMeshEntity	apf/apf.cc	/^MeshEntity* getMeshEntity(MeshElement* me)$/;"	f	namespace:apf
getMetricWithMaxJacobean	ma/maQuality.cc	/^static Matrix getMetricWithMaxJacobean(Mesh* m, SizeField* sf,$/;"	f	namespace:ma
getMin	parma/extractParmaResults.py	/^getMin = lambda s: int(float(s.split()[-2])) #ehhhhh trim off the decimal$/;"	v
getMinEdgeLength	ma/maQuality.cc	/^Entity* getMinEdgeLength(Adapt* a, EntityArray& ents, double& minLength)$/;"	f	namespace:ma
getMinOrMaxEdgeLength	ma/maQuality.cc	/^static Entity* getMinOrMaxEdgeLength(Adapt* a, EntityArray& ents, double& minOrMax$/;"	f	namespace:ma
getMinQuality	ma/maShape.cc	/^double getMinQuality(Adapt* a)$/;"	f	namespace:ma
getMinimumDimension	ma/maSolutionTransfer.cc	/^static int getMinimumDimension(apf::FieldShape* s)$/;"	f	namespace:ma
getMinimumElementSize	ma/maMesh.cc	/^double getMinimumElementSize(Mesh* m)$/;"	f	namespace:ma
getMinor	apf/apfMatrix.cc	/^Matrix<M - 1, N - 1> getMinor(Matrix<M,N> const& A,$/;"	f	namespace:apf
getModel	apf_cap/apfCAP.cc	/^gmi_model* MeshCAP::getModel()$/;"	f	class:apf::MeshCAP
getModel	apf_sim/apfSIM.cc	/^gmi_model* MeshSIM::getModel()$/;"	f	class:apf::MeshSIM
getModel	ma/maEdgeSwap.cc	/^    Model* getModel() {return model;}$/;"	f	class:ma::SwapLoop
getModel	mds/apfMDS.cc	/^    gmi_model* getModel()$/;"	f	class:apf::MeshMDS
getModelEdgeTag	mds/apfMDS.cc	/^static int getModelEdgeTag(int facetag1, int facetag2, ModelEdgeTags &tags,$/;"	f	namespace:apf
getModelEntity	mds/apfBox.cc	/^ModelEntity* BoxBuilder::getModelEntity(Indices mi)$/;"	f	class:apf::BoxBuilder
getModelIndex	mds/apfBox.cc	/^int BoxBuilder::getModelIndex(int i, int d)$/;"	f	class:apf::BoxBuilder
getModelIndices	mds/apfBox.cc	/^Indices BoxBuilder::getModelIndices(Indices vi)$/;"	f	class:apf::BoxBuilder
getModelTag	apf/apfMesh.cc	/^int Mesh::getModelTag(ModelEntity* e)$/;"	f	class:apf::Mesh
getModelType	apf/apfMesh.cc	/^int Mesh::getModelType(ModelEntity* e)$/;"	f	class:apf::Mesh
getNaN	spr/sprEstimateError.cc	/^static double getNaN()$/;"	f	namespace:spr
getName	apf/apf.cc	/^const char* getName(Field* f)$/;"	f	namespace:apf
getName	apf/apfField.h	/^    const char* getName() {return name.c_str();}$/;"	f	class:apf::FieldBase
getName	apf/apfHierarchic.cc	/^    const char* getName() const { return "Hierarchic2"; }$/;"	f	class:apf::Hierarchic2
getName	apf/apfHierarchic.cc	/^    const char* getName() const { return "Hierarchic3"; }$/;"	f	class:apf::Hierarchic3
getName	apf/apfIPShape.cc	/^    const char* getName() const {return name.c_str();}$/;"	f	class:apf::ConstantIPFit
getName	apf/apfIPShape.cc	/^    const char* getName() const {return name.c_str();}$/;"	f	class:apf::IPShape
getName	apf/apfIPShape.cc	/^    const char* getName() const {return name.c_str();}$/;"	f	class:apf::LinearIPFit
getName	apf/apfIPShape.cc	/^    const char* getName() const {return name.c_str();}$/;"	f	class:apf::VoronoiShape
getName	apf/apfNumbering.cc	/^const char* getName(GlobalNumbering* n)$/;"	f	namespace:apf
getName	apf/apfNumbering.cc	/^const char* getName(Numbering* n)$/;"	f	namespace:apf
getName	apf/apfShape.cc	/^    const char* getName() const { return "Lagrange Cubic"; }$/;"	f	class:apf::LagrangeCubic
getName	apf/apfShape.cc	/^    const char* getName() const { return "Linear"; }$/;"	f	class:apf::Linear
getName	apf/apfShape.cc	/^    const char* getName() const {return "Lagrange Quadratic";}$/;"	f	class:apf::LagrangeQuadratic
getName	apf/apfShape.cc	/^    const char* getName() const {return "Serendipity Quadratic";}$/;"	f	class:apf::SerendipityQuadratic
getName	apf/apfShape.cc	/^    const char* getName() const$/;"	f	class:apf::Constant
getName	crv/crvBezier.cc	/^  const char* getName() const {return name.c_str();}$/;"	f	class:crv::Bezier
getName	crv/crvBezier.cc	/^  const char* getName() const {return name.c_str();}$/;"	f	class:crv::GregorySurface4
getName	pumi/GenTag.h	/^    std::string const& getName() {return tag_name;}$/;"	f	class:TagHandle::std
getName	test/icesheet.cc	/^std::string getName(const char* fname) {$/;"	f
getNaturalBCCodes	phasta/phGeomBC.cc	/^void getNaturalBCCodes(Output& o, int block, apf::DynamicArray<int>& codes)$/;"	f	namespace:ph
getNaturalBCValues	phasta/phGeomBC.cc	/^void getNaturalBCValues(Output& o, int block, apf::DynamicArray<double>& values)$/;"	f	namespace:ph
getNeighborCount	apf/apfMesh.cc	/^size_t MatchedSharing::getNeighborCount(int peer)$/;"	f	class:apf::MatchedSharing
getNeighborCounts	parma/parma.cc	/^  void getNeighborCounts(apf::Mesh* m, mii& nborToShared) {$/;"	f	namespace:__anon75
getNeighbors	apf/apfMesh.cc	/^void MatchedSharing::getNeighbors(Parts& neighbors)$/;"	f	class:apf::MatchedSharing
getNetAdjPartIds	parma/diffMC/maximalIndependentSet/misLuby.cc	/^  void getNetAdjPartIds(mapiuItr first, mapiuItr last, vector<int>& ids) {$/;"	f	namespace:__anon50
getNetPartIds	parma/diffMC/maximalIndependentSet/misLuby.cc	/^  void getNetPartIds(vector<int>& net, vector<int>&ids) {$/;"	f	namespace:__anon50
getNeutralElement	apf/apf.h	/^  T getNeutralElement() const { return 0; };$/;"	f	class:apf::ReductionSum
getNeutralElement	apf/apf.h	/^  T getNeutralElement() const { return std::numeric_limits<T>::max(); };$/;"	f	class:apf::ReductionMin
getNeutralElement	apf/apf.h	/^  T getNeutralElement() const { return std::numeric_limits<T>::min(); };$/;"	f	class:apf::ReductionMax
getNewCode	ma/prismCodeMatch.cc	/^int getNewCode(int oldCode, int rotation)$/;"	f
getNewCode	ma/pyramidCodeMatch.cc	/^int getNewCode(int oldCode, int rotation)$/;"	f
getNewCode	ma/tetCodeMatch.cc	/^int getNewCode(int oldCode, int rotation)$/;"	f
getNewCopies	apf/apfMigrate.cc	/^static void getNewCopies($/;"	f	namespace:apf
getNewElements	ma/maDoubleSplitCollapse.cc	/^void DoubleSplitCollapse::getNewElements(EntityArray& e)$/;"	f	class:ma::DoubleSplitCollapse
getNewElements	ma/maFaceSplitCollapse.cc	/^  void FaceSplitCollapse::getNewElements(EntityArray& e)$/;"	f	class:ma::FaceSplitCollapse
getNewModelFromOld	apf/apfConvert.cc	/^    ModelEntity* getNewModelFromOld(ModelEntity* oldC)$/;"	f	class:apf::Converter
getNewRunLog	parma/extractParmaResults.py	/^def getNewRunLog(runs):$/;"	f
getNewSize	spr/sprEstimateTargetError.cc	/^static double getNewSize(Estimation* e, apf::MeshEntity* ent)$/;"	f	namespace:spr::target
getNewTets	ma/maEdgeSwap.cc	/^    EntityArray& getNewTets() {return tets;}$/;"	f	class:ma::SwapCavity
getNewVerts	ma/maEdgeSwap.cc	/^    void getNewVerts(Entity* ntv[2][3])$/;"	f	class:ma::EdgeSwap2D
getNodeComponents	apf/apfFieldData.cc	/^void FieldDataOf<T>::getNodeComponents(MeshEntity* e, int node, T* components)$/;"	f	class:apf::FieldDataOf
getNodeData	apf/apfElement.cc	/^void Element::getNodeData()$/;"	f	class:apf::Element
getNodeValue	apf/apfFieldOf.h	/^    void getNodeValue(MeshEntity* e, int node, T* value)$/;"	f	class:apf::FieldOf
getNodeValues	apf/apfElementOf.h	/^    T* getNodeValues()$/;"	f	class:apf::ElementOf
getNodeXi	apf/apfHierarchic.cc	/^    void getNodeXi(int, int, Vector3& xi) {$/;"	f	class:apf::Hierarchic2
getNodeXi	apf/apfHierarchic.cc	/^    void getNodeXi(int, int, Vector3& xi)$/;"	f	class:apf::Hierarchic3
getNodeXi	apf/apfIPShape.cc	/^    void getNodeXi(int type, int node, Vector3& xi)$/;"	f	class:apf::ConstantIPFit
getNodeXi	apf/apfIPShape.cc	/^    void getNodeXi(int type, int node, Vector3& xi)$/;"	f	class:apf::LinearIPFit
getNodeXi	apf/apfIPShape.cc	/^    void getNodeXi(int type, int node, Vector3& xi)$/;"	f	class:apf::VoronoiShape
getNodeXi	apf/apfShape.cc	/^    void getNodeXi(int type, int node, Vector3& xi)$/;"	f	class:apf::LagrangeCubic
getNodeXi	apf/apfShape.cc	/^    void getNodeXi(int, int, Vector3& xi)$/;"	f	class:apf::Linear
getNodeXi	apf/apfShape.cc	/^    void getNodeXi(int, int, Vector3& xi)$/;"	f	class:apf::QuadraticBase
getNodeXi	apf/apfShape.cc	/^void FieldShape::getNodeXi(int, int, Vector3&)$/;"	f	class:apf::FieldShape
getNodeXi	crv/crvBezier.cc	/^  void getNodeXi(int type, int node, apf::Vector3& xi)$/;"	f	class:crv::Bezier
getNodeXi	crv/crvBezier.cc	/^  void getNodeXi(int type, int node, apf::Vector3& xi)$/;"	f	class:crv::GregorySurface4
getNodes	apf/apfNumbering.cc	/^void getNodes(GlobalNumbering* n, DynamicArray<Node>& nodes)$/;"	f	namespace:apf
getNodes	apf/apfNumbering.cc	/^void getNodes(Numbering* n, DynamicArray<Node>& nodes)$/;"	f	namespace:apf
getNodesOnClosure	apf/apfNumbering.cc	/^void getNodesOnClosure($/;"	f	namespace:apf
getNodesOnEntitySet	apf/apfNumbering.cc	/^static void getNodesOnEntitySet($/;"	f	namespace:apf
getNormal	apf/apfMesh.cc	/^void Mesh::getNormal(ModelEntity* g, Vector3 const& p, Vector3& n)$/;"	f	class:apf::Mesh
getNumComps	parma/diffMC/parma_dcpart.cc	/^unsigned dcPart::getNumComps() {$/;"	f	class:dcPart
getNumControlPoints	crv/crv.cc	/^int getNumControlPoints(int type, int order)$/;"	f	namespace:crv
getNumDcComps	parma/diffMC/parma_dcpart.cc	/^unsigned dcPart::getNumDcComps() {$/;"	f	class:dcPart
getNumExported	zoltan/apfZoltanCallbacks.h	/^    int getNumExported() {return num_exported;};$/;"	f	class:apf::ZoltanData
getNumInternalControlPoints	crv/crv.cc	/^int getNumInternalControlPoints(int type, int order)$/;"	f	namespace:crv
getNumIso	parma/diffMC/parma_dcpart.cc	/^unsigned dcPart::getNumIso() {$/;"	f	class:dcPart
getNumber	apf/apfNumbering.cc	/^int getNumber(Numbering* n, MeshEntity* e, int node, int component)$/;"	f	namespace:apf
getNumber	apf/apfNumbering.cc	/^long getNumber(GlobalNumbering* n, MeshEntity* e, int node, int component)$/;"	f	namespace:apf
getNumber	apf/apfNumbering.cc	/^long getNumber(GlobalNumbering* n, Node node, int component)$/;"	f	namespace:apf
getNumber	ma/maCrawler.cc	/^  int getNumber(Entity* v)$/;"	f	struct:ma::Tagger
getNumbering	apf/apfMesh.cc	/^Numbering* Mesh::getNumbering(int i)$/;"	f	class:apf::Mesh
getOldEdge	ma/prismCodeMatch.cc	/^int getOldEdge(int newEdge, int rotation)$/;"	f
getOldEdge	ma/pyramidCodeMatch.cc	/^int getOldEdge(int newEdge, int rotation)$/;"	f
getOldEdge	ma/tetCodeMatch.cc	/^int getOldEdge(int newEdge, int rotation)$/;"	f
getOldElements	ma/maCollapse.cc	/^void Collapse::getOldElements(EntityArray& oldElements)$/;"	f	class:ma::Collapse
getOldFaces	ma/maEdgeSwap.cc	/^    Entity** getOldFaces() { return &(oldFaces[0]); }$/;"	f	class:ma::EdgeSwap2D
getOldQuality	ma/maCollapse.cc	/^double Collapse::getOldQuality()$/;"	f	class:ma::Collapse
getOldVerts	ma/maEdgeSwap.cc	/^    void getOldVerts(Entity* otv[2][3])$/;"	f	class:ma::EdgeSwap2D
getOpposite	zoltan/apfInterElement.cc	/^static long getOpposite(GlobalNumbering* gn, MeshTag* opposites,$/;"	f	namespace:apf
getOrder	apf/apf.cc	/^int getOrder(MeshElement* e)$/;"	f	namespace:apf
getOrder	apf/apfElement.h	/^    int getOrder() {return field->getShape()->getOrder();}$/;"	f	class:apf::Element
getOrder	apf/apfHierarchic.cc	/^    int getOrder() {return 2;}$/;"	f	class:apf::Hierarchic2
getOrder	apf/apfHierarchic.cc	/^    int getOrder() {return 3;}$/;"	f	class:apf::Hierarchic3
getOrder	apf/apfIPShape.cc	/^    int getOrder() {return order;}$/;"	f	class:apf::IPBase
getOrder	apf/apfShape.cc	/^    int getOrder() {return 0;}$/;"	f	class:apf::Constant
getOrder	apf/apfShape.cc	/^    int getOrder() {return 1;}$/;"	f	class:apf::Linear
getOrder	apf/apfShape.cc	/^    int getOrder() {return 2;}$/;"	f	class:apf::QuadraticBase
getOrder	apf/apfShape.cc	/^    int getOrder() {return 3;}$/;"	f	class:apf::LagrangeCubic
getOrder	crv/crvBezier.cc	/^  int getOrder() {return 4;}$/;"	f	class:crv::GregorySurface4
getOrder	crv/crvBezier.cc	/^  int getOrder() {return P;}$/;"	f	class:crv::Bezier
getOrder	crv/crvBezier.cc	/^int getOrder()$/;"	f	namespace:crv
getOtherCopy	apf/apfMesh.cc	/^Copy getOtherCopy(Mesh* m, MeshEntity* s)$/;"	f	namespace:apf
getOtherEdge	ma/maCrawler.cc	/^Entity* getOtherEdge(Mesh* m, Entity* e, Predicate& visited)$/;"	f	namespace:ma
getOtherElem	phasta/phLinks.cc	/^static apf::MeshEntity* getOtherElem(apf::Mesh* m, apf::MeshEntity* elem,$/;"	f	namespace:ph
getOtherElement	parma/diffMC/parma_centroidSelector.cc	/^  apf::MeshEntity* getOtherElement(apf::Mesh* m, $/;"	f	namespace:__anon49
getOtherFace	ma/maEdgeSwap.cc	/^    Entity* getOtherFace(Entity* oldFace, Entity* tet)$/;"	f	class:ma::SwapLoop
getOtherPrism	ma/maLayerRefine.cc	/^static Entity* getOtherPrism(Mesh* m, Entity* tri, Predicate& visited)$/;"	f	namespace:ma
getOtherQuad	ma/maTetrahedronize.cc	/^static Entity* getOtherQuad(Adapt* a, Entity* e, Predicate& visited)$/;"	f	namespace:ma
getOtherSide	zoltan/apfInterElement.cc	/^static Copy getOtherSide(Mesh* m, MeshEntity* s)$/;"	f	namespace:apf
getOtherTet	ma/maEdgeSwap.cc	/^    Entity* getOtherTet(Entity* oldTet, Entity* face)$/;"	f	class:ma::SwapLoop
getOtherTri	ma/maLayerRefine.cc	/^static Entity* getOtherTri(Mesh* m, Entity* prism, Predicate& visited)$/;"	f	namespace:ma
getOtherVert	ma/maCrawler.cc	/^Entity* getOtherVert(Mesh* m, Entity* v, Predicate& visited)$/;"	f	namespace:ma
getOtherVtx	parma/diffMC/parma_ghostMPASWeights.cc	/^  apf::MeshEntity* getOtherVtx(apf::Mesh* m,$/;"	f	namespace:__anon61
getOwnedVtx	mds/mdsUgrid.cc	/^      void getOwnedVtx(int nvtx) {$/;"	f	class:__anon101::ptnstats
getOwner	apf/apfMesh.cc	/^int MatchedSharing::getOwner(MeshEntity* e)$/;"	f	class:apf::MatchedSharing
getOwner	apf/apfMesh.cc	/^int NormalSharing::getOwner(MeshEntity* e)$/;"	f	class:apf::NormalSharing
getOwner	apf/apfNumbering.cc	/^  int getOwner(MeshEntity*) {return PCU_Comm_Self();} $/;"	f	struct:apf::NoSharing
getOwner	apf_cap/apfCAP.cc	/^int MeshCAP::getOwner(MeshEntity* e)$/;"	f	class:apf::MeshCAP
getOwner	apf_sim/apfSIM.cc	/^int MeshSIM::getOwner(MeshEntity* e)$/;"	f	class:apf::MeshSIM
getOwner	mds/apfMDS.cc	/^    int getOwner(MeshEntity* e)$/;"	f	class:apf::MeshMDS
getOwner	parma/diffMC/parma_ghostOwner.cc	/^  int getOwner(apf::Mesh* m, apf::MeshEntity* v) {$/;"	f	namespace:parma
getOwner	phasta/phLinks.cc	/^  int getOwner(apf::MeshEntity* e)$/;"	f	struct:ph::PhastaSharing
getOwner	test/pumi.cc	/^  int getOwner(pMeshEnt e)$/;"	f	struct:testOwnership
getOwnerCopy	apf/apfMesh.cc	/^Copy MatchedSharing::getOwnerCopy(MeshEntity* e)$/;"	f	class:apf::MatchedSharing
getPME	mds/apfPM.cc	/^PME* getPME(PM& ps, apf::Parts const& ids)$/;"	f	namespace:apf
getPMent	mds/apfPM.cc	/^PME* getPMent(PM& ps, apf::Parts const& pids, int owner)$/;"	f	namespace:apf
getParam	apf_cap/apfCAP.cc	/^void MeshCAP::getParam(MeshEntity* e, Vector3& point)$/;"	f	class:apf::MeshCAP
getParam	apf_sim/apfSIM.cc	/^void MeshSIM::getParam(MeshEntity* e, Vector3& point)$/;"	f	class:apf::MeshSIM
getParam	mds/apfMDS.cc	/^    void getParam(MeshEntity* e, Vector3& p)$/;"	f	class:apf::MeshMDS
getParamOn	apf/apfMesh.cc	/^void Mesh::getParamOn(ModelEntity* g, MeshEntity* e, Vector3& p)$/;"	f	class:apf::Mesh
getParent	apf/apfElement.h	/^    VectorElement* getParent() {return parent;}$/;"	f	class:apf::Element
getPartId	zoltan/apfZoltanCallbacks.cc	/^static int getPartId(Mesh* m, MeshEntity* s)$/;"	f	namespace:apf
getPartIdFromIdx	parma/diffMC/maximalIndependentSet/test/testMIS.cc	/^int getPartIdFromIdx(int row, int col, const int sqrtTotNumParts) {$/;"	f
getPartWeights	parma/parma.cc	/^  void getPartWeights(apf::Mesh* m, apf::MeshTag* w, double (*weight)[4]) {$/;"	f	namespace:__anon75
getPeer	parma/diffMC/parma_centroidSelector.cc	/^      int getPeer(apf::MeshEntity* e) {$/;"	f	class:parma::CentroidSelector	file:
getPeers	apf/apfMesh.cc	/^void getPeers(Mesh* m, int d, Parts& peers)$/;"	f	namespace:apf
getPerfectVolume	sam/samElementCount.cc	/^double getPerfectVolume(int dim) {$/;"	f	namespace:sam
getPeriodicRange	apf/apfMesh.cc	/^bool Mesh::getPeriodicRange(ModelEntity* g, int axis, double range[2])$/;"	f	class:apf::Mesh
getPhastaType	phasta/phBlock.cc	/^static int getPhastaType(apf::Mesh* m, apf::MeshEntity* e)$/;"	f	namespace:ph
getPieceFileName	apf/apfVtk.cc	/^static std::string getPieceFileName(int id)$/;"	f	namespace:apf
getPlan	pumi/pumi_mesh.cc	/^apf::Migration* getPlan(apf::Mesh* m, int num_target_part)$/;"	f
getPlan	test/ptnParma.cc	/^apf::Migration* getPlan(apf::Mesh* m)$/;"	f	namespace:__anon10
getPlan	test/split.cc	/^apf::Migration* getPlan(apf::Mesh* m)$/;"	f	namespace:__anon13
getPlan	test/ugrid.cc	/^apf::Migration* getPlan(apf::Mesh* m, const int partitionFactor)$/;"	f
getPlan	test/zsplit.cc	/^apf::Migration* getPlan(apf::Mesh* m)$/;"	f	namespace:__anon4
getPoint	apf/apfIntegrate.cc	/^        virtual IntegrationPoint const* getPoint(int i) const$/;"	f	class:apf::EdgeIntegration::N2
getPoint	apf/apfIntegrate.cc	/^        virtual IntegrationPoint const* getPoint(int i) const$/;"	f	class:apf::EdgeIntegration::N3
getPoint	apf/apfIntegrate.cc	/^        virtual IntegrationPoint const* getPoint(int i) const$/;"	f	class:apf::EdgeIntegration::N4
getPoint	apf/apfIntegrate.cc	/^        virtual IntegrationPoint const* getPoint(int i) const$/;"	f	class:apf::EdgeIntegration::N5
getPoint	apf/apfIntegrate.cc	/^        virtual IntegrationPoint const* getPoint(int i) const$/;"	f	class:apf::EdgeIntegration::N6
getPoint	apf/apfIntegrate.cc	/^        virtual IntegrationPoint const* getPoint(int i) const$/;"	f	class:apf::HexahedronIntegration::N2
getPoint	apf/apfIntegrate.cc	/^        virtual IntegrationPoint const* getPoint(int i) const$/;"	f	class:apf::QuadIntegration::N2
getPoint	apf/apfIntegrate.cc	/^        virtual IntegrationPoint const* getPoint(int i) const$/;"	f	class:apf::QuadIntegration::N3
getPoint	apf/apfIntegrate.cc	/^        virtual IntegrationPoint const* getPoint(int i) const$/;"	f	class:apf::TetrahedronIntegration::N2
getPoint	apf/apfIntegrate.cc	/^        virtual IntegrationPoint const* getPoint(int i) const$/;"	f	class:apf::TetrahedronIntegration::N3
getPoint	apf/apfIntegrate.cc	/^        virtual IntegrationPoint const* getPoint(int i) const$/;"	f	class:apf::TetrahedronIntegration::N4
getPoint	apf/apfIntegrate.cc	/^        virtual IntegrationPoint const* getPoint(int i) const$/;"	f	class:apf::TetrahedronIntegration::N5
getPoint	apf/apfIntegrate.cc	/^        virtual IntegrationPoint const* getPoint(int i) const$/;"	f	class:apf::TetrahedronIntegration::N6
getPoint	apf/apfIntegrate.cc	/^        virtual IntegrationPoint const* getPoint(int i) const$/;"	f	class:apf::TetrahedronIntegration::N7
getPoint	apf/apfIntegrate.cc	/^        virtual IntegrationPoint const* getPoint(int i) const$/;"	f	class:apf::TriangleIntegration::N2
getPoint	apf/apfIntegrate.cc	/^        virtual IntegrationPoint const* getPoint(int i) const$/;"	f	class:apf::TriangleIntegration::N3
getPoint	apf/apfIntegrate.cc	/^        virtual IntegrationPoint const* getPoint(int i) const$/;"	f	class:apf::TriangleIntegration::N4
getPoint	apf/apfIntegrate.cc	/^        virtual IntegrationPoint const* getPoint(int i) const$/;"	f	class:apf::TriangleIntegration::N5
getPoint	apf/apfIntegrate.cc	/^        virtual IntegrationPoint const* getPoint(int i) const$/;"	f	class:apf::TriangleIntegration::N6
getPoint	apf/apfIntegrate.cc	/^        virtual IntegrationPoint const* getPoint(int) const$/;"	f	class:apf::EdgeIntegration::N1
getPoint	apf/apfIntegrate.cc	/^        virtual IntegrationPoint const* getPoint(int) const$/;"	f	class:apf::HexahedronIntegration::N1
getPoint	apf/apfIntegrate.cc	/^        virtual IntegrationPoint const* getPoint(int) const$/;"	f	class:apf::PrismIntegration::N1
getPoint	apf/apfIntegrate.cc	/^        virtual IntegrationPoint const* getPoint(int) const$/;"	f	class:apf::PyramidIntegration::N1
getPoint	apf/apfIntegrate.cc	/^        virtual IntegrationPoint const* getPoint(int) const$/;"	f	class:apf::QuadIntegration::N1
getPoint	apf/apfIntegrate.cc	/^        virtual IntegrationPoint const* getPoint(int) const$/;"	f	class:apf::TetrahedronIntegration::N1
getPoint	apf/apfIntegrate.cc	/^        virtual IntegrationPoint const* getPoint(int) const$/;"	f	class:apf::TriangleIntegration::N1
getPoint	apf/apfMesh.cc	/^void Mesh::getPoint(MeshEntity* e, int node, Vector3& p)$/;"	f	class:apf::Mesh
getPointOnEllipsoid	test/visualizeAnisoSizes.cc	/^apf::Vector3 getPointOnEllipsoid($/;"	f
getPoint_	apf_cap/apfCAP.cc	/^void MeshCAP::getPoint_(MeshEntity* e, int node, Vector3& point)$/;"	f	class:apf::MeshCAP
getPoint_	apf_sim/apfSIM.cc	/^void MeshSIM::getPoint_(MeshEntity* e, int node, Vector3& point)$/;"	f	class:apf::MeshSIM
getPoint_	mds/apfMDS.cc	/^    void getPoint_(MeshEntity* e, int, Vector3& point)$/;"	f	class:apf::MeshMDS
getPolyOrder	phasta/phBlock.cc	/^std::string getPolyOrder$/;"	f	namespace:ph
getPosition	ma/maMesh.cc	/^Vector getPosition(Mesh* m, Entity* vertex)$/;"	f	namespace:ma
getPrismDiagonalChoices	ma/maTemplates.cc	/^int getPrismDiagonalChoices(Mesh* m, Entity** v)$/;"	f	namespace:ma
getPrismDiagonalCode	ma/maTemplates.cc	/^int getPrismDiagonalCode(Mesh* m, Entity** v)$/;"	f	namespace:ma
getPrismTriCurl	ma/maLayerRefine.cc	/^static int getPrismTriCurl(Mesh* m, Entity* prism, Entity* tri)$/;"	f	namespace:ma
getPtnArray	parma/diffMC/parma_vtxPtnWriter.cc	/^  void getPtnArray(apf::Mesh* m, Ptn& p, int* ptn) {$/;"	f	namespace:__anon72
getPtr	pumi/GenIterator.h	/^   inline void* getPtr() const$/;"	f	class:GenIterator
getPvtuDirectoryStr	crv/crvVtk.cc	/^static std::string getPvtuDirectoryStr(const char* prefix, int type, int n)$/;"	f	namespace:crv
getQuadEdgeDiagonalBit	ma/maTetrahedronize.cc	/^static int getQuadEdgeDiagonalBit($/;"	f	namespace:ma
getQuadEdgeOppositeEdge	ma/maMesh.cc	/^Entity* getQuadEdgeOppositeEdge(Mesh* m, Entity* q, Entity* e)$/;"	f	namespace:ma
getQuadGmshIdx	mds/mdsGmsh.cc	/^static int getQuadGmshIdx(const int apfIdx, const int apfType) {$/;"	f	namespace:__anon96
getQuality	crv/crvQuality.cc	/^double Quality2D::getQuality(apf::MeshEntity* e)$/;"	f	class:crv::Quality2D
getQuality	crv/crvQuality.cc	/^double Quality3D::getQuality(apf::MeshEntity* e)$/;"	f	class:crv::Quality3D
getQuality	crv/crvQuality.cc	/^double getQuality(apf::Mesh* m, apf::MeshEntity* e)$/;"	f	namespace:crv
getQuality	crv/crvShapeHandler.cc	/^    virtual double getQuality(apf::MeshEntity* e)$/;"	f	class:crv::BezierHandler
getQuality	ma/maShapeHandler.cc	/^    virtual double getQuality(Entity* e)$/;"	f	class:ma::LinearHandler
getQuality	ma/maShapeHandler.cc	/^    virtual double getQuality(Entity* e)$/;"	f	class:ma::QuadraticHandler
getRandomNumber	apf/apfMIS.cc	/^  double getRandomNumber()$/;"	f	namespace:apf
getRelativePathPSource	apf/apfVtk.cc	/^static std::string getRelativePathPSource(int id)$/;"	f	namespace:apf
getRemotes	apf_cap/apfCAP.cc	/^void MeshCAP::getRemotes(MeshEntity* e, Copies& remotes)$/;"	f	class:apf::MeshCAP
getRemotes	apf_sim/apfSIM.cc	/^void MeshSIM::getRemotes(MeshEntity* e, Copies& remotes)$/;"	f	class:apf::MeshSIM
getRemotes	mds/apfMDS.cc	/^    void getRemotes(MeshEntity* e, Copies& remotes)$/;"	f	class:apf::MeshMDS
getRemotesArray	apf/apfMesh.cc	/^static void getRemotesArray(Mesh* m, MeshEntity* e, CopyArray& a)$/;"	f	namespace:apf
getResidence	apf_cap/apfCAP.cc	/^void MeshCAP::getResidence(MeshEntity* e, Parts& residence)$/;"	f	class:apf::MeshCAP
getResidence	apf_sim/apfSIM.cc	/^void MeshSIM::getResidence(MeshEntity* e, Parts& residence)$/;"	f	class:apf::MeshSIM
getResidence	mds/apfMDS.cc	/^    void getResidence(MeshEntity* e, Parts& residence)$/;"	f	class:apf::MeshMDS
getResult	apf/apfGradientByVolume.cc	/^    GT getResult() {return gradSum \/ volumeSum;}$/;"	f	class:apf::GradientIntegrator
getRigidBody	phasta/phOutput.cc	/^static void getRigidBody(Output& o, BCs& bcs, apf::Numbering* n) {$/;"	f	namespace:ph
getRow	apf/apfDynamicMatrix.h	/^    void getRow(std::size_t i, DynamicVector& r) const$/;"	f	class:apf::DynamicMatrix
getRows	apf/apfDynamicMatrix.h	/^    std::size_t getRows() const {return values.getSize()\/columns;}$/;"	f	class:apf::DynamicMatrix
getSIMField	apf_sim/apfSIM.cc	/^::Field* apf::getSIMField(apf::Field* f)$/;"	f	class:apf
getSPRSizeField	spr/sprEstimateError.cc	/^apf::Field* getSPRSizeField(apf::Field* eps, double adaptRatio)$/;"	f	namespace:spr
getSamplePoints	spr/sprRecoverField.cc	/^static void getSamplePoints(Patch* p)$/;"	f	namespace:spr
getSampleValues	spr/sprRecoverField.cc	/^static void getSampleValues(Patch* p)$/;"	f	namespace:spr
getScalar	apf/apf.cc	/^double getScalar(Element* e, Vector3 const& param)$/;"	f	namespace:apf
getScalar	apf/apf.cc	/^double getScalar(Field* f, MeshEntity* e, int node)$/;"	f	namespace:apf
getScalarNodes	apf/apf.cc	/^void getScalarNodes(Element* e, NewArray<double>& values)$/;"	f	namespace:apf
getScalarType	apf/apfField.h	/^    virtual int getScalarType() {return Mesh::DOUBLE;}$/;"	f	class:apf::Field
getScalarType	apf/apfNumbering.cc	/^int NumberingOf<int>::getScalarType() {return Mesh::INT;}$/;"	f	class:apf::NumberingOf
getScalarType	apf/apfNumbering.cc	/^int NumberingOf<long>::getScalarType() {return Mesh::LONG;}$/;"	f	class:apf::NumberingOf
getSeedEnt	parma/diffMC/parma_dcpart.cc	/^apf::MeshEntity* dcPart::getSeedEnt(unsigned i) {$/;"	f	class:dcPart
getSenders	apf/apfMigrate.cc	/^void getSenders($/;"	f	namespace:apf
getSerendipity	apf/apfShape.cc	/^FieldShape* getSerendipity()$/;"	f	namespace:apf
getShape	apf/apf.cc	/^FieldShape* getShape(Field* f)$/;"	f	namespace:apf
getShape	apf/apfElement.h	/^    EntityShape* getShape() {return shape;}$/;"	f	class:apf::Element
getShape	apf/apfField.h	/^    FieldShape* getShape() {return shape;}$/;"	f	class:apf::FieldBase
getShape	apf/apfMesh.cc	/^FieldShape* Mesh::getShape() const$/;"	f	class:apf::Mesh
getShape	apf/apfNumbering.cc	/^FieldShape* getShape(GlobalNumbering* n)$/;"	f	namespace:apf
getShape	apf/apfNumbering.cc	/^FieldShape* getShape(Numbering* n)$/;"	f	namespace:apf
getShapeByName	apf/apfShape.cc	/^FieldShape* getShapeByName(const char* name)$/;"	f	namespace:apf
getShapeGrads	apf/apf.cc	/^void getShapeGrads(Element* e, Vector3 const& local,$/;"	f	namespace:apf
getShapeHandler	crv/crvShapeHandler.cc	/^ma::ShapeHandler* getShapeHandler(ma::Adapt* a)$/;"	f	namespace:crv
getShapeHandler	ma/maShapeHandler.cc	/^ShapeHandler* getShapeHandler(Adapt* a)$/;"	f	namespace:ma
getShapeValues	apf/apf.cc	/^void getShapeValues(Element* e, Vector3 const& local,$/;"	f	namespace:apf
getSharing	apf/apfMesh.cc	/^Sharing* getSharing(Mesh* m)$/;"	f	namespace:apf
getShrinkFactor	phasta/phAdapt.cc	/^static int getShrinkFactor(apf::Mesh* m, double minPartDensity) {$/;"	f	namespace:ph
getSideElement	phasta/phLinks.cc	/^static apf::MeshEntity* getSideElement(apf::Mesh* m, apf::MeshEntity* s)$/;"	f	namespace:ph
getSideElement	zoltan/apfInterElement.cc	/^static MeshEntity* getSideElement(Mesh* m, MeshEntity* s)$/;"	f	namespace:apf
getSimField	apf_sim/apfSIMDataOf.h	/^  pField getSimField() {return fd;}$/;"	f	class:apf::SIMDataOf
getSimModelAndCase	phasta/phAttrib.cc	/^  void getSimModelAndCase(gmi_model* m, pGModel& smdl, pACase& pd) {$/;"	f	namespace:__anon79
getSimmetrixAttributes	phasta/phAttrib.cc	/^void ph::getSimmetrixAttributes(gmi_model* model, ph::BCs& bcs)$/;"	f	class:ph
getSize	apf/apfDynamicArray.h	/^    std::size_t getSize() const {return Base::size();}$/;"	f	class:apf::DynamicArray
getSize	ma/maEdgeSwap.cc	/^    int getSize() {return size;}$/;"	f	class:ma::SwapLoop
getSize	phasta/phBC.cc	/^static int getSize(std::string const& name)$/;"	f	namespace:ph
getSize	phasta/phBlock.h	/^  int getSize()$/;"	f	struct:ph::BlocksCommon
getSize	pumi/GenTag.h	/^    int getSize() {return tag_size;}$/;"	f	class:TagHandle
getSizeAndFramesFromArray	test/runSimxAnisoAdapt.cc	/^static void getSizeAndFramesFromArray($/;"	f	file:
getSizeWeight	ma/maBalance.cc	/^static double getSizeWeight(Adapt* a, Entity* e, int type)$/;"	f	namespace:ma
getSizes	ma/maSize.cc	/^  void getSizes(Entity* v, Vector& s)$/;"	f	struct:ma::BothEval
getSizesAndFrames	test/runSimxAnisoAdapt.cc	/^void getSizesAndFrames($/;"	f
getSliverCode	ma/maShape.cc	/^int getSliverCode($/;"	f	namespace:ma
getSnapPoint	ma/maSnap.cc	/^static void getSnapPoint(Mesh* m, Entity* v, Vector& x)$/;"	f	namespace:ma
getSnapPoint	ma/maSnap_mohara.cc	/^static void getSnapPoint(Mesh* m, Entity* v, Vector& x)$/;"	f	namespace:ma
getSolution	parma/diffMC/zeroOneKnapsack.c	/^size_t* getSolution(Knapsack knapsack, size_t* sz) {$/;"	f
getSplitPlan	phasta/phPartition.cc	/^apf::Migration* getSplitPlan(Input& in, apf::Mesh2* m)$/;"	f	namespace:ph
getSplitVert	ma/maFaceSplit.cc	/^Entity* FaceSplit::getSplitVert()$/;"	f	class:ma::FaceSplit
getSplitVert	ma/maSplits.cc	/^Entity* Splits::getSplitVert(int i)$/;"	f	class:ma::Splits
getSplitXi	ma/maTemplates.cc	/^Vector getSplitXi(double place, int v0, int v1)$/;"	f	namespace:ma
getStats	parma/parma.cc	/^  void getStats(int& loc, long& tot, int& min, int& max, double& avg) {$/;"	f	namespace:__anon75
getStats	test/measureAnisoStats.cc	/^void getStats($/;"	f
getStats	test/measureIsoStats.cc	/^void getStats($/;"	f
getStatsInMetricSpace	ma/maStats.cc	/^void getStatsInMetricSpace(ma::Mesh* m, ma::SizeField* sf,$/;"	f	namespace:ma
getStatsInPhysicalSpace	ma/maStats.cc	/^void getStatsInPhysicalSpace(ma::Mesh* m,$/;"	f	namespace:ma
getStkId	stk/apfSTK.cc	/^long getStkId(GlobalNumbering* numbers, Node node)$/;"	f	namespace:apf
getSuccessCount	crv/crvShapeFixer.cc	/^int CrvEdgeEdgeFixer::getSuccessCount()$/;"	f	class:crv::CrvEdgeEdgeFixer
getSuccessCount	crv/crvShapeFixer.cc	/^int CrvFaceVertFixer::getSuccessCount()$/;"	f	class:crv::CrvFaceVertFixer
getSuccessCount	crv/crvShapeFixer.cc	/^int CrvLargeAngleTetFixer::getSuccessCount()$/;"	f	class:crv::CrvLargeAngleTetFixer
getSuccessCount	crv/crvShapeFixer.cc	/^int CrvLargeAngleTriFixer::getSuccessCount()$/;"	f	class:crv::CrvLargeAngleTriFixer
getSuffix	crv/crvVtk.cc	/^static const char* getSuffix(int type)$/;"	f	namespace:crv
getSurfMaxPair	test/capStoneAttachSolution.cc	/^void getSurfMaxPair(apf::Mesh* mesh,apf::Field* lambdaMaxField,apf::Field* currentSize,double &lambda_max,double &h_lambdamax)$/;"	f
getTag	apf/apfTagData.cc	/^MeshTag* TagData::getTag(MeshEntity* e)$/;"	f	class:apf::TagData
getTag	crv/crvAdapt.cc	/^int getTag(Adapt* a, ma::Entity* e)$/;"	f	namespace:crv
getTag	mds/apfMDS.cc	/^    void getTag(MeshEntity* e, MeshTag* t, void* data)$/;"	f	class:apf::MeshMDS
getTag	pumi/GenTag.cc	/^static pTag getTag(std::set<TagHandle>::iterator const& it)$/;"	f	file:
getTagChecksum	apf_cap/apfCAP.cc	/^unsigned MeshCAP::getTagChecksum(MeshTag*,int)$/;"	f	class:apf::MeshCAP
getTagChecksum	apf_sim/apfSIM.cc	/^unsigned MeshSIM::getTagChecksum(MeshTag*,int)$/;"	f	class:apf::MeshSIM
getTagChecksum	mds/apfMDS.cc	/^    unsigned getTagChecksum(MeshTag* t, int type)$/;"	f	class:apf::MeshMDS
getTagData	pumi/GenTag.cc	/^bool Taggable::getTagData(TagHandle* tag, void* data)$/;"	f	class:Taggable
getTagName	apf_cap/apfCAP.cc	/^const char* MeshCAP::getTagName(MeshTag* tag)$/;"	f	class:apf::MeshCAP
getTagName	apf_sim/apfSIM.cc	/^const char* MeshSIM::getTagName(MeshTag* t)$/;"	f	class:apf::MeshSIM
getTagName	mds/apfMDS.cc	/^    const char* getTagName(MeshTag* t)$/;"	f	class:apf::MeshMDS
getTagSize	apf_cap/apfCAP.cc	/^int MeshCAP::getTagSize(MeshTag* tag)$/;"	f	class:apf::MeshCAP
getTagSize	apf_sim/apfSIM.cc	/^int MeshSIM::getTagSize(MeshTag* t)$/;"	f	class:apf::MeshSIM
getTagSize	mds/apfMDS.cc	/^    int getTagSize(MeshTag* t)$/;"	f	class:apf::MeshMDS
getTagString	pumi/GenTag.cc	/^const char* Taggable::getTagString(TagHandle* tag)$/;"	f	class:Taggable
getTagType	apf_cap/apfCAP.cc	/^int MeshCAP::getTagType(MeshTag* tag)$/;"	f	class:apf::MeshCAP
getTagType	apf_sim/apfSIM.cc	/^int MeshSIM::getTagType(MeshTag* t)$/;"	f	class:apf::MeshSIM
getTagType	mds/apfMDS.cc	/^    int getTagType(MeshTag* t)$/;"	f	class:apf::MeshMDS
getTaggedSend	parma/diffMC/parma_centroidSelector.cc	/^      int getTaggedSend(apf::MeshEntity* e) {$/;"	f	class:parma::CentroidSelector	file:
getTags	apf_cap/apfCAP.cc	/^void MeshCAP::getTags(DynamicArray<MeshTag*>& ts)$/;"	f	class:apf::MeshCAP
getTags	apf_sim/apfSIM.cc	/^void MeshSIM::getTags(DynamicArray<MeshTag*>& ts)$/;"	f	class:apf::MeshSIM
getTags	crv/crvAdapt.cc	/^static int getTags(Adapt* a, ma::Entity* e)$/;"	f	namespace:crv
getTags	mds/apfMDS.cc	/^    void getTags(DynamicArray<MeshTag*>& tags)$/;"	f	class:apf::MeshMDS
getTargetDimension	crv/crvShape.cc	/^  virtual int getTargetDimension() {return md;}$/;"	f	class:crv::EdgeReshaper
getTargetDimension	crv/crvShape.cc	/^  virtual int getTargetDimension() {return md;}$/;"	f	class:crv::EdgeSwapper
getTargetDimension	crv/crvShapeFixer.cc	/^int  CrvLargeAngleTetFixer::getTargetDimension()$/;"	f	class:crv::CrvLargeAngleTetFixer
getTargetDimension	crv/crvShapeFixer.cc	/^int CrvLargeAngleTriFixer::getTargetDimension()$/;"	f	class:crv::CrvLargeAngleTriFixer
getTargetDimension	crv/crvShapeFixer.cc	/^int CrvShortEdgeFixer::getTargetDimension()$/;"	f	class:crv::CrvShortEdgeFixer
getTargetDimension	ma/maCoarsen.cc	/^    virtual int getTargetDimension() {return 1;}$/;"	f	class:ma::AllEdgeCollapser
getTargetDimension	ma/maCoarsen.cc	/^    virtual int getTargetDimension() {return 1;}$/;"	f	class:ma::MatchedEdgeCollapser
getTargetDimension	ma/maShape.cc	/^    virtual int getTargetDimension() {return 1;}$/;"	f	class:ma::QualityImprover2D
getTargetDimension	ma/maShape.cc	/^    virtual int getTargetDimension() {return 2;}$/;"	f	class:ma::LargeAngleTriFixer
getTargetDimension	ma/maShape.cc	/^    virtual int getTargetDimension() {return 3;}$/;"	f	class:ma::LargeAngleTetAligner
getTargetDimension	ma/maShape.cc	/^    virtual int getTargetDimension() {return 3;}$/;"	f	class:ma::LargeAngleTetFixer
getTargetDimension	ma/maShape.cc	/^    virtual int getTargetDimension() {return mesh->getDimension();}$/;"	f	class:ma::ShortEdgeFixer
getTargetDimension	ma/maSnap.cc	/^    int getTargetDimension() {return 0;}$/;"	f	class:ma::SnapAll
getTargetDimension	ma/maSnap.cc	/^    int getTargetDimension() {return 0;}$/;"	f	class:ma::SnapMatched
getTargetDimension	ma/maSnap_mohara.cc	/^    int getTargetDimension() {return 0;}$/;"	f	class:ma::SnapAll
getTargetDimension	ma/maSnap_mohara.cc	/^    int getTargetDimension() {return 0;}$/;"	f	class:ma::SnapMatched
getTargetSPRSizeField	spr/sprEstimateTargetError.cc	/^apf::Field* getTargetSPRSizeField($/;"	f	namespace:spr
getTestField	test/fieldReduce.cc	/^apf::Field* getTestField(apf::Mesh* m, const char* fname, double addval)$/;"	f	namespace:__anon15
getTetFaceOppositeVert	ma/maSnapper.cc	/^Entity* getTetFaceOppositeVert(Mesh* m, Entity* e, Entity* v)$/;"	f	namespace:ma
getTetMap	ma/maMap.cc	/^Affine getTetMap(apf::Mesh* m, Entity* e)$/;"	f	namespace:ma
getTetNodeIndex	crv/crvTables.cc	/^int getTetNodeIndex(int P, int i, int j, int k)$/;"	f	namespace:crv
getTetPartialJacobianDet	crv/crvQuality.cc	/^static double getTetPartialJacobianDet(apf::NewArray<apf::Vector3>& nodes,$/;"	f	namespace:crv
getTetVertIdOppositeTri	ma/maFaceSplit.cc	/^static int getTetVertIdOppositeTri(Mesh* m, Entity* tet, Entity* tri)$/;"	f	namespace:ma
getTetVertOppositeFace	ma/maRegionCollapse.cc	/^static Entity* getTetVertOppositeFace(Mesh* m, Entity* r, Entity* f)$/;"	f	namespace:ma
getTetVertOppositeTri	ma/maMesh.cc	/^Entity* getTetVertOppositeTri(Mesh* m, Entity* tet, Entity* tri)$/;"	f	namespace:ma
getTets	ma/maFaceSplit.h	/^    EntityArray& getTets() {return toSplit[3];}$/;"	f	class:ma::FaceSplit
getTets	ma/maSplits.h	/^    EntityArray& getTets() {return refiner->toSplit[3];}$/;"	f	class:ma::Splits
getTime	phasta/phstream.cc	/^  inline double getTime() {$/;"	f	namespace:__anon81
getTopology	stk/apfSTK.cc	/^const CellTopologyData* getTopology(Mesh* m, int t)$/;"	f	namespace:apf
getTot	parma/extractParmaResults.py	/^getTot = lambda s: int(float(s.split()[-4])) #ehhhhh trim off the decimal$/;"	v
getTotalMass	parma/rib/parma_rib.cc	/^static double getTotalMass(Bodies const* b)$/;"	f	namespace:parma
getTotalMetricVolumeIso	sam/samElementCount.cc	/^double getTotalMetricVolumeIso(apf::Field* iso_field) {$/;"	f	namespace:sam
getTransferDimension	ma/maSolutionTransfer.cc	/^int SolutionTransfer::getTransferDimension()$/;"	f	class:ma::SolutionTransfer
getTransform	ma/maSize.cc	/^  void getTransform($/;"	f	struct:ma::AnisoSizeField
getTransform	ma/maSize.cc	/^  void getTransform($/;"	f	struct:ma::LogAnisoSizeField
getTransform	ma/maSize.cc	/^void IdentitySizeField::getTransform($/;"	f	class:ma::IdentitySizeField
getTransformationMatrix	crv/crv.cc	/^void getTransformationMatrix(apf::Mesh* m, apf::MeshEntity* e,$/;"	f	namespace:crv
getTriDetJacNodesFromTetDetJacNodes	crv/crvTables.cc	/^void getTriDetJacNodesFromTetDetJacNodes(int f, int P,$/;"	f	namespace:crv
getTriEdgeOppositeVert	ma/maMesh.cc	/^Entity* getTriEdgeOppositeVert(Mesh* m, Entity* tri, Entity* v)$/;"	f	namespace:ma
getTriFromTet	crv/crvTables.cc	/^static void getTriFromTet(int f, int P, apf::NewArray<T>& tetNodes,$/;"	f	namespace:crv
getTriJacDetNodes	crv/crvQuality.cc	/^static void getTriJacDetNodes(int P, apf::NewArray<apf::Vector3>& elemNodes,$/;"	f	namespace:crv
getTriMap	ma/maMap.cc	/^Affine getTriMap(apf::Mesh* m, Entity* e)$/;"	f	namespace:ma
getTriNodeIndex	crv/crvTables.cc	/^int getTriNodeIndex(int P, int i, int j)$/;"	f	namespace:crv
getTriNodesFromTetNodes	crv/crvTables.cc	/^void getTriNodesFromTetNodes(int f, int P,$/;"	f	namespace:crv
getTriNormal	ma/maMesh.cc	/^Vector getTriNormal(Mesh* m, Entity* e)$/;"	f	namespace:ma
getTriNormal	ma/maMesh.cc	/^Vector getTriNormal(Mesh* m, Entity** v)$/;"	f	namespace:ma
getTriPartialJacobianDet	crv/crvQuality.cc	/^static double getTriPartialJacobianDet(apf::NewArray<apf::Vector3>& nodes,$/;"	f	namespace:crv
getTriVertOppositeEdge	ma/maMesh.cc	/^Entity* getTriVertOppositeEdge(Mesh* m, Entity* tri, Entity* e)$/;"	f	namespace:ma
getTriVerts	ma/maEdgeSwap.cc	/^    void getTriVerts(int tri, Entity** v)$/;"	f	class:ma::SwapCavity
getTriangulation	ma/maEdgeSwap.cc	/^static void getTriangulation(int loopSize, int i, apf::DynamicArray<int>& t)$/;"	f	namespace:ma
getTriangulation_3	ma/maEdgeSwap.cc	/^static void getTriangulation_3(int i, apf::DynamicArray<int>& t)$/;"	f	namespace:ma
getTriangulation_4	ma/maEdgeSwap.cc	/^static void getTriangulation_4(int i, apf::DynamicArray<int>& t)$/;"	f	namespace:ma
getTriangulation_5	ma/maEdgeSwap.cc	/^static void getTriangulation_5(int i, apf::DynamicArray<int>& t)$/;"	f	namespace:ma
getTriangulation_6	ma/maEdgeSwap.cc	/^static void getTriangulation_6(int i, apf::DynamicArray<int>& t)$/;"	f	namespace:ma
getTriangulation_7	ma/maEdgeSwap.cc	/^static void getTriangulation_7(int i, apf::DynamicArray<int>& t)$/;"	f	namespace:ma
getType	apf/apfElement.h	/^    int getType() {return mesh->getType(entity);}$/;"	f	class:apf::Element
getType	apf_cap/apfCAP.cc	/^    virtual int getType() {return Mesh::DOUBLE;}$/;"	f	class:apf::DoubleTagCAP
getType	apf_cap/apfCAP.cc	/^    virtual int getType() {return Mesh::INT;}$/;"	f	class:apf::IntTagCAP
getType	apf_cap/apfCAP.cc	/^Mesh::Type MeshCAP::getType(MeshEntity* e)$/;"	f	class:apf::MeshCAP
getType	apf_sim/apfSIM.cc	/^    virtual int getType() {return Mesh::DOUBLE;}$/;"	f	class:apf::DoubleTagSIM
getType	apf_sim/apfSIM.cc	/^    virtual int getType() {return Mesh::INT;}$/;"	f	class:apf::IntTagSIM
getType	apf_sim/apfSIM.cc	/^    virtual int getType() {return Mesh::LONG;}$/;"	f	class:apf::LongTagSIM
getType	apf_sim/apfSIM.cc	/^Mesh::Type MeshSIM::getType(MeshEntity* e)$/;"	f	class:apf::MeshSIM
getType	mds/apfMDS.cc	/^    Type getType(MeshEntity* e)$/;"	f	class:apf::MeshMDS
getType	phasta/phAttrib.cc	/^static std::string getType(pAttribute a)$/;"	f	file:
getType	pumi/GenTag.h	/^    int getType() {return tag_type;}$/;"	f	class:TagHandle
getUp	apf_cap/apfCAP.cc	/^void MeshCAP::getUp(MeshEntity* e, Up& up)$/;"	f	class:apf::MeshCAP
getUp	apf_sim/apfSIM.cc	/^void MeshSIM::getUp(MeshEntity* e, Up& up)$/;"	f	class:apf::MeshSIM
getUp	mds/apfMDS.cc	/^    void getUp(MeshEntity* e, Up& up)$/;"	f	class:apf::MeshMDS
getUpBridgeAdjacent	apf/apfMesh.cc	/^static void getUpBridgeAdjacent(Mesh* m, MeshEntity* origin,$/;"	f	namespace:apf
getUpEnt	parma/diffMC/parma_meshaux.h	/^apf::MeshEntity* getUpEnt(apf::Mesh* m, apf::MeshEntity* e) {$/;"	f
getUpward	apf_cap/apfCAP.cc	/^MeshEntity* MeshCAP::getUpward(MeshEntity* e, int i)$/;"	f	class:apf::MeshCAP
getUpward	apf_sim/apfSIM.cc	/^MeshEntity* MeshSIM::getUpward(MeshEntity* e, int i)$/;"	f	class:apf::MeshSIM
getUpward	mds/apfMDS.cc	/^    MeshEntity* getUpward(MeshEntity* e, int i)$/;"	f	class:apf::MeshMDS
getUpwardCounts	apf/apfVerify.cc	/^static void getUpwardCounts(gmi_model* gm, int meshDimension, UpwardCounts& uc)$/;"	f	namespace:apf
getValidityTag	crv/crvAdapt.cc	/^int getValidityTag(ma::Mesh* m, ma::Entity* e,$/;"	f	namespace:crv
getValue	apf/apfElementOf.h	/^    T getValue(Vector3 const& local)$/;"	f	class:apf::ElementOf
getValue	dsp/dspAdapters.cc	/^    virtual double getValue(ma::Entity* v)$/;"	f	class:dsp::UniformAdapter::MyFunction
getValue	ma/maSize.cc	/^    virtual double getValue(Entity* vert)$/;"	f	class:ma::FieldReader
getValue	ma/maSize.cc	/^  void getValue(Entity* vert, Matrix& r, Vector& h)$/;"	f	struct:ma::IsoWrapper
getValue	test/aniso_ma_test.cc	/^    virtual void getValue(ma::Entity* v, ma::Matrix& R, ma::Vector& H)$/;"	f	class:AnIso
getValue	test/capStoneAnisoAdaptWing.cc	/^    virtual void getValue(ma::Entity* v, ma::Matrix& R, ma::Vector& H)$/;"	f	class:WingShock
getValue	test/capStoneIsoAdaptB737.cc	/^    virtual double getValue(ma::Entity* v)$/;"	f	class:B737
getValue	test/capStoneSizeFields.h	/^    virtual double getValue(ma::Entity* v)$/;"	f	class:GeomB737
getValue	test/capStoneSizeFields.h	/^    virtual double getValue(ma::Entity* v)$/;"	f	class:GeomRobin
getValue	test/capStoneSizeFields.h	/^    virtual double getValue(ma::Entity* v)$/;"	f	class:Linear1
getValue	test/capStoneSizeFields.h	/^    virtual double getValue(ma::Entity* v)$/;"	f	class:Linear2
getValue	test/capStoneSizeFields.h	/^    virtual double getValue(ma::Entity* v)$/;"	f	class:Linear3
getValue	test/capStoneSizeFields.h	/^    virtual double getValue(ma::Entity* v)$/;"	f	class:Uniform
getValue	test/capStoneSizeFields.h	/^    virtual void getValue(ma::Entity* v, ma::Matrix& R, ma::Vector& H)$/;"	f	class:Shock
getValue	test/capStoneSizeFields.h	/^    virtual void getValue(ma::Entity* v, ma::Matrix& R, ma::Vector& H)$/;"	f	class:UniformAniso
getValue	test/capStoneSizeFields.h	/^    virtual void getValue(ma::Entity* v, ma::Matrix& R, ma::Vector& H)$/;"	f	class:WingShock
getValue	test/curvetest.cc	/^    virtual double getValue(ma::Entity* v)$/;"	f	class:Linear
getValue	test/dg_ma_test.cc	/^    virtual double getValue(ma::Entity* v)$/;"	f	class:Linear
getValue	test/fieldReduce.cc	/^double getValue(apf::Vector3& coords, double addval)$/;"	f	namespace:__anon15
getValue	test/fusion.cc	/^    virtual void getValue($/;"	f	class:Vortex
getValue	test/fusion3.cc	/^    virtual void getValue($/;"	f	class:Vortex
getValue	test/ma_test.cc	/^    virtual double getValue(ma::Entity* v)$/;"	f	class:Linear
getValue	test/refine2x.cc	/^    void getValue(ma::Entity* v, ma::Matrix& r, ma::Vector& h) {$/;"	f	class:AnisotropicX
getValue	test/torus_ma_test.cc	/^    virtual void getValue(ma::Entity* v, ma::Matrix& R, ma::Vector& H)$/;"	f	class:CylindricalShock
getValueType	apf/apf.cc	/^int getValueType(Field* f)$/;"	f	namespace:apf
getValueType	apf/apfMatrixField.h	/^    virtual int getValueType() const {return MATRIX;}$/;"	f	class:apf::MatrixField
getValueType	apf/apfPackedField.h	/^    virtual int getValueType() const {return PACKED;}$/;"	f	class:apf::PackedField
getValueType	apf/apfScalarField.h	/^    virtual int getValueType() const {return SCALAR;}$/;"	f	class:apf::ScalarField
getValueType	apf/apfVectorField.h	/^    virtual int getValueType() const {return VECTOR;}$/;"	f	class:apf::VectorField
getValues	apf/apfElementOf.h	/^    void getValues(NewArray<T>& values)$/;"	f	class:apf::ElementOf
getValues	apf/apfHierarchic.cc	/^    void getValues($/;"	f	class:apf::HEdge2
getValues	apf/apfHierarchic.cc	/^    void getValues($/;"	f	class:apf::HEdge3
getValues	apf/apfHierarchic.cc	/^    void getValues($/;"	f	class:apf::HTetrahedron2
getValues	apf/apfHierarchic.cc	/^    void getValues($/;"	f	class:apf::HTriangle2
getValues	apf/apfHierarchic.cc	/^    void getValues($/;"	f	class:apf::HTriangle3
getValues	apf/apfHierarchic.cc	/^    void getValues($/;"	f	class:apf::HVertex
getValues	apf/apfIPShape.cc	/^        void getValues(Mesh*, MeshEntity*,$/;"	f	class:apf::ConstantIPFit::Tetrahedron
getValues	apf/apfIPShape.cc	/^        void getValues(Mesh*, MeshEntity*,$/;"	f	class:apf::ConstantIPFit::Triangle
getValues	apf/apfIPShape.cc	/^        void getValues(Mesh*, MeshEntity*,$/;"	f	class:apf::LinearIPFit::Tetrahedron
getValues	apf/apfIPShape.cc	/^        void getValues(Mesh*, MeshEntity*,$/;"	f	class:apf::LinearIPFit::Triangle
getValues	apf/apfIPShape.cc	/^        void getValues(Mesh*, MeshEntity*,$/;"	f	class:apf::VoronoiShape::Element
getValues	apf/apfShape.cc	/^        void getValues(Mesh*, MeshEntity*,$/;"	f	class:apf::Constant::Element
getValues	apf/apfShape.cc	/^        void getValues(Mesh*, MeshEntity*,$/;"	f	class:apf::LagrangeCubic::Edge
getValues	apf/apfShape.cc	/^        void getValues(Mesh*, MeshEntity*,$/;"	f	class:apf::LagrangeCubic::Tetrahedron
getValues	apf/apfShape.cc	/^        void getValues(Mesh*, MeshEntity*,$/;"	f	class:apf::LagrangeCubic::Triangle
getValues	apf/apfShape.cc	/^        void getValues(Mesh*, MeshEntity*,$/;"	f	class:apf::LagrangeCubic::Vertex
getValues	apf/apfShape.cc	/^        void getValues(Mesh*, MeshEntity*,$/;"	f	class:apf::LagrangeQuadratic::Quad
getValues	apf/apfShape.cc	/^        void getValues(Mesh*, MeshEntity*,$/;"	f	class:apf::Linear::Edge
getValues	apf/apfShape.cc	/^        void getValues(Mesh*, MeshEntity*,$/;"	f	class:apf::Linear::Hexahedron
getValues	apf/apfShape.cc	/^        void getValues(Mesh*, MeshEntity*,$/;"	f	class:apf::Linear::Prism
getValues	apf/apfShape.cc	/^        void getValues(Mesh*, MeshEntity*,$/;"	f	class:apf::Linear::Pyramid
getValues	apf/apfShape.cc	/^        void getValues(Mesh*, MeshEntity*,$/;"	f	class:apf::Linear::Quad
getValues	apf/apfShape.cc	/^        void getValues(Mesh*, MeshEntity*,$/;"	f	class:apf::Linear::Tetrahedron
getValues	apf/apfShape.cc	/^        void getValues(Mesh*, MeshEntity*,$/;"	f	class:apf::Linear::Triangle
getValues	apf/apfShape.cc	/^        void getValues(Mesh*, MeshEntity*,$/;"	f	class:apf::Linear::Vertex
getValues	apf/apfShape.cc	/^        void getValues(Mesh*, MeshEntity*,$/;"	f	class:apf::QuadraticBase::Edge
getValues	apf/apfShape.cc	/^        void getValues(Mesh*, MeshEntity*,$/;"	f	class:apf::QuadraticBase::Tetrahedron
getValues	apf/apfShape.cc	/^        void getValues(Mesh*, MeshEntity*,$/;"	f	class:apf::QuadraticBase::Triangle
getValues	apf/apfShape.cc	/^      void getValues(Mesh*, MeshEntity*,$/;"	f	class:apf::SerendipityQuadratic::Quad
getValues	crv/crvBezier.cc	/^    void getValues(apf::Mesh* \/*m*\/, apf::MeshEntity* \/*e*\/,$/;"	f	class:crv::Bezier::Edge
getValues	crv/crvBezier.cc	/^    void getValues(apf::Mesh* m, apf::MeshEntity* e, apf::Vector3 const& xi,$/;"	f	class:crv::Bezier::Triangle
getValues	crv/crvBezier.cc	/^    void getValues(apf::Mesh* m, apf::MeshEntity* e, apf::Vector3 const& xi,$/;"	f	class:crv::GregorySurface4::Triangle
getValues	crv/crvBezier.cc	/^    void getValues(apf::Mesh* m, apf::MeshEntity* e,$/;"	f	class:crv::Bezier::Tetrahedron
getValues	crv/crvBezier.cc	/^    void getValues(apf::Mesh* m, apf::MeshEntity* e,$/;"	f	class:crv::GregorySurface4::Tetrahedron
getValues	crv/crvBezier.cc	/^    void getValues(apf::Mesh*, apf::MeshEntity*,$/;"	f	class:crv::Bezier::Vertex
getVector	apf/apf.cc	/^void getVector(Element* e, Vector3 const& param, Vector3& value)$/;"	f	namespace:apf
getVector	apf/apf.cc	/^void getVector(Field* f, MeshEntity* e, int node, Vector3& value)$/;"	f	namespace:apf
getVectorGrad	apf/apf.cc	/^void getVectorGrad(Element* e, Vector3 const& param, Matrix3x3& deriv)$/;"	f	namespace:apf
getVectorNodes	apf/apf.cc	/^void getVectorNodes(Element* e, NewArray<Vector3>& values)$/;"	f	namespace:apf
getVert	ma/maEdgeSwap.cc	/^    Entity* getVert(int i) {return verts[i];}$/;"	f	class:ma::SwapLoop
getVert	ma/maSnapper.cc	/^Entity* Snapper::getVert()$/;"	f	class:ma::Snapper
getVert	ma/maVertRemover.h	/^    Entity* getVert() {return vert;}$/;"	f	class:ma::VertRemover
getVert	mds/apfBox.cc	/^MeshEntity* BoxBuilder::getVert(Indices vi)$/;"	f	class:apf::BoxBuilder
getVertDest	ma/maLayerCoarsen.cc	/^  int getVertDest(Entity* v)$/;"	f	struct:ma::CurveLocalizer
getVertIds	test/nektar_align.cc	/^static void getVertIds(apf::GlobalNumbering* n, apf::MeshEntity* e, VertIdArray& vids)$/;"	f	file:
getVertIndices	apf/apfMesh.cc	/^static int const* getVertIndices(int type, int subtype, int which)$/;"	f	namespace:apf
getVertLayers	ma/maExtrude.cc	/^Layers getVertLayers(Mesh* m, Crawler::Layer const& base_layer) {$/;"	f	namespace:ma::__anon28
getVertParams	crv/crvShapeHandler.cc	/^    void getVertParams(int ptype, apf::MeshEntity** parentVerts,$/;"	f	class:crv::BezierTransfer
getVertPoints	ma/maMap.cc	/^void getVertPoints(apf::Mesh* m, Entity* e, Vector* p)$/;"	f	namespace:ma
getVertexCenter	phasta/phModelGeometry.cc	/^static apf::Vector3 getVertexCenter(gmi_model* gm, gmi_ent* v)$/;"	f	namespace:ph
getVertexLinks	phasta/phOutput.cc	/^static void getVertexLinks(Output& o, apf::Numbering* n, BCs& bcs)$/;"	f	namespace:ph
getVertices	phasta/phAdjacent.cc	/^void getVertices(apf::Mesh* m, apf::MeshEntity* e, apf::MeshEntity** v)$/;"	f	namespace:ph
getVolMaxPair	test/capStoneAttachSolution.cc	/^void getVolMaxPair(apf::Mesh* mesh,std::vector<std::vector<apf::MeshEntity*> > surfToStrandMap, apf::Field* lambdaMaxField,apf::Field* lambdaStrandMax, apf::Field* currentSize,double &lambda_max,double &h_lambdamax)$/;"	f
getVolumeChange	sam/samElementCount.cc	/^double getVolumeChange(int dim, double h) {$/;"	f	namespace:sam
getVolumeScalar	sam/samElementCount.cc	/^double getVolumeScalar(int dim, double targetElementCount,$/;"	f	namespace:sam
getVoronoiShape	apf/apfIPShape.cc	/^FieldShape* getVoronoiShape(int dimension, int order)$/;"	f	namespace:apf
getVtuDirectoryStr	crv/crvVtk.cc	/^static std::string getVtuDirectoryStr(const char* prefix, int type, int n)$/;"	f	namespace:crv
getVtxPtn	mds/mdsUgrid.cc	/^      void getVtxPtn(int numVtx, const char* ptnFile) {$/;"	f	class:__anon101::ptnstats
getVtxSize	test/refine2x.cc	/^    void getVtxSize() {$/;"	f	class:AnisotropicX	file:
getWeakestEigenvector	parma/rib/parma_rib.cc	/^static void getWeakestEigenvector(mth::Matrix3x3<double> const& A_in,$/;"	f	namespace:parma
getWeight	ma/maSize.cc	/^  double getWeight(Entity* e)$/;"	f	struct:ma::MetricSizeField
getWeight	ma/maSize.cc	/^double IdentitySizeField::getWeight(Entity*)$/;"	f	class:ma::IdentitySizeField
getWeight	parma/diffMC/parma_entWeights.cc	/^  double getWeight(apf::Mesh* m, apf::MeshTag* w, int entDim) {$/;"	f	namespace:parma
getWeight	parma/diffMC/parma_vtxSelector.cc	/^  double VtxSelector::getWeight(apf::MeshEntity* e) {$/;"	f	class:parma::VtxSelector
getWeightedStats	parma/parma.cc	/^  void getWeightedStats($/;"	f	namespace:__anon75
getWorstQuality	ma/maQuality.cc	/^double getWorstQuality(Adapt* a, Entity** e, size_t n)$/;"	f	namespace:ma
getWorstQuality	ma/maQuality.cc	/^double getWorstQuality(Adapt* a, EntityArray& e)$/;"	f	namespace:ma
getWriter	parma/diffMC/parma_vtxPtnWriter.cc	/^    int getWriter(int id) {$/;"	f	class:__anon72::Ptn
get_cap	gmi/agm.c	/^static int get_cap(struct agm* m, enum agm_obj_type o, int subtype)$/;"	f	file:
get_chunks	test/describe.cc	/^static double get_chunks()$/;"	f	file:
get_components	apf/apfMixedNumbering.cc	/^static void get_components($/;"	f	namespace:apf
get_dim	gmi_cap/gmi_cap.cc	/^static int get_dim(gmi_model* m, gmi_ent* e)$/;"	f	file:
get_dim	gmi_sim/gmi_sim.cc	/^static int get_dim(gmi_model*, gmi_ent* e)$/;"	f	file:
get_down	gmi/gmi_base.c	/^static struct gmi_set* get_down(struct agm* topo, struct agm_ent e)$/;"	f	file:
get_down	mds/mds.c	/^static void get_down(struct mds* m, mds_id e, int d, struct mds_set* out)$/;"	f	file:
get_elem_sets	stk/apfSTK.cc	/^ElemSets get_elem_sets(Mesh* mesh, StkModels* sets) {$/;"	f	namespace:apf
get_highest_dof_dim	apf/apfMixedNumbering.cc	/^static int get_highest_dof_dim($/;"	f	namespace:apf
get_msg	pcu/pcu.c	/^static pcu_msg* get_msg()$/;"	f	file:
get_node_sets	stk/apfSTK.cc	/^NodeSets get_node_sets(Mesh* mesh, StkModels* sets, GlobalNumbering* nmbr) {$/;"	f	namespace:apf
get_one_level_adj	pumi/pumi_gentity.cc	/^void get_one_level_adj (pGeom g, std::set<pGeomEnt>& ents, $/;"	f
get_peak	test/describe.cc	/^static double get_peak()$/;"	f	file:
get_reflector	mth/mthQR.cc	/^static bool get_reflector($/;"	f	namespace:mth
get_shapes	apf/apfMixedNumbering.cc	/^static void get_shapes($/;"	f	namespace:apf
get_side_sets	stk/apfSTK.cc	/^SideSets get_side_sets(Mesh* mesh, StkModels* sets) {$/;"	f	namespace:apf
get_stk_side	stk/apfMeshSTK.cc	/^static void get_stk_side(GlobalNumbering* en, MeshEntity* side,$/;"	f	namespace:apf
get_tag	gmi/gmi_lookup.c	/^static int* get_tag(struct gmi_lookup* l, struct agm_ent e)$/;"	f	file:
get_tag	gmi_cap/gmi_cap.cc	/^static int get_tag(gmi_model* m, gmi_ent* e)$/;"	f	file:
get_tag	gmi_sim/gmi_sim.cc	/^static int get_tag(gmi_model*, gmi_ent* e)$/;"	f	file:
get_up	gmi/gmi_base.c	/^static struct gmi_set* get_up(struct agm* topo, struct agm_ent e)$/;"	f	file:
get_up	mds/mds.c	/^static void get_up(struct mds* m, mds_id e, int d, struct mds_set* out)$/;"	f	file:
get_wilkinson_shift	mth/mthQR.cc	/^static double get_wilkinson_shift(Matrix<T,M,M> const& a, unsigned red_m)$/;"	f	namespace:mth
get_xgc_plan	test/xgc_split.cc	/^Migration* get_xgc_plan(pGeom g, pMesh m)$/;"	f
ghost_collectEntities	pumi/pumi_ghost.cc	/^static void ghost_collectEntities (pMesh m, Ghosting* plan, EntityVector entitiesToGhost[4])$/;"	f	file:
ghost_dim	pumi/pumi.h	/^    int ghost_dim;$/;"	m	class:Ghosting
ghost_receiveEntities	pumi/pumi_ghost.cc	/^static void ghost_receiveEntities(Ghosting* plan, apf::DynamicArray<pMeshTag>& tags,$/;"	f	file:
ghost_sendEntities	pumi/pumi_ghost.cc	/^void ghost_sendEntities(Ghosting* plan, int entDim,$/;"	f
ghost_tag	pumi/pumi.h	/^  pMeshTag ghost_tag;$/;"	m	class:pumi
ghost_vec	pumi/pumi.h	/^  std::vector<pMeshEnt> ghost_vec[4];$/;"	m	class:pumi
ghosted_tag	pumi/pumi.h	/^  pMeshTag ghosted_tag;$/;"	m	class:pumi
ghosted_vec	pumi/pumi.h	/^  std::vector<pMeshEnt> ghosted_vec[4];$/;"	m	class:pumi
ghosts	mds/mds_apf.h	/^  struct mds_net ghosts;$/;"	m	struct:mds_apf	typeref:struct:mds_apf::mds_net
gidSz	zoltan/apfZoltanCallbacks.h	/^    int gidSz;$/;"	m	class:apf::ZoltanData
global	test/test_matrix_grad.cc	/^    apf::Vector3 global;$/;"	m	class:CheckMatrixDerivIntegrator	file:
global	test/test_matrix_grad.cc	/^    apf::Vector3 global;$/;"	m	class:MatrixDerivIntegrator	file:
global	zoltan/apfZoltanMesh.h	/^    GlobalNumbering* global;$/;"	m	class:apf::ZoltanMesh
globalCode	test/fusion2.cc	/^static void globalCode(apf::Mesh2* m)$/;"	f	file:
globalNodeNumbers	phasta/phOutput.h	/^  int* globalNodeNumbers;$/;"	m	struct:ph::EnsaArrays
globalNumberings	apf/apfMesh.h	/^    std::vector<GlobalNumbering*> globalNumberings;$/;"	m	class:apf::Mesh
global_mpi	pcu/pcu_mpi.c	/^static pcu_mpi* global_mpi;$/;"	v	file:
global_pmsg	pcu/pcu.c	/^static pcu_msg global_pmsg;$/;"	v	file:
global_rank	pcu/pcu_pmpi.c	/^static int global_rank;$/;"	v	file:
global_size	pcu/pcu_pmpi.c	/^static int global_size;$/;"	v	file:
global_state	pcu/pcu.c	/^static enum state global_state = uninit;$/;"	v	typeref:enum:state	file:
globalize	apf/apfMixedNumbering.cc	/^static void globalize($/;"	f	namespace:apf
globalize	apf/apfNumbering.cc	/^static void globalize(GlobalNumbering* n)$/;"	f	namespace:apf
globalize	apf/apfNumbering.cc	/^void globalize(Numbering* n)$/;"	f	namespace:apf
globals_to_osh	omega_h/apfOmega_h.cc	/^static void globals_to_osh($/;"	f	namespace:apf
gmi_add_analytic	gmi/gmi_analytic.c	/^struct gmi_ent* gmi_add_analytic(struct gmi_model* m, int dim, int tag,$/;"	f
gmi_add_analytic_cell	gmi/gmi_analytic.c	/^void gmi_add_analytic_cell(struct gmi_model* m, int dim, int tag)$/;"	f
gmi_add_analytic_region	gmi/gmi_analytic.c	/^void gmi_add_analytic_region(struct gmi_model* m, int tag)$/;"	f
gmi_add_analytic_reparam	gmi/gmi_analytic.c	/^void gmi_add_analytic_reparam(struct gmi_model* m, struct agm_use u,$/;"	f
gmi_adjacent	gmi/gmi.c	/^struct gmi_set* gmi_adjacent(struct gmi_model* m, struct gmi_ent* e, int dim)$/;"	f
gmi_analytic	gmi/gmi_analytic.c	/^struct gmi_analytic$/;"	s	file:
gmi_analytic_data	gmi/gmi_analytic.c	/^void* gmi_analytic_data(struct gmi_model* m, struct gmi_ent* e)$/;"	f
gmi_analytic_fun	gmi/gmi_analytic.h	/^typedef void (*gmi_analytic_fun)(double const p[2], double x[3], void* u);$/;"	t
gmi_analytic_reparam_data	gmi/gmi_analytic.c	/^void* gmi_analytic_reparam_data(struct gmi_model* m, struct agm_use u)$/;"	f
gmi_analytic_topo	gmi/gmi_analytic.h	56;"	d
gmi_base	gmi/gmi_base.h	/^struct gmi_base {$/;"	s
gmi_base_adjacent	gmi/gmi_base.c	/^struct gmi_set* gmi_base_adjacent(struct gmi_model* m, struct gmi_ent* e,$/;"	f
gmi_base_begin	gmi/gmi_base.c	/^struct gmi_iter* gmi_base_begin(struct gmi_model* m, int dim)$/;"	f
gmi_base_destroy	gmi/gmi_base.c	/^void gmi_base_destroy(struct gmi_model* m)$/;"	f
gmi_base_dim	gmi/gmi_base.c	/^int gmi_base_dim(struct gmi_model* m, struct gmi_ent* e)$/;"	f
gmi_base_end	gmi/gmi_base.c	/^void gmi_base_end(struct gmi_model* m, struct gmi_iter* i)$/;"	f
gmi_base_find	gmi/gmi_base.c	/^struct gmi_ent* gmi_base_find(struct gmi_model* m, int dim, int tag)$/;"	f
gmi_base_freeze	gmi/gmi_base.c	/^void gmi_base_freeze(struct gmi_model* m)$/;"	f
gmi_base_identify	gmi/gmi_base.c	/^struct gmi_ent* gmi_base_identify(int dim, int idx)$/;"	f
gmi_base_index	gmi/gmi_base.c	/^int gmi_base_index(struct gmi_ent* e)$/;"	f
gmi_base_init	gmi/gmi_base.c	/^void gmi_base_init(struct gmi_base* m)$/;"	f
gmi_base_next	gmi/gmi_base.c	/^struct gmi_ent* gmi_base_next(struct gmi_model* m, struct gmi_iter* it)$/;"	f
gmi_base_ops	gmi/gmi_base.c	/^struct gmi_model_ops gmi_base_ops = {$/;"	v	typeref:struct:gmi_model_ops
gmi_base_read_dmg	gmi/gmi_file.c	/^void gmi_base_read_dmg(struct gmi_base* m, FILE* f)$/;"	f
gmi_base_read_tess	gmi/gmi_file.c	/^void gmi_base_read_tess(struct gmi_base* m, FILE* f)$/;"	f
gmi_base_reserve	gmi/gmi_base.c	/^void gmi_base_reserve(struct gmi_base* m, int dim, int n)$/;"	f
gmi_base_set_tag	gmi/gmi_base.c	/^void gmi_base_set_tag(struct gmi_model* m, struct gmi_ent* e, int tag)$/;"	f
gmi_base_tag	gmi/gmi_base.c	/^int gmi_base_tag(struct gmi_model* m, struct gmi_ent* e)$/;"	f
gmi_base_topo	gmi/gmi_base.c	/^struct agm* gmi_base_topo(struct gmi_model* m)$/;"	f
gmi_base_unfreeze	gmi/gmi_base.c	/^void gmi_base_unfreeze(struct gmi_model* m)$/;"	f
gmi_begin	gmi/gmi.c	/^struct gmi_iter* gmi_begin(struct gmi_model* m, int dim)$/;"	f
gmi_can_eval	gmi/gmi.c	/^int gmi_can_eval(struct gmi_model* m)$/;"	f
gmi_can_get_closest_point	gmi/gmi.c	/^int gmi_can_get_closest_point(struct gmi_model* m)$/;"	f
gmi_cap_start	gmi_cap/gmi_cap.cc	/^void gmi_cap_start(void)$/;"	f
gmi_cap_stop	gmi_cap/gmi_cap.cc	/^void gmi_cap_stop(void)$/;"	f
gmi_closest_point	gmi/gmi.c	/^void gmi_closest_point(struct gmi_model* m, struct gmi_ent* e,$/;"	f
gmi_creator	gmi/gmi.h	/^typedef struct gmi_model* (*gmi_creator)(const char* filename);$/;"	t	typeref:struct:gmi_creator
gmi_destroy	gmi/gmi.c	/^void gmi_destroy(struct gmi_model* m)$/;"	f
gmi_dim	gmi/gmi.c	/^int gmi_dim(struct gmi_model* m, struct gmi_ent* e)$/;"	f
gmi_end	gmi/gmi.c	/^void gmi_end(struct gmi_model* m, struct gmi_iter* i)$/;"	f
gmi_eval	gmi/gmi.c	/^void gmi_eval(struct gmi_model* m, struct gmi_ent* e,$/;"	f
gmi_export_cap	gmi_cap/gmi_cap.cc	/^GeometryDatabaseInterface* gmi_export_cap(gmi_model* m)$/;"	f
gmi_export_sim	gmi_sim/gmi_sim.cc	/^SGModel* gmi_export_sim(gmi_model* m)$/;"	f
gmi_fail	gmi/gmi.c	/^void gmi_fail(const char* why)$/;"	f
gmi_find	gmi/gmi.c	/^struct gmi_ent* gmi_find(struct gmi_model* m, int dim, int tag)$/;"	f
gmi_first_derivative	gmi/gmi.c	/^void gmi_first_derivative(struct gmi_model* m, struct gmi_ent* e,$/;"	f
gmi_free_lookup	gmi/gmi_lookup.c	/^void gmi_free_lookup(struct gmi_lookup* l)$/;"	f
gmi_free_set	gmi/gmi.c	/^void gmi_free_set(struct gmi_set* s)$/;"	f
gmi_freeze_lookup	gmi/gmi_lookup.c	/^void gmi_freeze_lookup(struct gmi_lookup* l, enum agm_ent_type t)$/;"	f
gmi_from_agm	gmi/gmi_base.c	/^struct gmi_ent* gmi_from_agm(struct agm_ent e)$/;"	f
gmi_fscanf	gmi/gmi_file.c	/^void gmi_fscanf(FILE* f, int n, const char* format, ...)$/;"	f
gmi_get_lookup	gmi/gmi_lookup.c	/^int gmi_get_lookup(struct gmi_lookup* l, struct agm_ent e)$/;"	f
gmi_getline	gmi/gmi_file.c	/^int gmi_getline(char** line, size_t* cap, FILE* f)$/;"	f
gmi_has_ext	gmi/gmi.c	/^int gmi_has_ext(const char* filename, const char* ext)$/;"	f
gmi_has_normal	gmi/gmi.c	/^int gmi_has_normal(struct gmi_model* m)$/;"	f
gmi_import_cap	gmi_cap/gmi_cap.cc	/^gmi_model* gmi_import_cap(GeometryDatabaseInterface* gi)$/;"	f
gmi_import_sim	gmi_sim/gmi_sim.cc	/^gmi_model* gmi_import_sim(SGModel* sm)$/;"	f
gmi_is_discrete_ent	gmi/gmi.c	/^int gmi_is_discrete_ent(struct gmi_model* m, struct gmi_ent* e)$/;"	f
gmi_is_in_closure_of	gmi/gmi.c	/^int gmi_is_in_closure_of(struct gmi_model* m, struct gmi_ent* e,$/;"	f
gmi_is_point_in_region	gmi/gmi.c	/^int gmi_is_point_in_region(struct gmi_model* m, struct gmi_ent* e,$/;"	f
gmi_load	gmi/gmi.c	/^struct gmi_model* gmi_load(const char* filename)$/;"	f
gmi_look_up	gmi/gmi_lookup.c	/^struct agm_ent gmi_look_up(struct gmi_lookup* l, enum agm_ent_type t, int tag)$/;"	f
gmi_lookup	gmi/gmi_lookup.c	/^struct gmi_lookup {$/;"	s	file:
gmi_make_analytic	gmi/gmi_analytic.c	/^struct gmi_model* gmi_make_analytic(void)$/;"	f
gmi_make_set	gmi/gmi.c	/^struct gmi_set* gmi_make_set(int n)$/;"	f
gmi_model	gmi/gmi.h	/^struct gmi_model {$/;"	s
gmi_model_ops	gmi/gmi.h	/^struct gmi_model_ops {$/;"	s
gmi_native_path	phasta/ph_convert.cc	/^const char* gmi_native_path = NULL;$/;"	v
gmi_native_path	test/convert.cc	/^const char* gmi_native_path = NULL;$/;"	v
gmi_native_path	test/rm_extrusion.cc	/^const char* gmi_native_path = NULL;$/;"	v
gmi_new_lookup	gmi/gmi_lookup.c	/^struct gmi_lookup* gmi_new_lookup(struct agm* topo)$/;"	f
gmi_next	gmi/gmi.c	/^struct gmi_ent* gmi_next(struct gmi_model* m, struct gmi_iter* i)$/;"	f
gmi_normal	gmi/gmi.c	/^void gmi_normal(struct gmi_model* m, struct gmi_ent* e,$/;"	f
gmi_null_find	gmi/gmi_null.c	/^struct gmi_ent* gmi_null_find(struct gmi_model* m, int dim, int tag)$/;"	f
gmi_path	phasta/ph_convert.cc	/^const char* gmi_path = NULL;$/;"	v
gmi_path	test/convert.cc	/^const char* gmi_path = NULL;$/;"	v
gmi_path	test/rm_extrusion.cc	/^const char* gmi_path = NULL;$/;"	v
gmi_periodic	gmi/gmi.c	/^int gmi_periodic(struct gmi_model* m, struct gmi_ent* e, int dim)$/;"	f
gmi_range	gmi/gmi.c	/^void gmi_range(struct gmi_model* m, struct gmi_ent* e, int dim,$/;"	f
gmi_register	gmi/gmi.c	/^void gmi_register(gmi_creator f, const char* ext)$/;"	f
gmi_register_cap	gmi_cap/gmi_cap.cc	/^void gmi_register_cap(void)$/;"	f
gmi_register_mesh	gmi/gmi_mesh.c	/^void gmi_register_mesh(void)$/;"	f
gmi_register_null	gmi/gmi_null.c	/^void gmi_register_null(void)$/;"	f
gmi_register_sim	gmi_sim/gmi_sim.cc	/^void gmi_register_sim(void)$/;"	f
gmi_reparam	gmi/gmi.c	/^void gmi_reparam(struct gmi_model* m, struct gmi_ent* from,$/;"	f
gmi_reparam_fun	gmi/gmi_analytic.h	/^typedef void (*gmi_reparam_fun)(double const from[2], double to[2], void* u);$/;"	t
gmi_set	gmi/gmi.h	/^struct gmi_set {$/;"	s
gmi_set_lookup	gmi/gmi_lookup.c	/^void gmi_set_lookup(struct gmi_lookup* l, struct agm_ent e, int tag)$/;"	f
gmi_sim_load	gmi_sim/gmi_sim.cc	/^struct gmi_model* gmi_sim_load(const char* nativefile, const char* smdfile)$/;"	f
gmi_sim_start	gmi_sim/gmi_sim.cc	/^void gmi_sim_start(void)$/;"	f
gmi_sim_stop	gmi_sim/gmi_sim.cc	/^void gmi_sim_stop(void)$/;"	f
gmi_tag	gmi/gmi.c	/^int gmi_tag(struct gmi_model* m, struct gmi_ent* e)$/;"	f
gmi_unfreeze_lookups	gmi/gmi_lookup.c	/^void gmi_unfreeze_lookups(struct gmi_lookup* l)$/;"	f
gmi_write_dmg	gmi/gmi.c	/^void gmi_write_dmg(struct gmi_model* m, const char* filename)$/;"	f
gmshTet10EdgeIndices	mds/mdsGmsh.cc	/^static const double gmshTet10EdgeIndices[6] = {0, 1, 2, 3, 5, 4};$/;"	m	namespace:__anon96	file:
goToParentDir	phasta/ph.cc	/^void goToParentDir() {$/;"	f	namespace:ph
goToStepDir	phasta/ph.cc	/^void goToStepDir(int step, bool all_mkdir)$/;"	f	namespace:ph
goodQuality	ma/maInput.h	/^    double goodQuality;$/;"	m	class:ma::Input
good_diagonal_codes	ma/maTetrahedronize.cc	/^  int good_diagonal_codes;$/;"	m	struct:ma::UnsafePrismOverride	file:
good_rotation	ma/maTetrahedronize.cc	/^  int good_rotation;$/;"	m	struct:ma::UnsafePyramidOverride	file:
grad	apf/apfMatrixElement.cc	/^void MatrixElement::grad(Vector3 const& xi, Vector<27>& g)$/;"	f	class:apf::MatrixElement
grad	apf/apfScalarElement.cc	/^void ScalarElement::grad(Vector3 const& local, Vector3& g)$/;"	f	class:apf::ScalarElement
grad	apf/apfVectorElement.cc	/^void VectorElement::grad(Vector3 const& xi, Matrix3x3& g)$/;"	f	class:apf::VectorElement
gradHelper	apf/apfVectorElement.cc	/^void VectorElement::gradHelper($/;"	f	class:apf::VectorElement
gradSum	apf/apfGradientByVolume.cc	/^    GT gradSum;$/;"	m	class:apf::GradientIntegrator	file:
gradeMesh	test/capStoneAttachSolution.cc	/^int gradeMesh(apf::Mesh* m,apf::Field* size_iso)$/;"	f
gradeSize	test/capStoneIsoAdaptB737.cc	/^void gradeSize(apf::Mesh2* m, apf::Field* f, double beta)$/;"	f
gradeSizeModify	test/capStoneAttachSolution.cc	/^int gradeSizeModify(apf::Mesh* m, apf::Field* size_iso,double gradingFactor, $/;"	f
gradf	apf/apfGradientByVolume.cc	/^    Field* gradf;$/;"	m	class:apf::RecoverGradient	file:
gradingFactor	phasta/phInput.h	/^    double gradingFactor;$/;"	m	class:ph::Input
grid	mds/apfBox.h	/^  Grid grid;$/;"	m	struct:apf::BoxBuilder
grow	gmi/agm.c	/^static void grow(int* n)$/;"	f	file:
grow	mds/mds.c	/^static void grow(struct mds* m, int t)$/;"	f	file:
grow_tag	gmi/agm.c	/^static void grow_tag(struct agm_tag* t, enum agm_obj_type o, int subtype)$/;"	f	file:
grow_tag	mds/mds_tag.c	/^static void grow_tag($/;"	f	file:
grow_tags	gmi/agm.c	/^static void grow_tags(struct agm_tags* ts, enum agm_obj_type o, int subtype)$/;"	f	file:
grs	phasta/phOutput.h	/^  GRStream* grs;$/;"	m	struct:ph::Output
grstream	phasta/phstream.h	/^typedef struct GRStream* grstream;$/;"	t	typeref:struct:GRStream
gvtx	test/fusion3.cc	/^double gvtx[6][3]={{1.016280, -0.491436, 0.000000},$/;"	v
h	mds/apfMDS.cc	/^  std::set<apf::MeshEntity*> h;$/;"	m	struct:apf::Queue	file:
hField	ma/maSize.cc	/^  apf::Field* hField;$/;"	m	struct:ma::AnisoSizeField	file:
hackMdsAdjacency	mds/apfMDS.cc	/^void hackMdsAdjacency(Mesh2* in, MeshEntity* up, int i, MeshEntity* down)$/;"	f	namespace:apf
halves	ma/maEdgeSwap.cc	/^    SwapCavity halves[2];$/;"	m	class:ma::EdgeSwap3D	file:
handle	ma/maLayerCoarsen.cc	/^  bool handle(Entity* v, int dest)$/;"	f	struct:ma::CurveLocalizer
handle	ma/maLayerRefine.cc	/^  void handle(Entity* e, bool split)$/;"	f	struct:ma::SplitTagger
handle	ma/maLayerSnap.cc	/^  void handle(Entity* v, bool alreadyUnsnapping)$/;"	f	struct:ma::UnsnapChecker
handle	ma/maLayerSnap.cc	/^  void handle(Entity* v, bool shouldSnap)$/;"	f	struct:ma::LayerSnapper
handle	ma/maLayerSnap.cc	/^  void handle(Entity* v, bool shouldUnsnap)$/;"	f	struct:ma::Unsnapper
handle	pumi/GenTag.h	/^      TagHandle* handle;$/;"	m	struct:Taggable::Entry
handleCheck	ma/maLayerCoarsen.cc	/^  bool handleCheck(Entity* v)$/;"	f	struct:ma::CurveLocalizer
handle_path	mds/mds_smb.c	/^static char* handle_path(const char* in, int is_write, int* zip,$/;"	f	file:
has	apf/apfMesh.cc	/^bool Migration::has(MeshEntity* e)$/;"	f	class:apf::Migration
has	apf_cap/apfCAP.cc	/^    bool has(MeshEntity* e)$/;"	f	class:apf::TagCAP
has	apf_sim/apfSIM.cc	/^    bool has(MeshEntity* e)$/;"	f	class:apf::TagSIM
has	mds/apfMDS.cc	/^  bool has(apf::MeshEntity* e) { return h.count(e); }$/;"	f	struct:apf::Queue
has	mds/mds_tag.h	/^  unsigned char* has[MDS_TYPES];$/;"	m	struct:mds_tag
has	parma/diffMC/parma_associative.h	/^      bool has(int key) {$/;"	f	class:parma::Associative
has	parma/diffMC/parma_components.cc	/^  bool DCC::has(apf::MeshEntity* e) { return m->hasTag(e, idT); }$/;"	f	class:parma::DCC
has	parma/diffMC/parma_components.cc	/^  bool dcComponents::has(apf::MeshEntity* e) { return c->has(e); }$/;"	f	class:parma::dcComponents
has	parma/diffMC/parma_graphDist.cc	/^      bool has(apf::MeshEntity* e) {$/;"	f	class:__anon74::CompContains
has	parma/diffMC/parma_graphDist.cc	/^      bool has(apf::MeshEntity*) {$/;"	f	class:__anon74::CompUpdateContains
has	pumi/pumi_ghost.cc	/^bool Ghosting::has(pMeshEnt e)$/;"	f	class:Ghosting
has	pumi/pumi_mesh.cc	/^bool Distribution::has(pMeshEnt e)$/;"	f	class:Distribution
hasAdjacency	apf_cap/apfCAP.cc	/^bool MeshCAP::hasAdjacency(int from_dim, int to_dim)$/;"	f	class:apf::MeshCAP
hasAdjacency	apf_sim/apfSIM.cc	/^bool MeshSIM::hasAdjacency(int from_dim, int to_dim)$/;"	f	class:apf::MeshSIM
hasAdjacency	mds/apfMDS.cc	/^    bool hasAdjacency(int from_dim, int to_dim)$/;"	f	class:apf::MeshMDS
hasAnySerendipity	apf_sim/apfSIM.cc	/^static bool hasAnySerendipity(pParMesh mesh)$/;"	f	namespace:apf
hasDGInterface	phasta/phOutput.h	/^  bool hasDGInterface;$/;"	m	struct:ph::Output
hasDistance	parma/diffMC/parma_graphDist.cc	/^  bool hasDistance(apf::Mesh* m) {$/;"	f	namespace:__anon74
hasDistance	parma/diffMC/parma_graphDist.cc	/^  bool hasDistance(apf::Mesh* m, apf::MeshTag* dist) {$/;"	f	namespace:__anon74
hasDuplicates	apf/apfVerify.cc	/^static bool hasDuplicates(Matches const& matches) {$/;"	f	namespace:apf
hasEnoughPoints	spr/sprRecoverField.cc	/^static bool hasEnoughPoints(Patch* p)$/;"	f	namespace:spr
hasEntWeight	parma/parma.cc	/^  void hasEntWeight(apf::Mesh* m, apf::MeshTag* w, int (*hasWeight)[4]) {$/;"	f	namespace:__anon75
hasEntity	apf/apf.cc	/^bool hasEntity(Field* f, MeshEntity* e)$/;"	f	namespace:apf
hasEntity	apf/apfArrayData.cc	/^    virtual bool hasEntity(MeshEntity*)$/;"	f	class:apf::ArrayDataOf
hasEntity	apf/apfCoordData.cc	/^bool CoordData::hasEntity(MeshEntity* e)$/;"	f	class:apf::CoordData
hasEntity	apf/apfTagData.cc	/^bool TagData::hasEntity(MeshEntity* e)$/;"	f	class:apf::TagData
hasEntity	apf/apfTagData.h	/^    virtual bool hasEntity(MeshEntity* e) {return tagData.hasEntity(e);}$/;"	f	class:apf::TagDataOf
hasEntity	apf/apfUserData.cc	/^bool UserData::hasEntity(MeshEntity* e)$/;"	f	class:apf::UserData
hasEntity	apf_sim/apfSIMDataOf.h	/^  virtual bool hasEntity(MeshEntity *)$/;"	f	class:apf::SIMDataOf
hasExtension	test/generate.cc	/^bool hasExtension(std::string s, std::string ext) {$/;"	f	namespace:__anon19
hasFrozenFields	apf/apfMesh.h	/^    bool hasFrozenFields;$/;"	m	class:apf::Mesh
hasLayer	ma/maAdapt.h	/^    bool hasLayer;$/;"	m	class:ma::Adapt
hasLink	ma/maLayerSnap.cc	/^  bool hasLink(Entity* v)$/;"	f	struct:ma::BaseTopLinker
hasMatch	apf/apfVerify.cc	/^static bool hasMatch($/;"	f	namespace:apf
hasMatches	apf_sim/apfSIM.h	/^    bool hasMatches;$/;"	m	class:apf::MeshSIM
hasMatching	apf_cap/apfCAP.h	/^    bool hasMatching() { return false; }$/;"	f	class:apf::MeshCAP
hasMatching	apf_sim/apfSIM.h	/^    bool hasMatching() {return hasMatches;}$/;"	f	class:apf::MeshSIM
hasMatching	mds/apfMDS.cc	/^    bool hasMatching()$/;"	f	class:apf::MeshMDS
hasNode	mds/apfMDS.cc	/^bool hasNode(Mesh* m, MeshEntity* e)$/;"	f	namespace:apf
hasNodesIn	apf/apfHierarchic.cc	/^    bool hasNodesIn(int dimension) {$/;"	f	class:apf::Hierarchic2
hasNodesIn	apf/apfHierarchic.cc	/^    bool hasNodesIn(int dimension)$/;"	f	class:apf::Hierarchic3
hasNodesIn	apf/apfIPShape.cc	/^    bool hasNodesIn(int d)$/;"	f	class:apf::IPBase
hasNodesIn	apf/apfShape.cc	/^    bool hasNodesIn(int dimension)$/;"	f	class:apf::Constant
hasNodesIn	apf/apfShape.cc	/^    bool hasNodesIn(int dimension)$/;"	f	class:apf::LagrangeCubic
hasNodesIn	apf/apfShape.cc	/^    bool hasNodesIn(int dimension)$/;"	f	class:apf::LagrangeQuadratic
hasNodesIn	apf/apfShape.cc	/^    bool hasNodesIn(int dimension)$/;"	f	class:apf::Linear
hasNodesIn	apf/apfShape.cc	/^    bool hasNodesIn(int dimension)$/;"	f	class:apf::SerendipityQuadratic
hasNodesIn	crv/crvBezier.cc	/^  bool hasNodesIn(int dimension)$/;"	f	class:crv::Bezier
hasNodesIn	crv/crvBezier.cc	/^  bool hasNodesIn(int dimension)$/;"	f	class:crv::GregorySurface4
hasNodesOn	crv/crvShapeHandler.cc	/^    virtual bool hasNodesOn(int dimension)$/;"	f	class:crv::BezierHandler
hasNodesOn	crv/crvShapeHandler.cc	/^    virtual bool hasNodesOn(int dimension)$/;"	f	class:crv::BezierTransfer
hasNodesOn	ma/maShapeHandler.cc	/^    virtual bool hasNodesOn(int dimension)$/;"	f	class:ma::LinearHandler
hasNodesOn	ma/maShapeHandler.cc	/^    virtual bool hasNodesOn(int dimension)$/;"	f	class:ma::QuadraticHandler
hasNodesOn	ma/maSolutionTransfer.cc	/^    virtual bool hasNodesOn(int dimension)$/;"	f	class:ma::FieldTransfer
hasNodesOn	ma/maSolutionTransfer.cc	/^    virtual bool hasNodesOn(int dimension)$/;"	f	class:ma::HighOrderTransfer
hasNodesOn	ma/maSolutionTransfer.cc	/^bool SolutionTransfers::hasNodesOn(int dimension)$/;"	f	class:ma::SolutionTransfers
hasNumber	ma/maCrawler.cc	/^  bool hasNumber(Entity* v)$/;"	f	struct:ma::Tagger
hasOtherSide	zoltan/apfInterElement.cc	/^static bool hasOtherSide(Mesh* m, MeshEntity* s)$/;"	f	namespace:apf
hasTag	apf_cap/apfCAP.cc	/^bool MeshCAP::hasTag(MeshEntity* e, MeshTag* tag)$/;"	f	class:apf::MeshCAP
hasTag	apf_sim/apfSIM.cc	/^bool MeshSIM::hasTag(MeshEntity* e, MeshTag* tag)$/;"	f	class:apf::MeshSIM
hasTag	mds/apfMDS.cc	/^    bool hasTag(MeshEntity* e, MeshTag* t)$/;"	f	class:apf::MeshMDS
hasTagData	pumi/GenTag.cc	/^bool Taggable::hasTagData(TagHandle* tag)$/;"	f	class:Taggable
hasTwoEntitiesOnBoundary	crv/crvShape.cc	/^static bool hasTwoEntitiesOnBoundary(apf::Mesh* m, apf::MeshEntity* e, int dimension)$/;"	f	namespace:crv
hasUp	apf_cap/apfCAP.cc	/^bool MeshCAP::hasUp(MeshEntity* e)$/;"	f	class:apf::MeshCAP
hasUp	apf_sim/apfSIM.cc	/^bool MeshSIM::hasUp(MeshEntity* e)$/;"	f	class:apf::MeshSIM
hasUp	mds/apfMDS.cc	/^    bool hasUp(MeshEntity* e)$/;"	f	class:apf::MeshMDS
hasWorseQuality	ma/maQuality.cc	/^bool hasWorseQuality(Adapt* a, EntityArray& e, double qualityToBeat)$/;"	f	namespace:ma
has_copy	mds/mds_apf.c	/^static int has_copy(struct mds_net* net, mds_id e, struct mds_copy c)$/;"	f	file:
hasher	proteushash.py	/^hasher = hashlib.sha256()$/;"	v
hashlib	proteushash.py	/^import hashlib$/;"	i
haveBC	phasta/phBC.cc	/^bool haveBC(BCs& bcs, std::string const& name)$/;"	f	namespace:ph
head	pumi/pumi_list.h	/^    ListMember head;$/;"	m	class:List
header	mds/mdsUgrid.cc	/^  struct header {$/;"	s	namespace:__anon101	file:
helper	apf/apfMesh.h	/^  NormalSharing helper;$/;"	m	struct:apf::MatchedSharing
helper	apf/apfTagData.h	/^    TagHelper<T> helper;$/;"	m	class:apf::TagDataOf
helperM	phasta/phLinks.cc	/^  apf::Sharing* helperM;$/;"	m	struct:ph::PhastaSharing	file:
helperN	phasta/phLinks.cc	/^  apf::Sharing* helperN;$/;"	m	struct:ph::PhastaSharing	file:
hex	test/shapefun2.cc	/^static apf::Vector3 const hex[8] = {$/;"	m	class:test::apf	file:
hexToPrisms	ma/maLayerTemplates.cc	/^static void hexToPrisms(Refine* r, Entity* p, Entity** v)$/;"	f	namespace:ma
hexToPrisms2	ma/maLayerTemplates.cc	/^static void hexToPrisms2(Refine* r, Entity* p, Entity** v)$/;"	f	namespace:ma
hex_face_map	stk/apfMeshSTK.cc	/^static unsigned const hex_face_map[6] = {4,0,1,2,3,5};$/;"	m	namespace:apf	file:
hex_face_rotations	phasta/phAdjacent.cc	/^static int const hex_face_rotations[6][8] = {$/;"	m	namespace:ph	file:
hex_quad_verts	apf/apfMesh.cc	/^int const hex_quad_verts[6][4] =$/;"	m	namespace:apf	file:
hexw	test/ugridptnstats.cc	/^const double hexw = 13.8;$/;"	v
i	apf/apfMatrix.cc	/^  int i;$/;"	m	struct:apf::SortStruct	file:
i	gmi_sim/gmi_sim.cc	/^  } i;$/;"	m	struct:sim_iter	typeref:union:sim_iter::__anon103	file:
i	parma/diffMC/parma_components.cc	/^    unsigned i;$/;"	m	struct:__anon65::Comp	file:
i	parma/diffMC/parma_stop.h	/^      Average* i;$/;"	m	class:parma::BalOrStall
iA	parma/diffMC/parma_balancer.h	/^      Average* iA;$/;"	m	class:parma::Balancer
iS	parma/diffMC/parma_balancer.h	/^      Slope* iS;$/;"	m	class:parma::Balancer
ibc	phasta/phOutput.h	/^  int* ibc;$/;"	m	struct:ph::EnsaArrays
ibcb	phasta/phOutput.h	/^  int*** ibcb;$/;"	m	struct:ph::EnsaArrays
ibegin	pumi/GenIterator.h	/^    Iterator ibegin;    $/;"	m	class:GenIterator
id	apf_sim/apfSIM.cc	/^    pMeshDataId id;$/;"	m	class:apf::TagSIM	file:
id	gmi/agm.h	/^  int id;$/;"	m	struct:agm_bdry
id	gmi/agm.h	/^  int id;$/;"	m	struct:agm_ent
id	gmi/agm.h	/^  int id;$/;"	m	struct:agm_use
id	parma/diffMC/maximalIndependentSet/mis.h	/^        int id;$/;"	m	struct:misLuby::PartInfo
id	parma/diffMC/parma_elmLtVtxEdgeSelector.cc	/^        int id;$/;"	m	struct:__anon64::ElmLtVtxEdgeSelector::Migr	file:
id	parma/diffMC/parma_graphDist.cc	/^      unsigned id;$/;"	m	class:__anon74::CompContains	file:
id	phasta/phBubble.cc	/^  int id;$/;"	m	struct:ph::Bubble	file:
id	test/nektar_align.cc	/^  long id;$/;"	m	struct:VertId	file:
idT	parma/diffMC/parma_components.h	/^      apf::MeshTag* idT;$/;"	m	class:parma::dcComponents::Components
idle_state	pcu/pcu_msg.c	/^  idle_state, \/\/in between phases$/;"	e	enum:__anon32	file:
ids	mds/apfPM.h	/^  std::vector<int> ids;$/;"	m	struct:apf::PME
iel	phasta/phOutput.h	/^  int* iel;$/;"	m	struct:ph::EnsaArrays
ien	phasta/phOutput.h	/^  int*** ien;$/;"	m	struct:ph::EnsaArrays
ienb	phasta/phOutput.h	/^  int*** ienb;$/;"	m	struct:ph::EnsaArrays
iend	pumi/GenIterator.h	/^    Iterator iend; $/;"	m	class:GenIterator
ienif0	phasta/phOutput.h	/^  int*** ienif0;$/;"	m	struct:ph::EnsaArrays
ienif1	phasta/phOutput.h	/^  int*** ienif1;$/;"	m	struct:ph::EnsaArrays
ienneigh	phasta/phOutput.h	/^  int* ienneigh;$/;"	m	struct:ph::EnsaArrays
igclv	phasta/phOutput.h	/^  apf::MeshEntity** igclv;$/;"	m	struct:ph::EnsaArrays
igclvid	phasta/phOutput.h	/^  int* igclvid;$/;"	m	struct:ph::EnsaArrays
igcnv	phasta/phOutput.h	/^  int* igcnv;$/;"	m	struct:ph::EnsaArrays
ile	phasta/phOutput.h	/^  int* ile;$/;"	m	struct:ph::EnsaArrays
ileo	phasta/phOutput.h	/^  int* ileo;$/;"	m	struct:ph::EnsaArrays
ilwork	phasta/phOutput.h	/^  int* ilwork;$/;"	m	struct:ph::EnsaArrays
ilworkf	phasta/phOutput.h	/^  int* ilworkf;$/;"	m	struct:ph::EnsaArrays
ilworkl	phasta/phOutput.h	/^  int* ilworkl;$/;"	m	struct:ph::EnsaArrays
import_gids	zoltan/apfZoltanCallbacks.h	/^    ZOLTAN_ID_PTR import_gids;$/;"	m	class:apf::ZoltanData
import_lids	zoltan/apfZoltanCallbacks.h	/^    ZOLTAN_ID_PTR import_lids; \/* Pointers to nodes imported *\/$/;"	m	class:apf::ZoltanData
import_procs	zoltan/apfZoltanCallbacks.h	/^    int *import_procs; \/* Proc IDs of procs owning nodes to be imported.*\/$/;"	m	class:apf::ZoltanData
import_to_part	zoltan/apfZoltanCallbacks.h	/^    int *import_to_part;$/;"	m	class:apf::ZoltanData
improveQualities	ma/maShape.cc	/^double improveQualities(Adapt* a)$/;"	f	namespace:ma
improveQualities2D	ma/maShape.cc	/^static void improveQualities2D(Adapt* a)$/;"	f	namespace:ma
in	mds/apfBox.cc	/^int Grid::in(Indices is)$/;"	f	class:apf::Grid
in	phasta/phAdapt.cc	/^  ph::Input* in;$/;"	m	struct:ph::AdaptCallback	file:
in	phasta/phOutput.h	/^  Input* in;$/;"	m	struct:ph::Output
in	phasta/phSnap.cc	/^ph::Input in;$/;"	v
inElement	apf/apfGradientByVolume.cc	/^    virtual void inElement(MeshElement* me)$/;"	f	class:apf::GradientIntegrator
inElement	apf/apfIntegrate.cc	/^void Integrator::inElement(MeshElement*)$/;"	f	class:apf::Integrator
inElement	ma/maQuality.cc	/^    virtual void inElement(apf::MeshElement* me)$/;"	f	class:ma::FixedMetricIntegrator
inElement	ma/maSize.cc	/^    void inElement(apf::MeshElement* me)$/;"	f	class:ma::SizeFieldIntegrator
inElement	sam/samElementCount.cc	/^  virtual void inElement(apf::MeshElement* me) {$/;"	f	class:sam::TotalMetricVolumeIso
inElement	spr/sprEstimateError.cc	/^    void inElement(apf::MeshElement* meshElement)$/;"	f	class:spr::ElementError
inElement	spr/sprEstimateError.cc	/^    void inElement(apf::MeshElement* meshElement)$/;"	f	class:spr::SelfProduct
inElement	spr/sprEstimateTargetError.cc	/^    void inElement(apf::MeshElement* meshElement)$/;"	f	class:spr::target::ElementError
inElement	test/test_integrator.cc	/^    void inElement(apf::MeshElement *) $/;"	f	class:CountIntegrator
inElement	test/test_matrix_grad.cc	/^    virtual void inElement(apf::MeshElement * elmt)$/;"	f	class:CheckMatrixDerivIntegrator
inElement	test/test_matrix_grad.cc	/^    virtual void inElement(apf::MeshElement * elmt)$/;"	f	class:MatrixDerivIntegrator
inEntity	apf/apfField.cc	/^  bool inEntity(MeshEntity* e)$/;"	f	struct:apf::ZeroOp
inEntity	apf/apfField.cc	/^bool FieldOp::inEntity(MeshEntity*)$/;"	f	class:apf::FieldOp
inEntity	apf/apfFieldData.cc	/^    bool inEntity(MeshEntity* e)$/;"	f	class:apf::AddOp
inEntity	apf/apfFieldData.cc	/^    bool inEntity(MeshEntity* e)$/;"	f	class:apf::CopyOp
inEntity	apf/apfFieldData.cc	/^    bool inEntity(MeshEntity* e)$/;"	f	class:apf::MultiplyOp
inEntity	apf/apfFieldOf.cc	/^    bool inEntity(MeshEntity* e)$/;"	f	class:apf::Axpy
inEntity	apf/apfFieldOf.cc	/^    bool inEntity(MeshEntity* e)$/;"	f	class:apf::Project
inEntity	apf/apfHierarchic.cc	/^    bool inEntity(MeshEntity* e)$/;"	f	class:apf::Projector
inEntity	apf/apfNumbering.cc	/^    virtual bool inEntity(MeshEntity* e)$/;"	f	class:apf::Counter
inEntity	apf/apfNumbering.cc	/^    virtual bool inEntity(MeshEntity* e)$/;"	f	class:apf::Globalizer
inEntity	apf/apfVtk.cc	/^    virtual bool inEntity(MeshEntity* e)$/;"	f	class:apf::WriteIPField
inEntity	apf/apfVtk.h	/^    virtual bool inEntity(MeshEntity* e)$/;"	f	class:apf::HasAll
inMesh	apf/apfConvert.cc	/^    Mesh *inMesh;$/;"	m	class:apf::Converter	file:
inMesh	phasta/migrate_interface.cc	/^  const char* inMesh = 0;$/;"	m	namespace:__anon78	file:
increase_dimension	mds/mds.c	/^static void increase_dimension(struct mds* m)$/;"	f	file:
increment	apf_cap/apfCAP.cc	/^void MeshCAP::increment(MeshIterator* it)$/;"	f	class:apf::MeshCAP
increment	apf_sim/apfSIM.h	/^    void increment(MeshIterator*) {}$/;"	f	class:apf::MeshSIM
increment	mds/apfMDS.cc	/^    void increment(MeshIterator* it)$/;"	f	class:apf::MeshMDS
index	gmi/gmi_lookup.c	/^  int index;$/;"	m	struct:entry	file:
infile	parma/extractParmaResults.py	/^infile = open(parmaLogName)$/;"	v
init	apf/apfArrayData.cc	/^    virtual void init(FieldBase* f)$/;"	f	class:apf::ArrayDataOf
init	apf/apfCoordData.cc	/^void CoordData::init(FieldBase* f)$/;"	f	class:apf::CoordData
init	apf/apfElement.cc	/^void Element::init(Field* f, MeshEntity* e, VectorElement* p)$/;"	f	class:apf::Element
init	apf/apfField.cc	/^void FieldBase::init($/;"	f	class:apf::FieldBase
init	apf/apfIPShape.cc	/^        void init(int type, int order)$/;"	f	class:apf::VoronoiShape::Element
init	apf/apfMesh.cc	/^void Mesh::init(FieldShape* s)$/;"	f	class:apf::Mesh
init	apf/apfNumbering.cc	/^void NumberingOf<T>::init($/;"	f	class:apf::NumberingOf
init	apf/apfNumbering.cc	/^void NumberingOf<T>::init(Field* f)$/;"	f	class:apf::NumberingOf
init	apf/apfTagData.cc	/^void TagData::init($/;"	f	class:apf::TagData
init	apf/apfTagData.h	/^    virtual void init(FieldBase* f)$/;"	f	class:apf::TagDataOf
init	apf/apfUserData.cc	/^void UserData::init(FieldBase* f)$/;"	f	class:apf::UserData
init	apf_sim/apfSIMDataOf.h	/^  virtual void init(FieldBase * f)$/;"	f	class:apf::SIMDataOf
init	ma/maAdapt.cc	/^void Cavity::init(Adapt* a)$/;"	f	class:ma::Cavity
init	ma/maCrawler.cc	/^  void init(Mesh* m_, Tag* t_)$/;"	f	struct:ma::Tagger
init	ma/maEdgeSwap.cc	/^    void init(Adapt* a)$/;"	f	class:ma::SwapCavity
init	ma/maEdgeSwap.cc	/^    void init(Adapt* a)$/;"	f	class:ma::SwapLoop
init	ma/maSize.cc	/^  void init(Mesh* m, apf::Field* sizes, apf::Field* frames)$/;"	f	struct:ma::AnisoSizeField
init	ma/maSize.cc	/^  void init(Mesh* m, apf::Field* sizes, apf::Field* frames)$/;"	f	struct:ma::LogAnisoSizeField
init	parma/diffMC/parma_centroidSelector.cc	/^      void init(Targets* tgts, DistanceQueue* distQ, Distance* dist) {$/;"	f	class:parma::CentroidSelector	file:
init	parma/diffMC/parma_centroids.cc	/^  void Centroids::init(apf::Mesh*, Sides* s) {$/;"	f	class:parma::Centroids
init	parma/diffMC/parma_elmBdrySides.cc	/^      void init(apf::Mesh* m) {$/;"	f	class:parma::ElmBdrySides	file:
init	parma/diffMC/parma_elmLtVtxEdgeTargets.cc	/^      void init(Sides* s, Weights* w[3], int sideTol,$/;"	f	class:parma::ElmLtVtxEdge	file:
init	parma/diffMC/parma_elmSideSides.cc	/^      void init(apf::Mesh* m) {$/;"	f	class:parma::ElmSideSides	file:
init	parma/diffMC/parma_entWeights.cc	/^  void EntWeights::init(apf::Mesh*, apf::MeshTag*, Sides* s) {$/;"	f	class:parma::EntWeights
init	parma/diffMC/parma_preserveTargets.cc	/^      void init(Sides* s, Weights* balance, Weights* preserve,$/;"	f	class:parma::PreserveTargets	file:
init	parma/diffMC/parma_shapeTargets.cc	/^      void init(Sides* s) {$/;"	f	class:parma::ShapeTargets	file:
init	parma/diffMC/parma_vtxEdgeTargets.cc	/^      void init(Sides* s, Weights* w[2], int sideTol, double vtxTol,$/;"	f	class:parma::VtxEdgeTargets	file:
init	parma/diffMC/parma_vtxSides.cc	/^      void init(apf::Mesh* m) {$/;"	f	class:parma::VtxSides	file:
init	parma/diffMC/parma_weightSideTargets.cc	/^      void init(Sides* s, Weights* w, int sideTol, double alpha) {$/;"	f	class:parma::WeightSideTargets	file:
init	parma/diffMC/parma_weightTargets.cc	/^      void init(Sides* s, Weights* w, double alpha) {$/;"	f	class:parma::WeightTargets	file:
init	pcu/pcu.c	/^enum state { uninit, init };$/;"	e	enum:state	file:
initArray	phasta/phMeshQuality.cc	/^static void initArray(double array[3][3]) {$/;"	f	namespace:ph
initBubbles	phasta/phBubble.cc	/^void initBubbles(apf::Mesh* m, Input& in)$/;"	f	namespace:ph
initBubbles	phasta/phInput.h	/^    int initBubbles;$/;"	m	class:ph::Input
initReader	mds/mdsGmsh.cc	/^void initReader(Reader* r, apf::Mesh2* m, const char* filename)$/;"	f	namespace:__anon96
initReader	mds/mdsUgrid.cc	/^  void initReader(Reader* r, apf::Mesh2* m, const char* filename) {$/;"	f	namespace:__anon101
initResidence	apf/apfMesh2.cc	/^void initResidence(apf::Mesh2* m, int d)$/;"	f	namespace:apf
initTag	parma/diffMC/parma_graphDist.cc	/^  apf::MeshTag* initTag(apf::Mesh* m, const char* name,$/;"	f	namespace:__anon74
init_order	pcu/pcu_order.c	/^static void init_order(pcu_order o)$/;"	f	file:
initialize	test/hierarchic.cc	/^void L2Projector::initialize() {$/;"	f	class:__anon20::L2Projector
initialize	test/simZBalance.cc	/^static void initialize(int argc, char** argv) {$/;"	f	file:
initializeMIS	apf/apfMIS.cc	/^  MIS* initializeMIS(Mesh* mesh, int vtx_dim, int edge_dim) {$/;"	f	namespace:apf
input	ma/maAdapt.h	/^    Input* input;$/;"	m	class:ma::Adapt
inputPartCount	test/repartition.cc	/^int inputPartCount = 1;$/;"	m	namespace:__anon22	file:
inputs	test/eigen_test.cc	/^static struct Input const inputs[NINPUTS] = {$/;"	v	file:
insertGhosts	parma/diffMC/parma_ghostWeights.cc	/^      void insertGhosts(apf::MeshEntity* e, entset* ghosts) {$/;"	f	class:parma::ElmGhostFinder	file:
insertInteriorEdges	parma/diffMC/parma_elmLtVtxEdgeSelector.cc	/^      void insertInteriorEdges(apf::MeshEntity* e, int dest, SetEnt& s) {$/;"	f	class:__anon64::ElmLtVtxEdgeSelector
insertInteriorEnts	parma/diffMC/parma_ltSelector.cc	/^      void insertInteriorEnts(apf::MeshEntity* e, int dest, SetEnt& s, int entDim) {$/;"	f	class:__anon58::LtSelector
insertInteriorVerts	parma/diffMC/parma_edgeEqVtxSelector.cc	/^      void insertInteriorVerts(apf::MeshEntity* e, int dest, SetEnt& s) {$/;"	f	class:__anon52::EdgeEqVtx
insertInteriorVerts	parma/diffMC/parma_elmLtVtxEdgeSelector.cc	/^      void insertInteriorVerts(apf::MeshEntity* e, int dest, SetEnt& s) {$/;"	f	class:__anon64::ElmLtVtxEdgeSelector
insertKey	phasta/phBlock.cc	/^static void insertKey(Blocks& b, BlockKey const& k)$/;"	f	namespace:ph
insertKeyInterface	phasta/phBlock.cc	/^static void insertKeyInterface$/;"	f	namespace:ph
insert_peer	mds/mds_net.c	/^static int insert_peer(struct mds_links* ln, int p)$/;"	f	file:
instance	pumi/pumi_mesh.cc	/^pumi* pumi::instance()$/;"	f	class:pumi
intFactory	phasta/phAttrib.cc	/^static ph::BC* intFactory(pAttribute a, pGEntity ge)$/;"	f	file:
integration_order	spr/sprEstimateError.cc	/^  int integration_order;$/;"	m	struct:spr::Estimation	file:
integration_order	spr/sprEstimateTargetError.cc	/^  int integration_order;$/;"	m	struct:spr::target::Estimation	file:
interface	phasta/phBlock.h	/^  BlocksInterface interface;$/;"	m	struct:ph::AllBlocks
interfaceFlag	phasta/phOutput.h	/^  int* interfaceFlag;$/;"	m	struct:ph::EnsaArrays
interior	phasta/phBlock.h	/^  Blocks interior;$/;"	m	struct:ph::AllBlocks
internalBCNodes	phasta/phInput.h	/^    int internalBCNodes;$/;"	m	class:ph::Input
internalCoeffs	crv/crvShapeHandler.cc	/^    apf::NewArray<double> internalCoeffs[4];$/;"	m	class:crv::BezierTransfer	file:
interpolate	ma/maSize.cc	/^  void interpolate($/;"	f	struct:ma::AnisoSizeField
interpolate	ma/maSize.cc	/^  void interpolate($/;"	f	struct:ma::LogAnisoSizeField
interpolate	ma/maSize.cc	/^void IdentitySizeField::interpolate($/;"	f	class:ma::IdentitySizeField
interpolateParametricCoordinate	ma/maSnap.cc	/^static double interpolateParametricCoordinate($/;"	f	namespace:ma
interpolateParametricCoordinate	ma/maSnap_mohara.cc	/^static double interpolateParametricCoordinate($/;"	f	namespace:ma
interpolateParametricCoordinateOnEdge	ma/maSnap.cc	/^static void interpolateParametricCoordinateOnEdge($/;"	f	namespace:ma
interpolateParametricCoordinateOnEdge	ma/maSnap_mohara.cc	/^static void interpolateParametricCoordinateOnEdge($/;"	f	namespace:ma
interpolateParametricCoordinates	crv/crvSnap.cc	/^static void interpolateParametricCoordinates($/;"	f	namespace:crv
interpolateParametricCoordinates	ma/maSnap.cc	/^void interpolateParametricCoordinates($/;"	f	namespace:ma
interpolateParametricCoordinates	ma/maSnap_mohara.cc	/^void interpolateParametricCoordinates($/;"	f	namespace:ma
interpolateParametricCoordinatesDoublePoles	ma/maSnap.cc	/^static Vector interpolateParametricCoordinatesDoublePoles($/;"	f	namespace:ma
interpolateParametricCoordinatesDoublePoles	ma/maSnap_mohara.cc	/^static Vector interpolateParametricCoordinatesDoublePoles($/;"	f	namespace:ma
interpolateParametricCoordinatesOnDegenerateFace	ma/maSnap.cc	/^static void interpolateParametricCoordinatesOnDegenerateFace($/;"	f	namespace:ma
interpolateParametricCoordinatesOnDegenerateFace	ma/maSnap_mohara.cc	/^static void interpolateParametricCoordinatesOnDegenerateFace($/;"	f	namespace:ma
interpolateParametricCoordinatesOnFace	ma/maSnap.cc	/^static void interpolateParametricCoordinatesOnFace($/;"	f	namespace:ma
interpolateParametricCoordinatesOnFace	ma/maSnap_mohara.cc	/^static void interpolateParametricCoordinatesOnFace($/;"	f	namespace:ma
interpolateParametricCoordinatesOnRegularFace	ma/maSnap.cc	/^static void interpolateParametricCoordinatesOnRegularFace($/;"	f	namespace:ma
interpolateParametricCoordinatesOnRegularFace	ma/maSnap_mohara.cc	/^static void interpolateParametricCoordinatesOnRegularFace($/;"	f	namespace:ma
interpolateParametricCoordinatesSinglePole	ma/maSnap.cc	/^static Vector interpolateParametricCoordinatesSinglePole($/;"	f	namespace:ma
interpolateParametricCoordinatesSinglePole	ma/maSnap_mohara.cc	/^static Vector interpolateParametricCoordinatesSinglePole($/;"	f	namespace:ma
interpolationError	crv/crv.cc	/^double interpolationError(apf::Mesh* m, apf::MeshEntity* e, int n){$/;"	f	namespace:crv
intersect	apf/apfGeometry.cc	/^Line intersect(Plane const& a, Plane const& b)$/;"	f	namespace:apf
intersect	apf/apfGeometry.cc	/^Vector3 intersect(Line const& a, Plane const& b)$/;"	f	namespace:apf
intersect	apf/apfMesh2.cc	/^static void intersect($/;"	f	namespace:apf
intersect	apf/apfVerify.cc	/^static void intersect($/;"	f	namespace:apf
intersectRayFace	ma/maSnapper.cc	/^FirstProblemPlane::intersectRayFace(const Ray& ray, const std::vector<Vector>& coords,$/;"	f	class:ma::FirstProblemPlane
intersection	ma/maSnapper.h	/^    Vector intersection;$/;"	m	class:ma::FirstProblemPlane
intpow	crv/crvMath.h	/^inline double intpow(const double b, const int e)$/;"	f	namespace:crv
intrude	ma/maExtrude.cc	/^void intrude(Mesh* m, ModelExtrusions const& model_extrusions,$/;"	f	namespace:ma
invMaps	stk/apfAlbany.h	/^  Map invMaps[4];$/;"	m	struct:apf::StkModels
inverse	mth/mth_def.h	/^Matrix<T,2,2> inverse(Matrix<T,2,2> const& a)$/;"	f	namespace:mth
inverse	mth/mth_def.h	/^Matrix<T,3,3> inverse(Matrix<T,3,3> const& a)$/;"	f	namespace:mth
inverse	mth/mth_def.h	/^void inverse(Tensor<T> const& a, Tensor<T>& r)$/;"	f	namespace:mth
inverse2x2	mth/mth_def.h	/^void inverse2x2(Tensor<T> const& a, Tensor<T>& r)$/;"	f	namespace:mth
inverse3x3	mth/mth_def.h	/^void inverse3x3(Tensor<T> const& a, Tensor<T>& r)$/;"	f	namespace:mth
invert	apf/apfMatrix.h	/^inline Matrix<2,2> invert(Matrix<2,2> const& m)$/;"	f	namespace:apf
invert	apf/apfMatrix.h	/^inline Matrix<3,3> invert(Matrix<3,3> const& m)$/;"	f	namespace:apf
invert	ma/maAffine.h	/^inline Affine invert(Affine const& a)$/;"	f	namespace:ma
invert	mds/mds_order.c	/^static struct mds_tag* invert($/;"	f	file:
invertMatrixWithPLU	crv/crvMath.cc	/^void invertMatrixWithPLU(int n, mth::Matrix<double>& A,$/;"	f	namespace:crv
invertMatrixWithQR	crv/crvMath.cc	/^void invertMatrixWithQR(int n, mth::Matrix<double>& A,$/;"	f	namespace:crv
involvesPyramids	ma/maLayerCollapse.cc	/^bool LayerCollapse::involvesPyramids()$/;"	f	class:ma::LayerCollapse
ip	spr/sprEstimateError.cc	/^    int ip; \/\/integration point counter$/;"	m	class:spr::ElementError	file:
ip	spr/sprEstimateTargetError.cc	/^    int ip;$/;"	m	class:spr::target::ElementError	file:
ipData	apf/apfVtk.cc	/^    NewArray<T> ipData;$/;"	m	class:apf::WriteIPField	file:
iper	phasta/phOutput.h	/^  int* iper;$/;"	m	struct:ph::EnsaArrays
ipnode	apf/apf.h	/^    int ipnode;$/;"	m	class:apf::Integrator
is	test/box.cc	/^bool is = true;$/;"	m	namespace:__anon8	file:
is2dStencilNetAvailable	parma/diffMC/maximalIndependentSet/test/testMIS.cc	/^bool is2dStencilNetAvailable(vector<int>& isInMIS, const int r, const int c, $/;"	f
is2dStencilNetInIS	parma/diffMC/maximalIndependentSet/test/testMIS.cc	/^bool is2dStencilNetInIS(vector<int>& isInMIS, const int r, const int c, $/;"	f
isBigEndian	apf/apfVtk.cc	/^bool isBigEndian()$/;"	f	namespace:apf
isBoundaryEntity	crv/crvShape.cc	/^bool isBoundaryEntity(apf::Mesh* m, apf::MeshEntity* e)$/;"	f	namespace:crv
isClassifiedOnBoundary	test/icesheet.cc	/^bool isClassifiedOnBoundary(apf::Mesh2* mesh, apf::MeshEntity* face) {$/;"	f
isCornerTriAngleLargeMetric	crv/crvShape.cc	/^static bool isCornerTriAngleLargeMetric(crv::Adapt *a,$/;"	f	namespace:crv
isCurlOk	ma/maEdgeSwap.cc	/^    bool isCurlOk(Entity* vert, Entity* tet)$/;"	f	class:ma::SwapLoop
isDG	phasta/phLinks.cc	/^  bool isDG;$/;"	m	struct:ph::PhastaSharing	file:
isDone	apf_cap/apfCAP.cc	/^bool MeshCAP::isDone(MeshIterator* it)$/;"	f	class:apf::MeshCAP
isDone	apf_sim/apfSIM.h	/^    bool isDone(MeshIterator*) { return true; }$/;"	f	class:apf::MeshSIM
isDone	mds/apfMDS.cc	/^    bool isDone(MeshIterator* it)$/;"	f	class:apf::MeshMDS
isElementOk	ma/maLayerSnap.cc	/^static bool isElementOk(Adapt* a, Entity* e)$/;"	f	namespace:ma
isEql	parma/diffMC/parma_commons.cc	/^int parmaCommons::isEql(double a, double b) {$/;"	f	class:parmaCommons
isEqlArr	parma/diffMC/parma_commons.h	/^template<class type1, class type2> int isEqlArr(type1 a, type2 b) {$/;"	f	namespace:parmaCommons
isFirst	apf/apfGradientByVolume.cc	/^    bool isFirst;$/;"	m	class:apf::GradientIntegrator	file:
isFixed	apf/apfNumbering.cc	/^bool isFixed(Numbering* n, MeshEntity* e, int node, int component)$/;"	f	namespace:apf
isFrozen	apf/apf.cc	/^bool isFrozen(Field* f)$/;"	f	namespace:apf
isFrozen	apf/apfArrayData.cc	/^    virtual bool isFrozen() {$/;"	f	class:apf::ArrayDataOf
isFrozen	apf/apfCoordData.h	/^    virtual bool isFrozen() { return false; }$/;"	f	class:apf::CoordData
isFrozen	apf/apfTagData.h	/^    virtual bool isFrozen()$/;"	f	class:apf::TagDataOf
isFrozen	apf/apfUserData.cc	/^bool UserData::isFrozen()$/;"	f	class:apf::UserData
isFrozen	apf_sim/apfSIMDataOf.h	/^  virtual bool isFrozen() {return false;}$/;"	f	class:apf::SIMDataOf
isGhost	apf_cap/apfCAP.h	/^    bool isGhost(MeshEntity*) { return false; }$/;"	f	class:apf::MeshCAP
isGhost	apf_sim/apfSIM.h	/^    bool isGhost(MeshEntity*) { return false; }$/;"	f	class:apf::MeshSIM
isGhost	mds/apfMDS.cc	/^    bool isGhost(MeshEntity* e)$/;"	f	class:apf::MeshMDS
isGhosted	apf_cap/apfCAP.h	/^    bool isGhosted(MeshEntity*) { return false; }$/;"	f	class:apf::MeshCAP
isGhosted	apf_sim/apfSIM.h	/^    bool isGhosted(MeshEntity*) { return false; }$/;"	f	class:apf::MeshSIM
isGhosted	mds/apfMDS.cc	/^    bool isGhosted(MeshEntity* e)$/;"	f	class:apf::MeshMDS
isGood2DMesh	ma/maCollapse.cc	/^bool Collapse::isGood2DMesh()$/;"	f	class:ma::Collapse
isIP	apf/apfVtk.cc	/^static bool isIP(FieldBase* f, int cellDim)$/;"	f	namespace:apf
isInClosure	ma/maMesh.cc	/^bool isInClosure(Mesh* m, Entity* parent, Entity* e)$/;"	f	namespace:ma
isInClosureOf	apf/apfMesh.cc	/^bool Mesh::isInClosureOf(ModelEntity* g, ModelEntity* target){$/;"	f	class:apf::Mesh
isInMIS	parma/diffMC/maximalIndependentSet/mis.h	/^        bool isInMIS;$/;"	m	struct:misLuby::PartInfo
isInMis	parma/diffMC/parma_dcpartFixer.cc	/^  bool isInMis(muu& mt) {$/;"	f	namespace:__anon48
isInNetGraph	parma/diffMC/maximalIndependentSet/mis.h	/^        bool isInNetGraph;$/;"	m	struct:misLuby::PartInfo
isInterface	phasta/phInterfaceCutter.cc	/^bool isInterface(gmi_model* gm, gmi_ent* ge, FieldBCs& fbcs)$/;"	f	namespace:ph
isIsolated	parma/diffMC/parma_dcpart.cc	/^bool dcPart::isIsolated(apf::MeshEntity* e) {$/;"	f	class:dcPart
isLargeAngleTetMetric	crv/crvShape.cc	/^static ma::Entity* isLargeAngleTetMetric(crv::Adapt* a, ma::Entity* e)$/;"	f	namespace:crv
isLargeAngleTriMetric	crv/crvShape.cc	/^static ma::Entity* isLargeAngleTriMetric(crv::Adapt* a, ma::Entity* e)$/;"	f	namespace:crv
isLayerElementOk	ma/maQuality.cc	/^bool isLayerElementOk(Mesh* m, Entity* e)$/;"	f	namespace:ma
isLess	apf/apfMesh.cc	/^bool MatchedSharing::isLess(Copy const& a, Copy const& b)$/;"	f	class:apf::MatchedSharing
isLess	parma/diffMC/parma_commons.cc	/^int parmaCommons::isLess(double a, double b) { $/;"	f	class:parmaCommons
isLocal	test/ptnParma.cc	/^int isLocal = 0;$/;"	m	namespace:__anon10	file:
isLocal	zoltan/apfZoltanMesh.h	/^    bool isLocal;$/;"	m	class:apf::ZoltanMesh
isLowInHigh	ma/maSnapper.cc	/^bool isLowInHigh(Mesh* mesh, Entity* highEnt, Entity* lowEnt)$/;"	f	namespace:ma
isMatched	mds/apfMDS.cc	/^    bool isMatched;$/;"	m	class:apf::MeshMDS	file:
isMatchingSlave	phasta/phOutput.cc	/^static bool isMatchingSlave(apf::MatchedSharing* ms, apf::MeshEntity* v)$/;"	f	namespace:ph
isMaximalIndependentSet	parma/diffMC/maximalIndependentSet/test/testMIS.cc	/^bool isMaximalIndependentSet(int* isInMIS, const int sqrtTotNumParts, $/;"	f
isMixed	phasta/phPartition.cc	/^bool isMixed(apf::Mesh2* m) {$/;"	f	namespace:ph
isMore	parma/diffMC/parma_commons.cc	/^int parmaCommons::isMore(double a, double b) { $/;"	f	class:parmaCommons
isNodal	apf/apfVtk.cc	/^static bool isNodal(FieldBase* f)$/;"	f	namespace:apf
isNodalField	phasta/phRestart.cc	/^static bool isNodalField(const char* fieldname, int nnodes, apf::Mesh* m)$/;"	f	namespace:ph
isNumbered	apf/apfNumbering.cc	/^bool isNumbered(Numbering* n, MeshEntity* e, int node, int component)$/;"	f	namespace:apf
isOnModel	apf/apfMesh.cc	/^bool Mesh::isOnModel(ModelEntity* g, Vector3 p, double scale)$/;"	f	class:apf::Mesh
isOnModelEdge	ma/maMesh.cc	/^bool isOnModelEdge(Mesh* m, Entity* e)$/;"	f	namespace:ma
isOnModelFace	ma/maMesh.cc	/^bool isOnModelFace(Mesh* m, Entity* e)$/;"	f	namespace:ma
isOwned	apf/apfMesh.cc	/^bool MatchedSharing::isOwned(MeshEntity* e)$/;"	f	class:apf::MatchedSharing
isOwned	apf/apfMesh.cc	/^bool NormalSharing::isOwned(MeshEntity* e)$/;"	f	class:apf::NormalSharing
isOwned	apf/apfNumbering.cc	/^  bool isOwned(MeshEntity*) {return true;}$/;"	f	struct:apf::NoSharing
isOwned	apf_cap/apfCAP.cc	/^bool MeshCAP::isOwned(MeshEntity* e)$/;"	f	class:apf::MeshCAP
isOwned	apf_sim/apfSIM.cc	/^bool MeshSIM::isOwned(MeshEntity* e)$/;"	f	class:apf::MeshSIM
isOwned	mds/apfMDS.cc	/^    bool isOwned(MeshEntity* e)$/;"	f	class:apf::MeshMDS
isOwned	parma/diffMC/parma_ghostOwner.cc	/^  bool isOwned(apf::Mesh* m, apf::MeshEntity* v) {$/;"	f	namespace:parma
isOwned	phasta/phLinks.cc	/^  bool isOwned(apf::MeshEntity* e)$/;"	f	struct:ph::PhastaSharing
isOwned	test/pumi.cc	/^  bool isOwned(pMeshEnt e)$/;"	f	struct:testOwnership
isOwnedByPeer	parma/diffMC/parma_ghostWeights.cc	/^  bool isOwnedByPeer(apf::Mesh* m,apf::MeshEntity* v, int peer) {$/;"	f	namespace:__anon69
isParamPointInsideModel	apf/apfMesh.cc	/^bool Mesh::isParamPointInsideModel(ModelEntity* g,$/;"	f	class:apf::Mesh
isPrintable	apf/apf.cc	/^bool isPrintable(Field* f)$/;"	f	namespace:apf
isPrintable	apf/apfNumbering.cc	/^bool isPrintable(GlobalNumbering* f)$/;"	f	namespace:apf
isPrintable	apf/apfNumbering.cc	/^bool isPrintable(Numbering* f)$/;"	f	namespace:apf
isPrintable	apf/apfVtk.cc	/^bool isPrintable(FieldBase* f)$/;"	f	namespace:apf
isPrismOk	ma/maQuality.cc	/^bool isPrismOk(apf::Mesh* m, Entity* e,$/;"	f	namespace:ma
isPyramidOk	ma/maQuality.cc	/^bool isPyramidOk(apf::Mesh* m, Entity* e,$/;"	f	namespace:ma
isQP	stk/apfSTK.cc	/^    bool isQP;$/;"	m	class:apf::StkBridge	file:
isQuadratic	apf_sim/apfSIM.cc	/^static bool isQuadratic(pParMesh mesh)$/;"	f	namespace:apf
isQuadratic	mds/mdsGmsh.cc	/^  bool isQuadratic;$/;"	m	struct:__anon96::Reader	file:
isQuadratic	mds/mdsGmsh.cc	/^bool isQuadratic(int gmshType)$/;"	f	namespace:__anon96
isRankZero	phasta/phstream.cc	/^  inline bool isRankZero() {$/;"	f	namespace:__anon81
isReorder	phasta/phInput.h	/^    int isReorder;$/;"	m	class:ph::Input
isRequesting	apf/apfCavityOp.h	/^    bool isRequesting;$/;"	m	class:apf::CavityOp
isRequiredForAnEdgeCollapse	ma/maCollapse.cc	/^bool isRequiredForAnEdgeCollapse(Adapt* adapt, Entity* vertex)$/;"	f	namespace:ma
isRequiredForMatchedEdgeCollapse	ma/maCollapse.cc	/^bool isRequiredForMatchedEdgeCollapse(Adapt* adapt, Entity* vertex)$/;"	f	namespace:ma
isSameCurl	ma/maLayerRefine.cc	/^static bool isSameCurl(Entity** a, Entity** b, int n)$/;"	f	namespace:ma
isSameEdge	ma/sliverCodeMatch.cc	/^bool isSameEdge(int const a[2], int const b[2])$/;"	f
isSameEdgePair	ma/sliverCodeMatch.cc	/^bool isSameEdgePair(int const a[2][2], int const b[2][2])$/;"	f
isShared	apf/apfMesh.cc	/^bool MatchedSharing::isShared(MeshEntity* e) {$/;"	f	class:apf::MatchedSharing
isShared	apf/apfMesh.cc	/^bool NormalSharing::isShared(MeshEntity* e) {$/;"	f	class:apf::NormalSharing
isShared	apf/apfNumbering.cc	/^  bool isShared(MeshEntity*) {return false;}$/;"	f	struct:apf::NoSharing
isShared	apf_cap/apfCAP.cc	/^bool MeshCAP::isShared(MeshEntity* e)$/;"	f	class:apf::MeshCAP
isShared	apf_sim/apfSIM.cc	/^bool MeshSIM::isShared(MeshEntity* e)$/;"	f	class:apf::MeshSIM
isShared	mds/apfMDS.cc	/^    bool isShared(MeshEntity* e)$/;"	f	class:apf::MeshMDS
isShared	phasta/phLinks.cc	/^  bool isShared(apf::MeshEntity* e)$/;"	f	struct:ph::PhastaSharing
isShared	test/pumi.cc	/^  bool isShared(pMeshEnt  e)$/;"	f	struct:testOwnership
isSharedWithTarget	parma/diffMC/parma_ghostMPASWeights.cc	/^  bool isSharedWithTarget(apf::Mesh* m,apf::MeshEntity* v, int target) {$/;"	f	namespace:__anon61
isSharedWithTarget	parma/diffMC/parma_ghostWeights.cc	/^  bool isSharedWithTarget(apf::Mesh* m,apf::MeshEntity* e, int target) {$/;"	f	namespace:__anon69
isSide	parma/diffMC/parma_centroidSelector.cc	/^      bool isSide(apf::MeshEntity* e) {$/;"	f	class:parma::CentroidSelector	file:
isSimple	ma/maMatchedSnapper.h	/^    bool isSimple;$/;"	m	class:ma::MatchedSnapper
isSimple	ma/maSnapper.h	/^    bool isSimple;$/;"	m	class:ma::Snapper
isSimplex	apf/apfMesh.cc	/^bool isSimplex(int type)$/;"	f	namespace:apf
isSubset	apf/apfVerify.cc	/^static bool isSubset(Parts const& a, Parts const& b)$/;"	f	namespace:apf
isSurfUnderlyingFaceDegenerate	ma/maSnap.cc	/^static size_t isSurfUnderlyingFaceDegenerate($/;"	f	namespace:ma
isSurfUnderlyingFaceDegenerate	ma/maSnap_mohara.cc	/^static size_t isSurfUnderlyingFaceDegenerate($/;"	f	namespace:ma
isSynchronous	zoltan/apfZoltan.cc	/^    bool isSynchronous;$/;"	m	class:apf::ZoltanSplitter	file:
isTetOk	ma/maEdgeSwap.cc	/^    bool isTetOk(Entity* tet)$/;"	f	class:ma::SwapCavity
isTop	ma/maCrawler.cc	/^  bool isTop()$/;"	f	struct:ma::TopFlagger
isTriEdgeAligned	ma/maMesh.cc	/^bool isTriEdgeAligned(Mesh* m, Entity* tri, Entity* edge)$/;"	f	namespace:ma
isTriangleOk	ma/maEdgeSwap.cc	/^    bool isTriangleOk(int i)$/;"	f	class:ma::SwapCavity
isTwoTriAngleAcute	ma/maMesh.cc	/^bool isTwoTriAngleAcute(Mesh* m, Entity* a, Entity* b)$/;"	f	namespace:ma
isTwoTriAngleAcute	ma/maMesh.cc	/^bool isTwoTriAngleAcute(Mesh* m, Entity** va, Entity** vb)$/;"	f	namespace:ma
isValid	apf/apfPartition.h	/^  bool isValid(int out)$/;"	f	struct:apf::Contract
isValidIndependentSet	parma/diffMC/maximalIndependentSet/test/testMIS.cc	/^bool isValidIndependentSet(int* isInMIS, const int sqrtTotNumParts, $/;"	f
isVertexAdjacentToTouchEdge	test/icesheet.cc	/^static bool isVertexAdjacentToTouchEdge(apf::Mesh* mesh,$/;"	f	file:
isWritingBinary	apf/apfVtk.cc	/^    bool isWritingBinary;$/;"	m	class:apf::WriteIPField	file:
is_compact	mds/mds_smb.c	/^static int is_compact(struct mds_apf* m)$/;"	f	file:
is_discrete_ent	gmi/gmi.h	/^  int (*is_discrete_ent)(struct gmi_model* m, struct gmi_ent* e);$/;"	m	struct:gmi_model_ops
is_discrete_ent	gmi_cap/gmi_cap.cc	/^static int is_discrete_ent(struct gmi_model*, struct gmi_ent* e)$/;"	f	file:
is_discrete_ent	gmi_sim/gmi_sim.cc	/^static int is_discrete_ent(struct gmi_model*, struct gmi_ent* e)$/;"	f	file:
is_double_isequal	test/pumi.cc	/^bool is_double_isequal(double A, double B)$/;"	f
is_ent_numbered	apf/apfMixedNumbering.cc	/^static bool is_ent_numbered($/;"	f	namespace:apf
is_in_closure_of	gmi/gmi.h	/^  int (*is_in_closure_of)(struct gmi_model* m, struct gmi_ent* e,$/;"	m	struct:gmi_model_ops
is_in_closure_of	gmi_cap/gmi_cap.cc	/^static int is_in_closure_of(struct gmi_model* m, struct gmi_ent* e,$/;"	f	file:
is_in_closure_of	gmi_sim/gmi_sim.cc	/^static int is_in_closure_of(struct gmi_model* m, struct gmi_ent* e,$/;"	f	file:
is_point_in_region	gmi/gmi.h	/^  int (*is_point_in_region)(struct gmi_model* m, struct gmi_ent* e,$/;"	m	struct:gmi_model_ops
is_point_in_region	gmi_cap/gmi_cap.cc	/^static int is_point_in_region(struct gmi_model* m, struct gmi_ent* e,$/;"	f	file:
is_point_in_region	gmi_sim/gmi_sim.cc	/^static int is_point_in_region(struct gmi_model* m, struct gmi_ent* e,$/;"	f	file:
is_simplex	mds/apfBox.h	/^  bool is_simplex;$/;"	m	struct:apf::BoxBuilder
isf	test/refine2x.cc	/^    ma::SizeField* isf;$/;"	m	class:AnisotropicX	file:
iso	parma/diffMC/parma_components.cc	/^  unsigned DCC::iso() { return getNumIso(); }$/;"	f	class:parma::DCC
isoSize	sam/samSz.cc	/^apf::Field* isoSize(apf::Mesh* m) {$/;"	f	namespace:samSz
iso_field	sam/samElementCount.cc	/^  apf::Field* iso_field;$/;"	m	class:sam::TotalMetricVolumeIso	file:
isotag	parma/diffMC/parma_dcpart.h	/^      apf::MeshTag* isotag;$/;"	m	class:dcPart
isotropicIntersect	test/capStoneAttachSolution.cc	/^void isotropicIntersect(apf::Mesh* m, std::queue<apf::Field*> sizeFieldList,apf::Field* finalSizeField,apf::Field* finalChoiceField)$/;"	f
iter	pumi/mPartEntityContainer.h	/^    typedef ListIterator<gEntity> iter;$/;"	t	class:mPartEntityContainer
iterDim	apf_cap/apfCAP.h	/^    int iterDim;$/;"	m	class:apf::MeshCAP
iterDim	apf_sim/apfSIM.h	/^    int iterDim;$/;"	m	class:apf::MeshSIM
iterTime	parma/extractParmaResults.py	/^                        run.metrics[elmMigr.name])]$/;"	v
iterTimeAll	parma/extractParmaResults.py	/^iterTimeAll = []$/;"	v
iterall	pumi/pumi.h	/^  typedef mPartEntityContainer::iter iterall;$/;"	t	class:gModel
iterate	apf_cap/apfCAP.cc	/^MeshEntity* MeshCAP::iterate(MeshIterator* it)$/;"	f	class:apf::MeshCAP
iterate	apf_sim/apfSIM.cc	/^    virtual MeshEntity* iterate()$/;"	f	class:apf::EdgeIteratorSIM
iterate	apf_sim/apfSIM.cc	/^    virtual MeshEntity* iterate()$/;"	f	class:apf::FaceIteratorSIM
iterate	apf_sim/apfSIM.cc	/^    virtual MeshEntity* iterate()$/;"	f	class:apf::RegionIteratorSIM
iterate	apf_sim/apfSIM.cc	/^    virtual MeshEntity* iterate()$/;"	f	class:apf::VertexIteratorSIM
iterate	apf_sim/apfSIM.cc	/^MeshEntity* MeshSIM::iterate(MeshIterator* it)$/;"	f	class:apf::MeshSIM
iterate	mds/apfMDS.cc	/^    MeshEntity* iterate(MeshIterator* it)$/;"	f	class:apf::MeshMDS
iterate	parma/diffMC/parma_associative.h	/^      const Item* iterate() {$/;"	f	class:parma::Associative
iterate	parma/diffMC/parma_components.cc	/^      apf::MeshEntity* iterate() {$/;"	f	class:parma::dcComponents::BdryItr
iterateBdry	parma/diffMC/parma_components.cc	/^  apf::MeshEntity* dcComponents::iterateBdry() { return bItr->iterate(); }$/;"	f	class:parma::dcComponents
iterateBoundary	apf/apfMesh.cc	/^MeshEntity* iterateBoundary(Mesh* m, MeshIterator* it, int part)$/;"	f	namespace:apf
iterator	apf/apfCavityOp.h	/^    MeshIterator* iterator;$/;"	m	class:apf::CavityOp
iterator	apf_sim/apfSIM.cc	/^    EIter iterator;$/;"	m	class:apf::EdgeIteratorSIM	file:
iterator	apf_sim/apfSIM.cc	/^    FIter iterator;$/;"	m	class:apf::FaceIteratorSIM	file:
iterator	apf_sim/apfSIM.cc	/^    RIter iterator;$/;"	m	class:apf::RegionIteratorSIM	file:
iterator	apf_sim/apfSIM.cc	/^    VIter iterator;$/;"	m	class:apf::VertexIteratorSIM	file:
iterator	can/canArray.h	/^    typedef T* iterator;$/;"	t	class:can::Array
iteratorActive	parma/diffMC/parma_associative.h	/^      bool iteratorActive;$/;"	m	class:parma::Associative
itr	parma/diffMC/parma_components.cc	/^      Level::iterator itr;$/;"	m	class:parma::dcComponents::BdryItr	file:
key	proteushash.py	/^key = base64.b32encode(hasher.digest()[:20]).lower()$/;"	v
keyToIndex	phasta/phBlock.h	/^  Map keyToIndex;$/;"	m	struct:ph::BlocksCommon
keys	phasta/phBlock.h	/^  BlockKey keys[MAX_BLOCK_KEYS];$/;"	m	struct:ph::Blocks
keys	phasta/phBlock.h	/^  BlockKeyInterface keys[MAX_BLOCK_KEYS];$/;"	m	struct:ph::BlocksInterface
knots	test/fusion3.cc	/^  vector <double> knots;$/;"	m	class:BSpline	file:
knots1	test/fusion3.cc	/^double knots1[]={0.000000,0.000000,0.000000,0.000000,0.018182,0.036364,0.054545,0.072727,0.090909,0.109091,0.127273,0.145455,0.163636,0.181818,0.200000,0.218182,0.236364,0.254545,0.272727,0.290909,0.309091,0.327273,0.345455,0.363636,0.381818,0.400000,0.418182,0.436364,0.454545,0.472727,0.490909,0.509091,0.527273,0.545455,0.563636,0.581818,0.600000,0.618182,0.636364,0.654545,0.672727,0.690909,0.709091,0.727273,0.745455,0.763636,0.781818,0.800000,0.818182,0.836364,0.854545,0.872727,0.890909,0.909091,0.927273,0.945455,0.963636,0.981818,1.000000,1.000000,1.000000,1.000000};$/;"	v
knots2	test/fusion3.cc	/^double knots2[]={0.000000,0.000000,0.000000,0.000000,0.000000,0.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000};$/;"	v
knots3	test/fusion3.cc	/^double knots3[]={0.000000,0.000000,0.000000,0.000000,0.018182,0.036364,0.054545,0.072727,0.090909,0.109091,0.127273,0.145455,0.163636,0.181818,0.200000,0.218182,0.236364,0.254545,0.272727,0.290909,0.309091,0.327273,0.345455,0.363636,0.381818,0.400000,0.418182,0.436364,0.454545,0.472727,0.490909,0.509091,0.527273,0.545455,0.563636,0.581818,0.600000,0.618182,0.636364,0.654545,0.672727,0.690909,0.709091,0.727273,0.745455,0.763636,0.781818,0.800000,0.818182,0.836364,0.854545,0.872727,0.890909,0.909091,0.927273,0.945455,0.963636,0.981818,1.000000,1.000000,1.000000,1.000000};$/;"	v
knots4	test/fusion3.cc	/^double knots4[]={0.000000,0.000000,0.000000,0.000000,0.000000,0.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000};$/;"	v
knots5	test/fusion3.cc	/^double knots5[]={0.000000,0.000000,0.000000,0.000000,0.000000,0.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000};$/;"	v
knots6	test/fusion3.cc	/^double knots6[]={0.000000,0.000000,0.000000,0.000000,0.000000,0.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000};$/;"	v
knownSizes	phasta/phBC.cc	/^static struct { const char* name; int size; } const knownSizes[7] =$/;"	m	namespace:ph	file:
l	mds/mds_net.h	/^  unsigned** l;$/;"	m	struct:mds_links
l	parma/diffMC/parma_shapeSelector.cc	/^    uint l; \/\/used entries in d$/;"	m	struct:__anon57::UintArr	file:
l	parma/diffMC/parma_vtxSelector.cc	/^    uint l; \/\/used entries in d$/;"	m	struct:__anon59::UintArr	file:
l	test/eigen_test.cc	/^  double l[3];$/;"	m	struct:Input	file:
la	parma/diffMC/parma_graphDist.cc	/^  void la(apf::Mesh* m, apf::MeshTag* order=NULL) {$/;"	f	namespace:parma_ordering
last	pcu/pcu_aa.c	/^  pcu_aa_node* last;$/;"	m	struct:remove_vars	file:
last_bdry	gmi/agm.c	/^  int* last_bdry[AGM_ENT_TYPES];$/;"	m	struct:ents	file:
last_use	gmi/agm.c	/^  int* last_use[AGM_BDRY_TYPES];$/;"	m	struct:bdrys	file:
latest_version_number	apf/apfFile.cc	/^static int latest_version_number = 3;$/;"	m	namespace:apf	file:
layers	parma/diffMC/parma_ghost.cc	/^      int layers;$/;"	m	class:__anon68::GhostElmBalancer	file:
layers	parma/diffMC/parma_ghost.cc	/^      int layers;$/;"	m	class:__anon68::GhostVtxLtElmBalancer	file:
layers	parma/diffMC/parma_ghost.cc	/^    int layers;$/;"	m	class:GhostElmGtVtxBalancer	file:
layers	parma/diffMC/parma_ghostMPAS.cc	/^      int layers;$/;"	m	class:__anon67::MPASGhostBalancer	file:
layers	parma/diffMC/parma_ghostMPASWeights.cc	/^      int layers;$/;"	m	class:parma::GhostElementFinder	file:
layers	parma/diffMC/parma_ghostWeights.cc	/^      int layers;$/;"	m	class:parma::VtxGhostFinder	file:
left	pcu/pcu_aa.h	/^  pcu_aa_tree left;$/;"	m	struct:pcu_aa_node_struct
len	parma/diffMC/parma_components.cc	/^    double len;$/;"	m	struct:__anon65::Comp	file:
len	parma/diffMC/parma_monitor.h	/^      unsigned int len; \/* length of queue *\/$/;"	m	class:parma::CircBuffer
length	parma/diffMC/parma_monitor.cc	/^  unsigned int CircBuffer::length() { return len; }$/;"	f	class:parma::CircBuffer
less	pcu/pcu_aa.c	/^  pcu_aa_less* less;$/;"	m	struct:remove_vars	file:
level	pcu/pcu_aa.h	/^  int level;$/;"	m	struct:pcu_aa_node_struct
level	test/degenerateSurfs.cc	/^int level = 1;$/;"	v
lidSz	zoltan/apfZoltanCallbacks.h	/^    int lidSz;$/;"	m	class:apf::ZoltanData
limit_ent	gmi/agm.c	/^static void limit_ent(struct agm* m, struct agm_ent* e)$/;"	f	file:
line	mds/mdsGmsh.cc	/^  char* line;$/;"	m	struct:__anon96::Reader	file:
linear	apf/apfGeometry.h	/^  Matrix3x3 linear;$/;"	m	struct:apf::Frame
linear	test/hierarchic.cc	/^static double linear(int d, apf::Vector3 const& p) {$/;"	f	namespace:__anon20
linecap	mds/mdsGmsh.cc	/^  size_t linecap;$/;"	m	struct:__anon96::Reader	file:
linkAfter	pumi/pumi_list.h	/^    void linkAfter(ListMember* p)$/;"	f	class:ListMember
linkNewVerts	ma/maRefine.cc	/^static void linkNewVerts(Refine* r)$/;"	f	namespace:ma
linkTag	ma/maLayerSnap.cc	/^  Tag* linkTag;$/;"	m	struct:ma::BaseTopLinker	file:
lion	lion/lionBase64.cc	/^namespace lion {$/;"	n	file:
lion	lion/lionBase64.h	/^namespace lion {$/;"	n
lion	lion/lionCompress.h	/^namespace lion {$/;"	n
lion	lion/lionNoZLib.cc	/^namespace lion {$/;"	n	file:
lion	lion/lionZLib.cc	/^namespace lion {$/;"	n	file:
lion_eprint	lion/lionPrint.c	/^int lion_eprint(int lvl, char const* fmt, ...) {$/;"	f
lion_get_verbosity	lion/lionPrint.c	/^int lion_get_verbosity() {$/;"	f
lion_oprint	lion/lionPrint.c	/^int lion_oprint(int lvl, char const* fmt, ...) {$/;"	f
lion_set_stderr	lion/lionPrint.c	/^void lion_set_stderr(FILE* err) {$/;"	f
lion_set_stdout	lion/lionPrint.c	/^void lion_set_stdout(FILE* out) {$/;"	f
lion_set_verbosity	lion/lionPrint.c	/^void lion_set_verbosity(int lvl) {$/;"	f
lion_stderr	lion/lionPrint.c	/^FILE* lion_stderr = NULL;$/;"	v
lion_stdout	lion/lionPrint.c	/^FILE* lion_stdout = NULL;$/;"	v
lion_veprint	lion/lionPrint.c	/^int lion_veprint(int lvl, char const* fmt, va_list ap) {$/;"	f
lion_verbosity_level	lion/lionPrint.c	/^int lion_verbosity_level = 0;$/;"	v
lion_voprint	lion/lionPrint.c	/^int lion_voprint(int lvl, char const* fmt, va_list ap) {$/;"	f
list_tags	test/describe.cc	/^static void list_tags(apf::Mesh* m)$/;"	f	file:
load	phasta/phInput.cc	/^void Input::load(const char* filename)$/;"	f	class:ph::Input
loadCommon	phasta/phCook.cc	/^void loadCommon(ph::Input& in, ph::BCs& bcs, gmi_model*& g)$/;"	f	namespace:__anon77
loadMdsFromANSYS	mds/mdsANSYS.cc	/^Mesh2* loadMdsFromANSYS(const char* nodefile, const char* elemfile)$/;"	f	namespace:apf
loadMdsFromGmsh	mds/mdsGmsh.cc	/^Mesh2* loadMdsFromGmsh(gmi_model* g, const char* filename)$/;"	f	namespace:apf
loadMdsFromUgrid	mds/mdsUgrid.cc	/^  Mesh2* loadMdsFromUgrid(gmi_model* g, const char* filename)$/;"	f	namespace:apf
loadMdsMesh	mds/apfMDS.cc	/^Mesh2* loadMdsMesh(const char* modelfile, const char* meshfile)$/;"	f	namespace:apf
loadMdsMesh	mds/apfMDS.cc	/^Mesh2* loadMdsMesh(gmi_model* model, const char* meshfile)$/;"	f	namespace:apf
loadMdsPart	mds/apfMDS.cc	/^Mesh2* loadMdsPart(gmi_model* model, const char* meshfile)$/;"	f	namespace:apf
loadMesh	phasta/ph.cc	/^apf::Mesh2* loadMesh(gmi_model*& g, const char* meshfile) {$/;"	f	namespace:ph
loadMesh	phasta/phCook.cc	/^static apf::Mesh2* loadMesh(gmi_model*& g, ph::Input& in) {$/;"	f	namespace:__anon77
loadModelAndBCs	phasta/phBC.cc	/^void loadModelAndBCs(ph::Input& in, gmi_model*& m, BCs& bcs)$/;"	f	namespace:ph
loadNativeModel	test/generate.cc	/^pNativeModel loadNativeModel() {$/;"	f	namespace:__anon19
loadSerialMdsMesh	mds/apfMDS.cc	/^Mesh2* loadSerialMdsMesh(gmi_model* model, const char* meshfile)$/;"	f	namespace:apf
load_acis	gmi_sim/gmi_sim.cc	/^static pNativeModel load_acis(const char* \/*filename*\/)$/;"	f	file:
load_acis	gmi_sim/gmi_sim.cc	/^static pNativeModel load_acis(const char* filename)$/;"	f	file:
load_balance	test/simZBalance.cc	/^static void load_balance(apf::Mesh2* m) {$/;"	f	file:
load_parasolid	gmi_sim/gmi_sim.cc	/^static pNativeModel load_parasolid(const char* filename)$/;"	f	file:
local	zoltan/apfZoltanMesh.h	/^    Numbering* local;$/;"	m	class:apf::ZoltanMesh
localPtn	phasta/phInput.h	/^    int localPtn;$/;"	m	class:ph::Input
localWeight	parma/diffMC/parma_ghostWeights.cc	/^  double localWeight(apf::Mesh* m, apf::MeshTag* w, int dim) {$/;"	f	namespace:__anon69
localizeLayerStacks	ma/maLayerCoarsen.cc	/^void localizeLayerStacks(Mesh* m) {$/;"	f	namespace:ma
locations	ma/maMatchedSnapper.h	/^    apf::DynamicArray<Vector> locations;$/;"	m	class:ma::MatchedSnapper
log	mth/mthAD.h	/^AD<T, N> log(AD<T, N> const& A)$/;"	f	namespace:mth
log	mth/mthAD.h	/^double log(double A)$/;"	f	namespace:mth
logMEval	ma/maSize.cc	/^  LogMEval logMEval;$/;"	m	struct:ma::LogAnisoSizeField	file:
logMField	ma/maSize.cc	/^  apf::Field* logMField;$/;"	m	struct:ma::LogAnisoSizeField	file:
look	mds/mds.c	/^static void look(struct mds* m, mds_id e, int d, struct mds_set* s)$/;"	f	file:
look_down	mds/mds.c	/^static void look_down(struct mds* m, mds_id e, int d, struct mds_set* s)$/;"	f	file:
look_up	mds/mds.c	/^static void look_up(struct mds* m, mds_id const e, int d, struct mds_set* s)$/;"	f	file:
lookup	gmi/gmi_base.h	/^  struct gmi_lookup* lookup;$/;"	m	struct:gmi_base	typeref:struct:gmi_base::gmi_lookup
lookup	ma/maLayerSnap.cc	/^  Entity* lookup(int idx)$/;"	f	struct:ma::BaseTopLinker
lookup	mds/mds_order.c	/^static mds_id lookup(struct mds_tag* tag, mds_id old)$/;"	f	file:
lookup	stk/apfSTK.cc	/^static Node lookup(long id, GlobalMap& map)$/;"	f	namespace:apf
lookupVert	mds/mdsGmsh.cc	/^apf::MeshEntity* lookupVert(Reader* r, long nodeId, apf::ModelEntity* g)$/;"	f	namespace:__anon96
lookupVert	mds/mdsUgrid.cc	/^  apf::MeshEntity* lookupVert(Reader* r, long ftnNodeId) {$/;"	f	namespace:__anon101
loop	ma/maEdgeSwap.cc	/^    SwapLoop loop;$/;"	m	class:ma::SwapCavity	file:
lower	test/aniso_ma_test.cc	/^    ma::Vector lower;$/;"	m	class:AnIso	file:
lower	test/capStoneSizeFields.h	/^    ma::Vector lower;$/;"	m	class:GeomB737
lower	test/capStoneSizeFields.h	/^    ma::Vector lower;$/;"	m	class:GeomRobin
lower	test/capStoneSizeFields.h	/^    ma::Vector lower;$/;"	m	class:Linear3
lower	test/curvetest.cc	/^    ma::Vector lower;$/;"	m	class:Linear	file:
lower	test/dg_ma_test.cc	/^    ma::Vector lower;$/;"	m	class:Linear	file:
lower	test/ma_test.cc	/^    ma::Vector lower;$/;"	m	class:Linear	file:
lvl	parma/diffMC/parma_components.cc	/^      Level* lvl;$/;"	m	class:parma::dcComponents::BdryItr	file:
m	apf/apfIntegrate.cc	/^    double m;$/;"	m	class:apf::Measurer	file:
m	apf/apfMIS.h	/^    Mesh* m;$/;"	m	class:apf::MIS
m	apf/apfMatrix.cc	/^  double m;$/;"	m	struct:apf::SortStruct	file:
m	gmi/agm.c	/^  struct agm* m;$/;"	m	struct:agm_tag	typeref:struct:agm_tag::agm	file:
m	ma/maCrawler.cc	/^  Mesh* m;$/;"	m	struct:ma::LayerNumberer	file:
m	ma/maCrawler.cc	/^  Mesh* m;$/;"	m	struct:ma::Tagger	file:
m	ma/maCrawler.cc	/^  Mesh* m;$/;"	m	struct:ma::TopFlagger	file:
m	ma/maLayerCoarsen.cc	/^  Mesh* m;$/;"	m	struct:ma::CurveLocalizer	file:
m	ma/maLayerCollapse.h	/^  Mesh* m;$/;"	m	struct:ma::LayerCollapse
m	ma/maLayerRefine.cc	/^  Mesh* m;$/;"	m	struct:ma::Disambiguator	file:
m	ma/maLayerRefine.cc	/^  Mesh* m;$/;"	m	struct:ma::SplitTagger	file:
m	ma/maLayerSnap.cc	/^  Mesh* m;$/;"	m	struct:ma::BaseTopLinker	file:
m	ma/maLayerSnap.cc	/^  Mesh* m;$/;"	m	struct:ma::LayerSnapper	file:
m	ma/maLayerSnap.cc	/^  Mesh* m;$/;"	m	struct:ma::SnapTagger	file:
m	ma/maLayerSnap.cc	/^  Mesh* m;$/;"	m	struct:ma::UnsnapChecker	file:
m	ma/maLayerSnap.cc	/^  Mesh* m;$/;"	m	struct:ma::Unsnapper	file:
m	ma/maTetrahedronize.cc	/^  Mesh* m;$/;"	m	struct:ma::QuadMarker	file:
m	mds/apfBox.h	/^  Mesh2* m;$/;"	m	struct:apf::BoxBuilder
m	parma/diffMC/parma_centroidSelector.cc	/^      apf::Mesh* m;$/;"	m	class:__anon49::Distance	file:
m	parma/diffMC/parma_centroidSelector.cc	/^      apf::Mesh* m;$/;"	m	class:__anon49::DistanceQueue	file:
m	parma/diffMC/parma_components.h	/^      apf::Mesh* m;$/;"	m	class:parma::dcComponents::Components
m	parma/diffMC/parma_dcpart.h	/^      apf::Mesh* m;$/;"	m	class:dcPart
m	parma/diffMC/parma_dcpartFixer.cc	/^    apf::Mesh* m;$/;"	m	class:dcPartFixer::PartFixer	file:
m	parma/diffMC/parma_distQ.h	/^    apf::Mesh* m;$/;"	m	class:parma::DistanceQueue
m	parma/diffMC/parma_step.h	/^      apf::Mesh* m;$/;"	m	class:parma::Stepper
m	phasta/phSnap.cc	/^apf::Mesh2* m;$/;"	v
m	pumi/pumi.h	/^    pMesh m;$/;"	m	class:Distribution
m	pumi/pumi.h	/^    pMesh m;$/;"	m	class:Ghosting
m	test/refine2x.cc	/^    ma::Mesh* m;$/;"	m	class:AnisotropicX	file:
m2gClsfcn	phasta/phOutput.h	/^  int* m2gClsfcn;$/;"	m	struct:ph::EnsaArrays
m2gParCoord	phasta/phOutput.h	/^  double* m2gParCoord;$/;"	m	struct:ph::EnsaArrays
mPartEntityContainer	pumi/mPartEntityContainer.cc	/^mPartEntityContainer::mPartEntityContainer()$/;"	f	class:mPartEntityContainer
mPartEntityContainer	pumi/mPartEntityContainer.h	/^class mPartEntityContainer$/;"	c
m_mesh	crv/crv.h	/^    apf::Mesh2* m_mesh;$/;"	m	class:crv::MeshCurver
m_order	crv/crv.h	/^    int m_order;$/;"	m	class:crv::MeshCurver
ma	ma/ma.cc	/^namespace ma {$/;"	n	file:
ma	ma/ma.h	/^namespace ma {$/;"	n
ma	ma/maAdapt.cc	/^namespace ma {$/;"	n	file:
ma	ma/maAdapt.h	/^namespace ma {$/;"	n
ma	ma/maAffine.h	/^namespace ma {$/;"	n
ma	ma/maBalance.cc	/^namespace ma {$/;"	n	file:
ma	ma/maBalance.h	/^namespace ma {$/;"	n
ma	ma/maCoarsen.cc	/^namespace ma {$/;"	n	file:
ma	ma/maCoarsen.h	/^namespace ma {$/;"	n
ma	ma/maCollapse.cc	/^namespace ma {$/;"	n	file:
ma	ma/maCollapse.h	/^namespace ma {$/;"	n
ma	ma/maCrawler.cc	/^namespace ma {$/;"	n	file:
ma	ma/maCrawler.h	/^namespace ma {$/;"	n
ma	ma/maDoubleSplitCollapse.cc	/^namespace ma {$/;"	n	file:
ma	ma/maDoubleSplitCollapse.h	/^namespace ma {$/;"	n
ma	ma/maEdgeSwap.cc	/^namespace ma {$/;"	n	file:
ma	ma/maEdgeSwap.h	/^namespace ma {$/;"	n
ma	ma/maExtrude.cc	/^namespace ma {$/;"	n	file:
ma	ma/maExtrude.h	/^namespace ma {$/;"	n
ma	ma/maFaceSplit.cc	/^namespace ma {$/;"	n	file:
ma	ma/maFaceSplit.h	/^namespace ma {$/;"	n
ma	ma/maFaceSplitCollapse.cc	/^namespace ma {$/;"	n	file:
ma	ma/maFaceSplitCollapse.h	/^namespace ma {$/;"	n
ma	ma/maInput.cc	/^namespace ma {$/;"	n	file:
ma	ma/maInput.h	/^namespace ma {$/;"	n
ma	ma/maLayer.cc	/^namespace ma {$/;"	n	file:
ma	ma/maLayer.h	/^namespace ma {$/;"	n
ma	ma/maLayerCoarsen.cc	/^namespace ma {$/;"	n	file:
ma	ma/maLayerCollapse.cc	/^namespace ma {$/;"	n	file:
ma	ma/maLayerCollapse.h	/^namespace ma {$/;"	n
ma	ma/maLayerRefine.cc	/^namespace ma {$/;"	n	file:
ma	ma/maLayerSnap.cc	/^namespace ma {$/;"	n	file:
ma	ma/maLayerTables.cc	/^namespace ma {$/;"	n	file:
ma	ma/maLayerTemplates.cc	/^namespace ma {$/;"	n	file:
ma	ma/maMap.cc	/^namespace ma {$/;"	n	file:
ma	ma/maMap.h	/^namespace ma {$/;"	n
ma	ma/maMatch.cc	/^namespace ma {$/;"	n	file:
ma	ma/maMatch.h	/^namespace ma {$/;"	n
ma	ma/maMatchedCollapse.cc	/^namespace ma {$/;"	n	file:
ma	ma/maMatchedCollapse.h	/^namespace ma {$/;"	n
ma	ma/maMatchedSnapper.cc	/^namespace ma {$/;"	n	file:
ma	ma/maMatchedSnapper.h	/^namespace ma {$/;"	n
ma	ma/maMesh.cc	/^namespace ma {$/;"	n	file:
ma	ma/maMesh.h	/^namespace ma {$/;"	n
ma	ma/maOperator.cc	/^namespace ma {$/;"	n	file:
ma	ma/maOperator.h	/^namespace ma {$/;"	n
ma	ma/maQuality.cc	/^namespace ma {$/;"	n	file:
ma	ma/maRefine.cc	/^namespace ma {$/;"	n	file:
ma	ma/maRefine.h	/^namespace ma {$/;"	n
ma	ma/maRegionCollapse.cc	/^namespace ma {$/;"	n	file:
ma	ma/maRegionCollapse.h	/^namespace ma {$/;"	n
ma	ma/maReposition.cc	/^namespace ma {$/;"	n	file:
ma	ma/maReposition.h	/^namespace ma {$/;"	n
ma	ma/maShape.cc	/^namespace ma {$/;"	n	file:
ma	ma/maShape.h	/^namespace ma {$/;"	n
ma	ma/maShapeHandler.cc	/^namespace ma {$/;"	n	file:
ma	ma/maShapeHandler.h	/^namespace ma {$/;"	n
ma	ma/maShortEdgeRemover.cc	/^namespace ma {$/;"	n	file:
ma	ma/maShortEdgeRemover.h	/^namespace ma {$/;"	n
ma	ma/maSize.cc	/^namespace ma {$/;"	n	file:
ma	ma/maSize.h	/^namespace ma {$/;"	n
ma	ma/maSnap.cc	/^namespace ma {$/;"	n	file:
ma	ma/maSnap.h	/^namespace ma {$/;"	n
ma	ma/maSnap_mohara.cc	/^namespace ma {$/;"	n	file:
ma	ma/maSnapper.cc	/^namespace ma {$/;"	n	file:
ma	ma/maSnapper.h	/^namespace ma {$/;"	n
ma	ma/maSolutionTransfer.cc	/^namespace ma {$/;"	n	file:
ma	ma/maSolutionTransfer.h	/^namespace ma {$/;"	n
ma	ma/maSplits.cc	/^namespace ma {$/;"	n	file:
ma	ma/maSplits.h	/^namespace ma {$/;"	n
ma	ma/maStats.cc	/^namespace ma {$/;"	n	file:
ma	ma/maStats.h	/^namespace ma {$/;"	n
ma	ma/maTables.cc	/^namespace ma {$/;"	n	file:
ma	ma/maTables.h	/^namespace ma {$/;"	n
ma	ma/maTemplates.cc	/^namespace ma {$/;"	n	file:
ma	ma/maTemplates.h	/^namespace ma {$/;"	n
ma	ma/maTetrahedronize.cc	/^namespace ma {$/;"	n	file:
ma	ma/maTetrahedronize.h	/^namespace ma {$/;"	n
ma	ma/maVertRemover.cc	/^namespace ma {$/;"	n	file:
ma	ma/maVertRemover.h	/^namespace ma {$/;"	n
ma_dbg	ma/maDBG.cc	/^namespace ma_dbg {$/;"	n	file:
ma_dbg	ma/maDBG.h	/^namespace ma_dbg {$/;"	n
magic_name	phasta/phIO.c	/^static const char* magic_name = "byteorder magic number";$/;"	v	file:
magnitude	phasta/phAttrib.cc	/^  pAttributeDouble magnitude;$/;"	m	struct:CompBC	file:
main	ma/prismCodeMatch.cc	/^int main()$/;"	f
main	ma/pyramidCodeMatch.cc	/^int main()$/;"	f
main	ma/rotateOct.cc	/^int main()$/;"	f
main	ma/sliverCodeMatch.cc	/^int main()$/;"	f
main	ma/tetCodeMatch.cc	/^int main()$/;"	f
main	parma/diffMC/maximalIndependentSet/test/testMIS.cc	/^int main(int argc, char** argv) {$/;"	f
main	parma/diffMC/zeroOneKnapsackTest.c	/^int main() {$/;"	f
main	phasta/adaptLvlSet_loop.cc	/^int main(int argc, char** argv) {$/;"	f
main	phasta/chef.cc	/^int main(int argc, char** argv)$/;"	f
main	phasta/chefStream.cc	/^int main(int argc, char** argv) {$/;"	f
main	phasta/condense.cc	/^int main(int argc, char** argv) {$/;"	f
main	phasta/cut_interface.cc	/^int main(int argc, char** argv)$/;"	f
main	phasta/migrate_interface.cc	/^int main(int argc, char** argv)$/;"	f
main	phasta/ph_convert.cc	/^int main(int argc, char** argv)$/;"	f
main	phasta/readUrPrep.cc	/^int main(int argc, char** argv)$/;"	f
main	phasta/threshold.cc	/^int main(int argc, char** argv)$/;"	f
main	test/1d.cc	/^int main(int argc, char** argv)$/;"	f
main	test/align.cc	/^int main()$/;"	f
main	test/aniso_ma_test.cc	/^int main(int argc, char** argv)$/;"	f
main	test/ansys.cc	/^int main(int argc, char** argv)$/;"	f
main	test/assert_timing.cc	/^int main(int argc, char** argv) {$/;"	f
main	test/balance.cc	/^int main(int argc, char** argv)$/;"	f
main	test/base64.cc	/^int main ( )$/;"	f
main	test/bezierElevation.cc	/^int main(int argc, char** argv)$/;"	f
main	test/bezierMesh.cc	/^int main(int argc, char** argv)$/;"	f
main	test/bezierMisc.cc	/^int main(int argc, char** argv)$/;"	f
main	test/bezierRefine.cc	/^int main(int argc, char** argv)$/;"	f
main	test/bezierSubdivision.cc	/^int main(int argc, char** argv)$/;"	f
main	test/bezierValidity.cc	/^int main(int argc, char** argv)$/;"	f
main	test/box.cc	/^int main(int argc, char** argv)$/;"	f
main	test/capStone2VTK.cc	/^int main(int argc, char** argv)$/;"	f
main	test/capStoneAnisoAdapt.cc	/^int main(int argc, char** argv)$/;"	f
main	test/capStoneAnisoAdaptWing.cc	/^int main(int argc, char** argv)$/;"	f
main	test/capStoneAttachSolution.cc	/^int main(int argc, char** argv)$/;"	f
main	test/capStoneCheckParametrization.cc	/^int main(int argc, char** argv)$/;"	f
main	test/capStoneGeomTest.cc	/^int main(int argc, char** argv)$/;"	f
main	test/capStoneIsoAdaptB737.cc	/^int main(int argc, char** argv)$/;"	f
main	test/collapse.cc	/^int main(int argc, char** argv) {$/;"	f
main	test/construct.cc	/^int main(int argc, char** argv)$/;"	f
main	test/convert.cc	/^int main(int argc, char** argv)$/;"	f
main	test/crack_test.cc	/^int main(int argc, char** argv)$/;"	f
main	test/create_mis.cc	/^int main(int argc, char** argv)$/;"	f
main	test/curve_to_bezier.cc	/^int main(int argc, char** argv)$/;"	f
main	test/curvetest.cc	/^int main(int argc, char** argv)$/;"	f
main	test/degenerateSurfs.cc	/^int main(int argc, char** argv)$/;"	f
main	test/describe.cc	/^int main(int argc, char** argv)$/;"	f
main	test/dg_ma_test.cc	/^int main(int argc, char** argv)$/;"	f
main	test/eigen_test.cc	/^int main()$/;"	f
main	test/elmBalance.cc	/^int main(int argc, char** argv)$/;"	f
main	test/extrude.cc	/^int main(int argc, char** argv)$/;"	f
main	test/fieldReduce.cc	/^int main(int argc, char** argv)$/;"	f
main	test/field_io.cc	/^int main(int argc, char** argv)$/;"	f
main	test/fixDisconnected.cc	/^int main(int argc, char** argv)$/;"	f
main	test/fixlayer.cc	/^int main(int argc, char** argv)$/;"	f
main	test/fixshape.cc	/^int main(int argc, char** argv)$/;"	f
main	test/fusion.cc	/^int main( int argc, char* argv[])$/;"	f
main	test/fusion2.cc	/^int main( int argc, char* argv[])$/;"	f
main	test/fusion3.cc	/^int main(int argc, char * argv[])$/;"	f
main	test/gap.cc	/^int main(int argc, char** argv)$/;"	f
main	test/generate.cc	/^int main(int argc, char** argv)$/;"	f
main	test/ghost.cc	/^int main(int argc, char** argv)$/;"	f
main	test/ghostEdge.cc	/^int main(int argc, char** argv)$/;"	f
main	test/ghostMPAS.cc	/^int main(int argc, char** argv)$/;"	f
main	test/gmsh.cc	/^int main(int argc, char** argv)$/;"	f
main	test/graphdist.cc	/^int main(int argc, char** argv)$/;"	f
main	test/hierarchic.cc	/^int main(int argc, char** argv)$/;"	f
main	test/icesheet.cc	/^int main(int argc, char** argv)$/;"	f
main	test/inClosureOf_test.cc	/^int main(int argc, char** argv)$/;"	f
main	test/integrate.cc	/^int main()$/;"	f
main	test/intrude.cc	/^int main(int argc, char** argv)$/;"	f
main	test/loadPart.cc	/^int main(int argc, char** argv)$/;"	f
main	test/ma_insphere.cc	/^int main(int argc, char** argv)$/;"	f
main	test/ma_test.cc	/^int main(int argc, char** argv)$/;"	f
main	test/mdlConvert.cc	/^int main(int argc, char** argv)$/;"	f
main	test/measureAnisoStats.cc	/^int main(int argc, char** argv)$/;"	f
main	test/measureIsoStats.cc	/^int main(int argc, char** argv)$/;"	f
main	test/mixedNumbering.cc	/^int main(int argc, char** argv)$/;"	f
main	test/mkmodel.cc	/^int main(int argc, char** argv)$/;"	f
main	test/mktopomodel.cc	/^int main(int argc, char** argv)$/;"	f
main	test/modelInfo.cc	/^int main(int argc, char** argv)$/;"	f
main	test/moving.cc	/^int main(int argc, char** argv)$/;"	f
main	test/nektar_align.cc	/^int main(int argc, char** argv)$/;"	f
main	test/neper.cc	/^int main(int argc, char** argv)$/;"	f
main	test/newdim.cc	/^int main(int argc, char** argv)$/;"	f
main	test/osh2smb.cc	/^int main(int argc, char** argv) {$/;"	f
main	test/outputcontrol.cc	/^int main(int argc, char** argv) {$/;"	f
main	test/ph_adapt.cc	/^int main(int argc, char** argv)$/;"	f
main	test/poisson.cc	/^int main(int argc, char** argv) {$/;"	f
main	test/ptnParma.cc	/^int main(int argc, char** argv)$/;"	f
main	test/pumi.cc	/^int main(int argc, char** argv)$/;"	f
main	test/qr.cc	/^int main()$/;"	f
main	test/quality.cc	/^int main(int argc, char** argv)$/;"	f
main	test/refine2x.cc	/^int main(int argc, char** argv)$/;"	f
main	test/render.cc	/^int main(int argc, char** argv)$/;"	f
main	test/renderClass.cc	/^int main(int argc, char** argv)$/;"	f
main	test/render_ascii.cc	/^int main(int argc, char** argv)$/;"	f
main	test/reorder.cc	/^int main(int argc, char** argv) {$/;"	f
main	test/repartition.cc	/^int main(int argc, char** argv)$/;"	f
main	test/reposition.cc	/^int main(int argc, char** argv)$/;"	f
main	test/rm_extrusion.cc	/^int main(int argc, char** argv)$/;"	f
main	test/runSimxAnisoAdapt.cc	/^int main(int argc, char** argv)$/;"	f
main	test/scale.cc	/^int main(int argc, char** argv) {$/;"	f
main	test/serialize.cc	/^int main( int argc, char* argv[])$/;"	f
main	test/shapefun.cc	/^int main(int argc, char** argv)$/;"	f
main	test/shapefun2.cc	/^int main(int argc, char** argv)$/;"	f
main	test/simDiscrete.cc	/^int main(int argc, char *argv[])$/;"	f
main	test/simSpjToSmd.cc	/^int main(int argc, char* argv[])$/;"	f
main	test/simTranslate.cc	/^int main(int argc, char* argv[])$/;"	f
main	test/simZBalance.cc	/^int main(int argc, char** argv) {$/;"	f
main	test/sim_countBL.cc	/^int main(int argc, char **argv)$/;"	f
main	test/sim_part.cc	/^int main(int argc, char **argv)$/;"	f
main	test/smb2osh.cc	/^int main(int argc, char** argv) {$/;"	f
main	test/snap.cc	/^int main(int argc, char** argv)$/;"	f
main	test/split.cc	/^int main(int argc, char** argv)$/;"	f
main	test/spr_test.cc	/^int main(int argc, char** argv)$/;"	f
main	test/tensor.cc	/^int main()$/;"	f
main	test/test_AD.cc	/^int main()$/;"	f
main	test/test_integrator.cc	/^int main(int argc, char ** argv) {$/;"	f
main	test/test_matrix_grad.cc	/^int main(int argc, char* argv[])$/;"	f
main	test/test_scaling.cc	/^int main(int argc, char** argv)$/;"	f
main	test/test_verify.cc	/^int main(int argc, char** argv)$/;"	f
main	test/tetrahedronize.cc	/^int main(int argc, char** argv)$/;"	f
main	test/torus_ma_test.cc	/^int main(int argc, char** argv)$/;"	f
main	test/ugrid.cc	/^int main(int argc, char** argv)$/;"	f
main	test/ugridptnstats.cc	/^int main(int argc, char** argv)$/;"	f
main	test/uniform.cc	/^int main(int argc, char** argv)$/;"	f
main	test/verify.cc	/^int main(int argc, char** argv)$/;"	f
main	test/verify_2nd_order_shapes.cc	/^int main(int argc, char** argv) {$/;"	f
main	test/verify_convert.cc	/^int main(int argc, char* argv[])$/;"	f
main	test/visualizeAnisoSizes.cc	/^int main(int argc, char** argv)$/;"	f
main	test/viz.cc	/^int main(int argc, char** argv)$/;"	f
main	test/vtxBalance.cc	/^int main(int argc, char** argv)$/;"	f
main	test/vtxEdgeElmBalance.cc	/^int main(int argc, char** argv)$/;"	f
main	test/vtxElmBalance.cc	/^int main(int argc, char** argv)$/;"	f
main	test/vtxElmMixedBalance.cc	/^int main(int argc, char** argv)$/;"	f
main	test/writeIPFieldTest.cc	/^int main(int argc, char** argv)$/;"	f
main	test/writePart.cc	/^int main(int argc, char** argv)$/;"	f
main	test/writeVtxPtn.cc	/^int main(int argc, char** argv)$/;"	f
main	test/xgc_split.cc	/^int main(int argc, char** argv)$/;"	f
main	test/zbalance.cc	/^int main(int argc, char** argv)$/;"	f
main	test/zsplit.cc	/^int main(int argc, char** argv)$/;"	f
make	apf/apfTagData.h	/^    MeshTag* make(Mesh* m, const char* n, int s)$/;"	f	class:apf::TagHelper
makeBSpline	test/fusion3.cc	/^void makeBSpline(BSpline** splines, int  order, int numPts, double* ctrlPts, double * knots)$/;"	f
makeBdryVtxDistItr	parma/diffMC/parma_bdryVtx.cc	/^  BdryVtxItr* makeBdryVtxDistItr(apf::Mesh* m, apf::MeshTag* d) {$/;"	f	namespace:parma
makeBodies	parma/rib/parma_mesh_rib.cc	/^Body** makeBodies(apf::DynamicArray<Body>& arr) {$/;"	f	namespace:parma
makeCentroidSelector	parma/diffMC/parma_centroidSelector.cc	/^  Selector* makeCentroidSelector(apf::Mesh* m, apf::MeshTag* w, Centroids* c) {$/;"	f	namespace:parma
makeConstantBC	phasta/phBC.cc	/^ConstantBC* makeConstantBC(BCs& bcs, std::string const& name, int dim, int tag,$/;"	f	namespace:ph
makeDeprecated	phasta/phInput.cc	/^static void makeDeprecated(stringset& old)$/;"	f	namespace:ph
makeDirectories	crv/crvVtk.cc	/^static void makeDirectories(const char* prefix, int type, int n)$/;"	f	namespace:crv
makeEdgeEqVtxSelector	parma/diffMC/parma_edgeEqVtxSelector.cc	/^  Selector* makeEdgeEqVtxSelector(apf::Mesh* m, apf::MeshTag* w, double maxVtx) {$/;"	f	namespace:parma
makeEdgeModel	test/bezierElevation.cc	/^gmi_model* makeEdgeModel()$/;"	f
makeEdgeModel	test/bezierSubdivision.cc	/^gmi_model* makeEdgeModel()$/;"	f
makeEdgeSwap	ma/maEdgeSwap.cc	/^EdgeSwap* makeEdgeSwap(Adapt* a)$/;"	f	namespace:ma
makeEllipsoid	test/visualizeAnisoSizes.cc	/^void makeEllipsoid($/;"	f
makeElmBdrySides	parma/diffMC/parma_elmBdrySides.cc	/^  Sides* makeElmBdrySides(apf::Mesh* m) {$/;"	f	namespace:parma
makeElmGhostWeights	parma/diffMC/parma_ghostWeights.cc	/^  GhostWeights* makeElmGhostWeights(apf::Mesh* m, apf::MeshTag* w, Sides* s) {$/;"	f	namespace:parma
makeElmLtVtxEdgeBalancer	parma/diffMC/parma_elmLtVtxEdgeBalancer.cc	/^  apf::Balancer* makeElmLtVtxEdgeBalancer(apf::Mesh* m, double maxVtx,$/;"	f	namespace:parma
makeElmLtVtxEdgeSelector	parma/diffMC/parma_elmLtVtxEdgeSelector.cc	/^  Selector* makeElmLtVtxEdgeSelector(apf::Mesh* m, apf::MeshTag* w, double maxVtx, double maxEdge) {$/;"	f	namespace:parma
makeElmLtVtxEdgeTargets	parma/diffMC/parma_elmLtVtxEdgeTargets.cc	/^  Targets* makeElmLtVtxEdgeTargets(Sides* s, Weights* w[3], int sideTol,$/;"	f	namespace:parma
makeElmLtVtxSelector	parma/diffMC/parma_ltSelector.cc	/^  Selector* makeElmLtVtxSelector(apf::Mesh* m, apf::MeshTag* w, double maxVtx) {$/;"	f	namespace:parma
makeElmSelector	parma/diffMC/parma_elmSelector.cc	/^  Selector* makeElmSelector(apf::Mesh* m, apf::MeshTag* w) {$/;"	f	namespace:parma
makeElmSideSides	parma/diffMC/parma_elmSideSides.cc	/^  Sides* makeElmSideSides(apf::Mesh* m) {$/;"	f	namespace:parma
makeEmpty	dsp/dspAdapters.cc	/^Adapter* Adapter::makeEmpty()$/;"	f	class:dsp::Adapter
makeEmpty	dsp/dspSmoothers.cc	/^Smoother* Smoother::makeEmpty()$/;"	f	class:dsp::Smoother
makeEmptyMdsMesh	mds/apfMDS.cc	/^Mesh2* makeEmptyMdsMesh(gmi_model* model, int dim, bool isMatched)$/;"	f	namespace:apf
makeEmptyMesh	test/fusion2.cc	/^static apf::Mesh2* makeEmptyMesh()$/;"	f	file:
makeEntWeights	parma/diffMC/parma_entWeights.cc	/^  Weights* makeEntWeights(apf::Mesh* m, apf::MeshTag* w, Sides* s, int dim) {$/;"	f	namespace:parma
makeFaceModel	test/bezierElevation.cc	/^gmi_model* makeFaceModel()$/;"	f
makeFaceModel	test/bezierSubdivision.cc	/^gmi_model* makeFaceModel()$/;"	f
makeField	apf/apf.cc	/^Field* makeField($/;"	f	namespace:apf
makeGRStream	phasta/phstream.cc	/^GRStream* makeGRStream() {$/;"	f
makeGhostMPASWeights	parma/diffMC/parma_ghostMPASWeights.cc	/^  Weights* makeGhostMPASWeights(apf::Mesh* m, apf::MeshTag* w, Sides* s,$/;"	f	namespace:parma
makeGlobal	apf/apfMixedNumbering.cc	/^void makeGlobal($/;"	f	namespace:apf
makeGlobal	apf/apfNumbering.cc	/^GlobalNumbering* makeGlobal(Numbering* n, bool destroy)$/;"	f	namespace:apf
makeIter	mds/apfMDS.cc	/^static MeshIterator* makeIter()$/;"	f	namespace:apf
makeKnapsack	parma/diffMC/zeroOneKnapsack.c	/^Knapsack makeKnapsack(size_t MaxWeight, size_t NumItems, $/;"	f
makeLaplacian	dsp/dspSmoothers.cc	/^Smoother* Smoother::makeLaplacian()$/;"	f	class:dsp::Smoother
makeMdsBox	mds/apfBox.cc	/^Mesh2* makeMdsBox($/;"	f	namespace:apf
makeModel	test/bezierMesh.cc	/^gmi_model* makeModel()$/;"	f
makeModel	test/bezierRefine.cc	/^gmi_model* makeModel()$/;"	f
makeModel	test/bezierValidity.cc	/^gmi_model* makeModel()$/;"	f
makeModel	test/fusion.cc	/^gmi_model* makeModel()$/;"	f
makeModel	test/fusion3.cc	/^gmi_model* makeModel()$/;"	f
makeNewElements	ma/maFaceSplit.cc	/^void FaceSplit::makeNewElements()$/;"	f	class:ma::FaceSplit
makeNewElements	ma/maSplits.cc	/^void Splits::makeNewElements()$/;"	f	class:ma::Splits
makeNewFaces	ma/maEdgeSwap.cc	/^    void makeNewFaces()$/;"	f	class:ma::EdgeSwap2D
makeOrFind	apf/apfMesh2.cc	/^MeshEntity* makeOrFind($/;"	f	namespace:apf
makeOrFindTag	apf/apfTagData.cc	/^MeshTag* TagData::makeOrFindTag(const char* name, int size)$/;"	f	class:apf::TagData
makePlaneConstraint	phasta/phConstraint.cc	/^static Constraint* makePlaneConstraint(double* values)$/;"	f	namespace:ph
makePlaneConstraintElas	phasta/phConstraint.cc	/^static Constraint* makePlaneConstraintElas(double* values)$/;"	f	namespace:ph
makePointConstraint	phasta/phConstraint.cc	/^static Constraint* makePointConstraint(double* values)$/;"	f	namespace:ph
makePointConstraintElas	phasta/phConstraint.cc	/^static Constraint* makePointConstraintElas(double* values)$/;"	f	namespace:ph
makePreservingTargets	parma/diffMC/parma_preserveTargets.cc	/^  Targets* makePreservingTargets(Sides* s, Weights* balanceW, Weights* preserveW,$/;"	f	namespace:parma
makePyramidCentroid	ma/maLayerTemplates.cc	/^static Entity* makePyramidCentroid(Adapt* a, Entity* p)$/;"	f	namespace:ma
makeQuality	crv/crvQuality.cc	/^Quality* makeQuality(apf::Mesh* m, int algorithm)$/;"	f	namespace:crv
makeRStream	phasta/phstream.cc	/^RStream* makeRStream() {$/;"	f
makeRecoveredField	spr/sprRecoverField.cc	/^static apf::Field* makeRecoveredField(Recovery* r)$/;"	f	namespace:spr
makeResidence	apf/apfMigrate.cc	/^static Parts makeResidence(int part)$/;"	f	namespace:apf
makeRunLog	parma/extractParmaResults.py	/^def makeRunLog():$/;"	f
makeShapeSelector	parma/diffMC/parma_shapeSelector.cc	/^  Selector* makeShapeSelector(apf::Mesh* m, apf::MeshTag* wtag) {$/;"	f	namespace:parma
makeShapeTargets	parma/diffMC/parma_shapeTargets.cc	/^  Targets* makeShapeTargets(Sides* s) {$/;"	f	namespace:parma
makeSimxModelAndMesh	test/runSimxAnisoAdapt.cc	/^void makeSimxModelAndMesh($/;"	f
makeSizeField	ma/maSize.cc	/^SizeField* makeSizeField(Mesh* m, AnisotropicFunction* f,$/;"	f	namespace:ma
makeSizeField	ma/maSize.cc	/^SizeField* makeSizeField(Mesh* m, IsotropicFunction* f)$/;"	f	namespace:ma
makeSizeField	ma/maSize.cc	/^SizeField* makeSizeField(Mesh* m, apf::Field* size)$/;"	f	namespace:ma
makeSizeField	ma/maSize.cc	/^SizeField* makeSizeField(Mesh* m, apf::Field* sizes, apf::Field* frames,$/;"	f	namespace:ma
makeSplitVert	ma/maRefine.cc	/^Entity* makeSplitVert(Refine* r, Entity* edge)$/;"	f	namespace:ma
makeSplitVertOnFace	ma/maFaceSplit.cc	/^Entity* makeSplitVertOnFace(Adapt* a, Entity* face)$/;"	f	namespace:ma
makeStkField	stk/apfSTK.cc	/^StkScalarField* makeStkField<StkScalarField>($/;"	f	namespace:apf
makeStkField	stk/apfSTK.cc	/^StkTensorField* makeStkField<StkTensorField>($/;"	f	namespace:apf
makeStkField	stk/apfSTK.cc	/^StkVectorField* makeStkField<StkVectorField>($/;"	f	namespace:apf
makeStkNumberings	stk/apfMeshSTK.cc	/^void makeStkNumberings(Mesh* m, GlobalNumbering* n[4])$/;"	f	namespace:apf
makeStkQPField	stk/apfSTK.cc	/^StkQPScalarField* makeStkQPField<StkQPScalarField>($/;"	f	namespace:apf
makeStkQPField	stk/apfSTK.cc	/^StkQPTensorField* makeStkQPField<StkQPTensorField>($/;"	f	namespace:apf
makeStkQPField	stk/apfSTK.cc	/^StkQPVectorField* makeStkQPField<StkQPVectorField>($/;"	f	namespace:apf
makeTargets	parma/diffMC/parma_weightTargets.cc	/^  Targets* makeTargets(Sides* s, Weights* w, double alpha) {$/;"	f	namespace:parma
makeUintArr	parma/diffMC/parma_shapeSelector.cc	/^  UintArr* makeUintArr(uint n) {$/;"	f	namespace:__anon57
makeUintArr	parma/diffMC/parma_vtxSelector.cc	/^  UintArr* makeUintArr(uint n) {$/;"	f	namespace:__anon59
makeUniform	dsp/dspAdapters.cc	/^Adapter* Adapter::makeUniform(double size)$/;"	f	class:dsp::Adapter
makeVtuSubdirectories	apf/apfVtk.cc	/^static void makeVtuSubdirectories(const char* prefix, int numParts)$/;"	f	namespace:apf
makeVtx	mds/mdsUgrid.cc	/^  apf::MeshEntity* makeVtx(Reader* r,$/;"	f	namespace:__anon101
makeVtxEdgeTargets	parma/diffMC/parma_vtxEdgeTargets.cc	/^  Targets* makeVtxEdgeTargets(Sides* s, Weights* w[2], int sideTol,$/;"	f	namespace:parma
makeVtxGhostWeights	parma/diffMC/parma_ghostWeights.cc	/^  GhostWeights* makeVtxGhostWeights(apf::Mesh* m, apf::MeshTag* w, Sides* s,$/;"	f	namespace:parma
makeVtxLtElmSelector	parma/diffMC/parma_ltSelector.cc	/^  Selector* makeVtxLtElmSelector(apf::Mesh* m, apf::MeshTag* w, double maxElm) {$/;"	f	namespace:parma
makeVtxSelector	parma/diffMC/parma_vtxSelector.cc	/^  Selector* makeVtxSelector(apf::Mesh* m, apf::MeshTag* w) {$/;"	f	namespace:parma
makeVtxSides	parma/diffMC/parma_vtxSides.cc	/^  Sides* makeVtxSides(apf::Mesh* m) {$/;"	f	namespace:parma
makeWeightSideTargets	parma/diffMC/parma_weightSideTargets.cc	/^  Targets* makeWeightSideTargets(Sides* s, Weights* w, int sideTol, $/;"	f	namespace:parma
makeZoltanBalancer	zoltan/apfZoltan.cc	/^Balancer* makeZoltanBalancer(Mesh* mesh, int method, int approach,$/;"	f	namespace:apf
makeZoltanBalancer	zoltan/apfZoltanEmpty.cc	/^Balancer* makeZoltanBalancer(Mesh*, int, int, bool)$/;"	f	namespace:apf
makeZoltanGlobalSplitter	zoltan/apfZoltan.cc	/^Splitter* makeZoltanGlobalSplitter(Mesh* mesh, int method, int approach,$/;"	f	namespace:apf
makeZoltanGlobalSplitter	zoltan/apfZoltanEmpty.cc	/^Splitter* makeZoltanGlobalSplitter(Mesh*, int, int, bool)$/;"	f	namespace:apf
makeZoltanSplitter	zoltan/apfZoltan.cc	/^Splitter* makeZoltanSplitter(Mesh* mesh, int method, int approach,$/;"	f	namespace:apf
makeZoltanSplitter	zoltan/apfZoltanEmpty.cc	/^Splitter* makeZoltanSplitter(Mesh*, int, int, bool, bool)$/;"	f	namespace:apf
make_comm	pcu/pcu_msg.c	/^static void make_comm(pcu_msg* m)$/;"	f	file:
make_edge_topo	test/bezierElevation.cc	/^void make_edge_topo(gmi_model* m, gmi_ent* e, int v0tag, int v1tag)$/;"	f
make_edge_topo	test/bezierMesh.cc	/^void make_edge_topo(gmi_model* m, gmi_ent* e, int v0tag, int v1tag)$/;"	f
make_edge_topo	test/bezierRefine.cc	/^void make_edge_topo(gmi_model* m, gmi_ent* e, int v0tag, int v1tag)$/;"	f
make_edge_topo	test/bezierSubdivision.cc	/^void make_edge_topo(gmi_model* m, gmi_ent* e, int v0tag, int v1tag)$/;"	f
make_edge_topo	test/bezierValidity.cc	/^void make_edge_topo(gmi_model* m, gmi_ent* e, int v0tag, int v1tag)$/;"	f
make_edge_topo	test/fusion3.cc	/^void make_edge_topo(gmi_model* m, gmi_ent* e, int v0tag, int v1tag)$/;"	f
make_faces_topo	test/fusion3.cc	/^void make_faces_topo(gmi_model* m, gmi_ent* faces[numGF])$/;"	f
make_peer	pcu/pcu_msg.c	/^static pcu_msg_peer* make_peer(int id)$/;"	f	file:
make_queue	mds/mds_order.c	/^static void make_queue(struct queue* q, mds_id n)$/;"	f	file:
make_verts	mds/mds_smb.c	/^static void make_verts(struct mds_apf* m)$/;"	f	file:
maker	apf/apfTagData.h	/^    TagMaker* maker;$/;"	m	class:apf::TagData
mapLocalToGlobal	apf/apf.cc	/^void mapLocalToGlobal(MeshElement* e, Vector3 const& local, Vector3& global)$/;"	f	namespace:apf
mapiu	parma/diffMC/maximalIndependentSet/mis.h	/^    typedef std::map<int, unsigned> mapiu;$/;"	t	namespace:misLuby
mapiuItr	parma/diffMC/maximalIndependentSet/mis.h	/^    typedef mapiu::iterator mapiuItr;$/;"	t	namespace:misLuby
markBadQuality	ma/maShape.cc	/^int markBadQuality(Adapt* a)$/;"	f	namespace:ma
markBaseEdgesToCollapse	ma/maLayerCoarsen.cc	/^static long markBaseEdgesToCollapse(Adapt* a)$/;"	f	namespace:ma
markCrvBadQuality	crv/crvShape.cc	/^int markCrvBadQuality(Adapt* a)$/;"	f	namespace:crv
markEdges	crv/crvShape.cc	/^static int markEdges(ma::Mesh* m, ma::Entity* e, int tag,$/;"	f	namespace:crv
markEdgesInitial	test/capStoneAttachSolution.cc	/^void markEdgesInitial(apf::Mesh* m, apf::Field* size_iso, std::queue<apf::MeshEntity*> &markedEdges,double gradingFactor)$/;"	f
markEdgesOppLargeAnglesTet	crv/crvShape.cc	/^static int markEdgesOppLargeAnglesTet(Adapt* a)$/;"	f	namespace:crv
markEdgesOppLargeAnglesTri	crv/crvShape.cc	/^static int markEdgesOppLargeAnglesTri(Adapt* a)$/;"	f	namespace:crv
markEdgesToCollapse	ma/maCoarsen.cc	/^long markEdgesToCollapse(Adapt* a)$/;"	f	namespace:ma
markEdgesToFix	crv/crvShape.cc	/^static int markEdgesToFix(Adapt* a, int flag)$/;"	f	namespace:crv
markEdgesToSplit	ma/maRefine.cc	/^long markEdgesToSplit(Adapt* a)$/;"	f	namespace:ma
markElement	apf/apfCavityOp.cc	/^static void markElement($/;"	f	namespace:apf
markElements	apf/apfCavityOp.cc	/^static void markElements($/;"	f	namespace:apf
markEntities	ma/maAdapt.cc	/^long markEntities($/;"	f	namespace:ma
markInvalidEntities	crv/crvAdapt.cc	/^int markInvalidEntities(Adapt* a)$/;"	f	namespace:crv
markIslandPyramids	ma/maTetrahedronize.cc	/^static long markIslandPyramids(Adapt* a)$/;"	f	namespace:ma
markIslandQuads	ma/maTetrahedronize.cc	/^static void markIslandQuads(Adapt* a)$/;"	f	namespace:ma
markIsolated	parma/diffMC/parma_dcpart.cc	/^void dcPart::markIsolated(const unsigned dcComp) {$/;"	f	class:dcPart
markLayerElements	ma/maLayer.cc	/^static long markLayerElements(Adapt* a)$/;"	f	namespace:ma
markNonIslandQuads	ma/maTetrahedronize.cc	/^static void markNonIslandQuads(Adapt* a)$/;"	f	namespace:ma
markVertices	parma/diffMC/parma_components.cc	/^  void DCC::markVertices() {$/;"	f	class:parma::DCC
markVertsToSnap	ma/maSnap.cc	/^static void markVertsToSnap(Adapt* a, Tag* t)$/;"	f	namespace:ma
markVertsToSnap	ma/maSnap_mohara.cc	/^static void markVertsToSnap(Adapt* a, Tag* t)$/;"	f	namespace:ma
mass	parma/rib/parma_rib.h	/^  double mass;$/;"	m	struct:parma::Body
mat	test/runSimxAnisoAdapt.cc	/^typedef vector<vec>    mat;$/;"	t	file:
match	ma/maMatchedCollapse.cc	/^void Rebuilds::match(apf::Sharing* sh)$/;"	f	class:ma::Rebuilds
match	ma/maShape.cc	/^    CodeMatch match;$/;"	m	class:ma::FixBySwap	file:
matchEntityToTemplate	ma/maRefine.cc	/^int matchEntityToTemplate(Adapt* a, Entity* e, Entity** vo)$/;"	f	namespace:ma
matchNewElements	ma/maMatch.cc	/^void matchNewElements(Refine* r)$/;"	f	namespace:ma
matchSliver	crv/crvShapeFixer.cc	/^ma::CodeMatch matchSliver($/;"	f	namespace:crv
matchSliver	ma/maShape.cc	/^CodeMatch matchSliver($/;"	f	namespace:ma
matchToTemplate	ma/maRefine.cc	/^int matchToTemplate(int type, Entity** vi, int code, Entity** vo)$/;"	f	namespace:ma
matches	mds/mds_apf.h	/^  struct mds_net matches;$/;"	m	struct:mds_apf	typeref:struct:mds_apf::mds_net
matplotlib	parma/extractParmaResults.py	/^import matplotlib.pyplot as plt$/;"	i
matrices_from_osh	omega_h/apfOmega_h.cc	/^static void matrices_from_osh($/;"	f	namespace:apf
matrices_to_osh	omega_h/apfOmega_h.cc	/^static void matrices_to_osh($/;"	f	namespace:apf
matrix_deriv	test/test_matrix_grad.cc	/^    apf::Vector<27> matrix_deriv;$/;"	m	class:MatrixDerivIntegrator	file:
matrix_deriv_elmt	test/test_matrix_grad.cc	/^    apf::Element * matrix_deriv_elmt;$/;"	m	class:MatrixDerivIntegrator	file:
matrix_deriv_fld	test/test_matrix_grad.cc	/^    apf::Field * matrix_deriv_fld;$/;"	m	class:CheckMatrixDerivIntegrator	file:
matrix_deriv_fld	test/test_matrix_grad.cc	/^    apf::Field * matrix_deriv_fld;$/;"	m	class:MatrixDerivIntegrator	file:
matrix_fld	test/test_matrix_grad.cc	/^    apf::Field * matrix_fld;$/;"	m	class:MatrixDerivIntegrator	file:
mattype	phasta/phOutput.h	/^  int** mattype;$/;"	m	struct:ph::EnsaArrays
mattypeb	phasta/phOutput.h	/^  int** mattypeb;$/;"	m	struct:ph::EnsaArrays
mattypeif0	phasta/phOutput.h	/^  int** mattypeif0;$/;"	m	struct:ph::EnsaArrays
mattypeif1	phasta/phOutput.h	/^  int** mattypeif1;$/;"	m	struct:ph::EnsaArrays
max	parma/diffMC/zeroOneKnapsack.c	/^size_t max(const size_t a, const size_t b) {$/;"	f
maxAdaptIterations	phasta/phInput.h	/^    int maxAdaptIterations;$/;"	m	class:ph::Input
maxAdaptiveIter	crv/crvQuality.cc	/^static int maxAdaptiveIter = 5;$/;"	m	namespace:crv	file:
maxComponent	phasta/phConstraint.cc	/^static int maxComponent(apf::Vector3 const& v)$/;"	f	namespace:ph
maxContactNeighbor	parma/diffMC/parma_dcpart.cc	/^unsigned dcPart::maxContactNeighbor(const unsigned dcComp) {$/;"	f	class:dcPart
maxEdge	parma/diffMC/parma_elmLtVtxEdgeBalancer.cc	/^      double maxEdge;$/;"	m	class:__anon66::ElmLtVtxEdge	file:
maxEdge	parma/diffMC/parma_elmLtVtxEdgeSelector.cc	/^      double maxEdge;$/;"	m	class:__anon64::ElmLtVtxEdgeSelector	file:
maxElevationLevel	crv/crvQuality.cc	/^static int maxElevationLevel = 19;$/;"	m	namespace:crv	file:
maxElmW	parma/diffMC/parma_ghost.cc	/^      double maxElmW;$/;"	m	class:__anon68::GhostVtxLtElmBalancer	file:
maxMigrationLimit	apf/apfMigrate.cc	/^const size_t maxMigrationLimit = 10*1000*1000;$/;"	m	namespace:apf	file:
maxStep	parma/diffMC/parma_balancer.h	/^      int maxStep;$/;"	m	class:parma::Balancer
maxVtx	parma/diffMC/parma_edgeEqVtxSelector.cc	/^      double maxVtx;$/;"	m	class:__anon52::EdgeEqVtx	file:
maxVtx	parma/diffMC/parma_elmLtVtxEdgeBalancer.cc	/^      double maxVtx;$/;"	m	class:__anon66::ElmLtVtxEdge	file:
maxVtx	parma/diffMC/parma_elmLtVtxEdgeSelector.cc	/^      double maxVtx;$/;"	m	class:__anon64::ElmLtVtxEdgeSelector	file:
maxVtx	parma/diffMC/parma_vtxEdgeElmBalancer.cc	/^      double maxVtx;$/;"	m	class:__anon46::VtxEdgeBalancer	file:
maxVtx	parma/diffMC/parma_vtxElmBalancer.cc	/^      double maxVtx;$/;"	m	class:__anon71::ElmLtVtx	file:
maxWeight	parma/diffMC/zeroOneKnapsack.c	/^    size_t maxWeight;$/;"	m	struct:zeroOneKnapsack	file:
maximumEdgeRatio	ma/maInput.h	/^    double maximumEdgeRatio;$/;"	m	class:ma::Input
maximumImbalance	ma/maInput.h	/^    double maximumImbalance;$/;"	m	class:ma::Input
maximumIterations	ma/maInput.h	/^    int maximumIterations;$/;"	m	class:ma::Input
md	crv/crvShape.cc	/^  int md;$/;"	m	class:crv::EdgeReshaper	file:
md	crv/crvShape.cc	/^  int md;$/;"	m	class:crv::EdgeSwapper	file:
mds	mds/mds.h	/^struct mds {$/;"	s
mds	mds/mds_apf.h	/^  struct mds mds;$/;"	m	struct:mds_apf	typeref:struct:mds_apf::mds
mds2apf	mds/apfMDS.cc	/^static Mesh::Type mds2apf(int t_mds)$/;"	f	namespace:apf
mds2smb	mds/mds_smb.c	/^static int mds2smb(int mds_type)$/;"	f	file:
mds_add_adjacency	mds/mds.c	/^void mds_add_adjacency(struct mds* m, int from_dim, int to_dim)$/;"	f
mds_add_copy	mds/mds_net.c	/^void mds_add_copy(struct mds_net* net, struct mds* m, mds_id e,$/;"	f
mds_align_ghosts	mds/mds_apf.c	/^int mds_align_ghosts(struct mds_apf* m)$/;"	f
mds_align_matches	mds/mds_apf.c	/^int mds_align_matches(struct mds_apf* m)$/;"	f
mds_align_remotes	mds/mds_apf.c	/^int mds_align_remotes(struct mds_apf* m)$/;"	f
mds_apf	mds/mds_apf.h	/^struct mds_apf {$/;"	s
mds_apf_create	mds/mds_apf.c	/^struct mds_apf* mds_apf_create(struct gmi_model* model, int d,$/;"	f
mds_apf_create_entity	mds/mds_apf.c	/^mds_id mds_apf_create_entity($/;"	f
mds_apf_destroy	mds/mds_apf.c	/^void mds_apf_destroy(struct mds_apf* m)$/;"	f
mds_apf_destroy_entity	mds/mds_apf.c	/^void mds_apf_destroy_entity(struct mds_apf* m, mds_id e)$/;"	f
mds_apf_double	mds/apfMDS.cc	/^int const mds_apf_double = apf::Mesh::DOUBLE;$/;"	v
mds_apf_int	mds/apfMDS.cc	/^int const mds_apf_int = apf::Mesh::INT;$/;"	v
mds_apf_long	mds/apfMDS.cc	/^int const mds_apf_long = apf::Mesh::LONG;$/;"	v
mds_apf_model	mds/mds_apf.c	/^struct gmi_ent* mds_apf_model(struct mds_apf* m, mds_id e)$/;"	f
mds_apf_param	mds/mds_apf.c	/^double* mds_apf_param(struct mds_apf* m, mds_id e)$/;"	f
mds_apf_point	mds/mds_apf.c	/^double* mds_apf_point(struct mds_apf* m, mds_id e)$/;"	f
mds_apf_set_model	mds/mds_apf.c	/^void mds_apf_set_model(struct mds_apf* m, mds_id e, struct gmi_ent* model)$/;"	f
mds_begin	mds/mds.c	/^mds_id mds_begin(struct mds* m, int d)$/;"	f
mds_change_dimension	mds/mds.c	/^void mds_change_dimension(struct mds* m, int d)$/;"	f
mds_copies	mds/mds_net.h	/^struct mds_copies {$/;"	s
mds_copy	mds/mds_net.h	/^struct mds_copy {$/;"	s
mds_create	mds/mds.c	/^void mds_create(struct mds* m, int d, mds_id cap[MDS_TYPES])$/;"	f
mds_create_entity	mds/mds.c	/^mds_id mds_create_entity(struct mds* m, int t, mds_id* from)$/;"	f
mds_create_net	mds/mds_net.c	/^void mds_create_net(struct mds_net* net)$/;"	f
mds_create_tag	mds/mds_tag.c	/^struct mds_tag* mds_create_tag($/;"	f
mds_create_tags	mds/mds_tag.c	/^void mds_create_tags(struct mds_tags* ts)$/;"	f
mds_degree	mds/mds.c	/^int const mds_degree[MDS_TYPES][4] =$/;"	v
mds_derive_model	mds/mds_apf.c	/^void mds_derive_model(struct mds_apf* m)$/;"	f
mds_destroy	mds/mds.c	/^void mds_destroy(struct mds* m)$/;"	f
mds_destroy_entity	mds/mds.c	/^void mds_destroy_entity(struct mds* m, mds_id e)$/;"	f
mds_destroy_net	mds/mds_net.c	/^void mds_destroy_net(struct mds_net* net, struct mds* m)$/;"	f
mds_destroy_tag	mds/mds_tag.c	/^void mds_destroy_tag(struct mds_tags* ts, struct mds_tag* t)$/;"	f
mds_destroy_tags	mds/mds_tag.c	/^void mds_destroy_tags(struct mds_tags* ts)$/;"	f
mds_dim	mds/mds.c	/^int const mds_dim[MDS_TYPES] =$/;"	v
mds_find_model	mds/mds_apf.c	/^struct gmi_ent* mds_find_model(struct mds_apf* m, int dim, int id)$/;"	f
mds_find_tag	mds/mds_tag.c	/^struct mds_tag* mds_find_tag(struct mds_tags* ts, const char* name)$/;"	f
mds_free_links	mds/mds_net.c	/^void mds_free_links(struct mds_links* ln)$/;"	f
mds_free_local_links	mds/mds_net.c	/^void mds_free_local_links(struct mds_links* ln)$/;"	f
mds_get_adjacent	mds/mds.c	/^void mds_get_adjacent(struct mds* m, mds_id e, int d, struct mds_set* s)$/;"	f
mds_get_copies	mds/mds_net.c	/^struct mds_copies* mds_get_copies(struct mds_net* net, mds_id e)$/;"	f
mds_get_local_matches	mds/mds_net.c	/^void mds_get_local_matches(struct mds_net* net, struct mds* m,$/;"	f
mds_get_part	mds/mds_apf.c	/^void* mds_get_part(struct mds_apf* m, mds_id e)$/;"	f
mds_get_tag	mds/mds_tag.c	/^void* mds_get_tag(struct mds_tag* tag, mds_id e)$/;"	f
mds_get_type_links	mds/mds_net.c	/^void mds_get_type_links(struct mds_net* net, struct mds* m,$/;"	f
mds_give_tag	mds/mds_tag.c	/^void mds_give_tag(struct mds_tag* tag, struct mds* m, mds_id e)$/;"	f
mds_grow_net	mds/mds_net.c	/^void mds_grow_net($/;"	f
mds_grow_tags	mds/mds_tag.c	/^void mds_grow_tags($/;"	f
mds_hack_adjacent	mds/mds.c	/^void mds_hack_adjacent(struct mds* m, mds_id up, int i, mds_id down)$/;"	f
mds_has_tag	mds/mds_tag.c	/^int mds_has_tag(struct mds_tag* tag, mds_id e)$/;"	f
mds_has_up	mds/mds.c	/^int mds_has_up(struct mds* m, mds_id e)$/;"	f
mds_id	mds/mds.h	/^typedef MDS_ID_TYPE mds_id;$/;"	t
mds_identify	mds/mds.c	/^mds_id mds_identify(int type, mds_id idx)$/;"	f
mds_index	mds/mds.c	/^mds_id mds_index(mds_id e)$/;"	f
mds_links	mds/mds_net.h	/^struct mds_links {$/;"	s
mds_make_copies	mds/mds_net.c	/^struct mds_copies* mds_make_copies(int n)$/;"	f
mds_model_dim	mds/mds_apf.c	/^int mds_model_dim(struct mds_apf* m, struct gmi_ent* model)$/;"	f
mds_model_id	mds/mds_apf.c	/^int mds_model_id(struct mds_apf* m, struct gmi_ent* model)$/;"	f
mds_net	mds/mds_net.h	/^struct mds_net {$/;"	s
mds_net_empty	mds/mds_net.c	/^int mds_net_empty(struct mds_net* net)$/;"	f
mds_next	mds/mds.c	/^mds_id mds_next(struct mds* m, mds_id e)$/;"	f
mds_number_verts_bfs	mds/mds_order.c	/^struct mds_tag* mds_number_verts_bfs(struct mds_apf* m)$/;"	f
mds_read_smb	mds/mds_smb.c	/^struct mds_apf* mds_read_smb(struct gmi_model* model, const char* pathname,$/;"	f
mds_read_smb_meta	mds/apfMDS.cc	/^void mds_read_smb_meta(struct pcu_file* file, struct mds_apf* mesh,$/;"	f
mds_realloc	mds/mds.c	/^static void* mds_realloc(void* p, size_t n)$/;"	f	file:
mds_remove_adjacency	mds/mds.c	/^void mds_remove_adjacency(struct mds* m, int from_dim, int to_dim)$/;"	f
mds_rename_tag	mds/mds_tag.c	/^void mds_rename_tag(struct mds_tag* tag, const char* newName)$/;"	f
mds_reorder	mds/mds_order.c	/^struct mds_apf* mds_reorder(struct mds_apf* m, int ignore_peers,$/;"	f
mds_set	mds/mds.h	/^struct mds_set {$/;"	s
mds_set_copies	mds/mds_net.c	/^void mds_set_copies(struct mds_net* net, struct mds* m, mds_id e,$/;"	f
mds_set_local_matches	mds/mds_net.c	/^void mds_set_local_matches(struct mds_net* net, struct mds* m,$/;"	f
mds_set_part	mds/mds_apf.c	/^void mds_set_part(struct mds_apf* m, mds_id e, void* p)$/;"	f
mds_set_type_links	mds/mds_net.c	/^void mds_set_type_links(struct mds_net* net, struct mds* m,$/;"	f
mds_swap_tag_structs	mds/mds_tag.c	/^void mds_swap_tag_structs(struct mds_tags* as, struct mds_tag** a,$/;"	f
mds_tag	mds/mds_tag.h	/^struct mds_tag {$/;"	s
mds_tags	mds/mds_tag.h	/^struct mds_tags {$/;"	s
mds_take_tag	mds/mds_tag.c	/^void mds_take_tag(struct mds_tag* tag, mds_id e)$/;"	f
mds_type	mds/mds.c	/^int mds_type(mds_id e)$/;"	f
mds_types	mds/mds.c	/^int const* mds_types[MDS_TYPES][4] =$/;"	v
mds_update_model_for_entity	mds/mds_apf.c	/^void mds_update_model_for_entity(struct mds_apf* m, mds_id e,$/;"	f
mds_write_smb	mds/mds_smb.c	/^struct mds_apf* mds_write_smb(struct mds_apf* m, const char* pathname,$/;"	f
mds_write_smb_meta	mds/apfMDS.cc	/^void mds_write_smb_meta(struct pcu_file* file, void* mesh_cpp) {$/;"	f
measure	apf/apfIntegrate.cc	/^double measure(Mesh* m, MeshEntity* e)$/;"	f	namespace:apf
measure	apf/apfIntegrate.cc	/^double measure(MeshElement* e)$/;"	f	namespace:apf
measure	ma/maSize.cc	/^  double measure(Entity* e)$/;"	f	struct:ma::MetricSizeField
measure	ma/maSize.cc	/^double IdentitySizeField::measure(Entity* e)$/;"	f	class:ma::IdentitySizeField
measureBezierTetQuality	ma/maQuality.cc	/^double measureBezierTetQuality(Vector xyz[10])$/;"	f	namespace:ma
measureElementQuality	ma/maQuality.cc	/^double measureElementQuality(Mesh* m, SizeField* f, Entity* e, bool useMax)$/;"	f	namespace:ma
measureGraphDist	parma/diffMC/parma_graphDist.cc	/^  apf::MeshTag* measureGraphDist(apf::Mesh* m) {$/;"	f	namespace:parma
measureLinearTetQuality	ma/maQuality.cc	/^double measureLinearTetQuality(Vector xyz[4])$/;"	f	namespace:ma
measureLinearTriArea	crv/crvShapeHandler.cc	/^static double measureLinearTriArea(ma::Mesh* m, ma::Entity* tri)$/;"	f	namespace:crv
measureMesh	test/bezierRefine.cc	/^static double measureMesh(apf::Mesh2* m)$/;"	f	file:
measureQuadraticTetQuality	ma/maQuality.cc	/^double measureQuadraticTetQuality(Mesh* m, Entity* tet)$/;"	f	namespace:ma
measureQuadraticTetQuality	ma/maQuality.cc	/^double measureQuadraticTetQuality(Vector xyz[10])$/;"	f	namespace:ma
measureTetQuality	ma/maQuality.cc	/^double measureTetQuality(Mesh* m, SizeField* f, Entity* tet, bool useMax)$/;"	f	namespace:ma
measureTriQuality	ma/maQuality.cc	/^double measureTriQuality(Mesh* m, SizeField* f, Entity* tri, bool useMax)$/;"	f	namespace:ma
measurement	ma/maQuality.cc	/^    double measurement;$/;"	m	class:ma::FixedMetricIntegrator	file:
measurement	ma/maSize.cc	/^    double measurement;$/;"	m	class:ma::SizeFieldIntegrator	file:
merge	pcu/pcu_coll.h	/^  pcu_merge* merge; \/\/merge operation$/;"	m	struct:__anon40
mergeSolutionFields	test/icesheet.cc	/^void mergeSolutionFields(apf::Mesh2* mesh) {$/;"	f
merge_comm	pumi/pumi_mesh.cc	/^void merge_comm(MPI_Comm oldComm)$/;"	f
mersenne_twister	parma/diffMC/maximalIndependentSet/mersenne_twister.cc	/^unsigned mersenne_twister(void)$/;"	f
mersenne_twister_seed	parma/diffMC/maximalIndependentSet/mersenne_twister.cc	/^void mersenne_twister_seed(unsigned seed)$/;"	f
mesh	apf/apfCavityOp.h	/^    Mesh* mesh;$/;"	m	class:apf::CavityOp
mesh	apf/apfCoordData.h	/^    Mesh* mesh;$/;"	m	class:apf::CoordData
mesh	apf/apfElement.h	/^    Mesh* mesh;$/;"	m	class:apf::Element
mesh	apf/apfField.h	/^    Mesh* mesh;$/;"	m	class:apf::FieldBase
mesh	apf/apfFieldOf.cc	/^    Mesh* mesh;$/;"	m	class:apf::Project	file:
mesh	apf/apfGradientByVolume.cc	/^    Mesh* mesh;$/;"	m	class:apf::RecoverGradient	file:
mesh	apf/apfHierarchic.cc	/^    Mesh* mesh;$/;"	m	class:apf::Projector	file:
mesh	apf/apfMesh.cc	/^    Mesh* mesh;$/;"	m	class:apf::ElementFinder	file:
mesh	apf/apfMesh.h	/^    Mesh* mesh;$/;"	m	class:apf::Migration
mesh	apf/apfMesh.h	/^  Mesh* mesh;$/;"	m	struct:apf::MatchedSharing
mesh	apf/apfMesh.h	/^  Mesh* mesh;$/;"	m	struct:apf::NormalSharing
mesh	apf/apfMesh2.cc	/^    Mesh2* mesh;$/;"	m	class:apf::ElementBuilder	file:
mesh	apf/apfTagData.h	/^    Mesh* mesh;$/;"	m	class:apf::TagData
mesh	apf/apfTagData.h	/^    Mesh* mesh;$/;"	m	class:apf::TagDataOf
mesh	apf_cap/apfCAP.cc	/^    MeshDatabaseInterface* mesh;$/;"	m	class:apf::TagCAP	file:
mesh	apf_sim/apfSIM.cc	/^    pParMesh mesh;$/;"	m	class:apf::TagSIM	file:
mesh	apf_sim/apfSIM.h	/^    pParMesh mesh;$/;"	m	class:apf::MeshSIM
mesh	apf_sim/apfSIMDataOf.h	/^  Mesh * mesh;$/;"	m	class:apf::SIMDataOf
mesh	crv/crv.h	/^  apf::Mesh* mesh;$/;"	m	class:crv::Quality
mesh	crv/crvShape.cc	/^  ma::Mesh* mesh;$/;"	m	class:crv::EdgeReshaper	file:
mesh	crv/crvShape.cc	/^  ma::Mesh* mesh;$/;"	m	class:crv::EdgeSwapper	file:
mesh	crv/crvShapeFixer.h	/^    apf::Mesh2* mesh;$/;"	m	class:crv::CrvEdgeEdgeFixer
mesh	crv/crvShapeFixer.h	/^    apf::Mesh2* mesh;$/;"	m	class:crv::CrvFaceVertFixer
mesh	crv/crvShapeFixer.h	/^    apf::Mesh2* mesh;$/;"	m	class:crv::CrvLargeAngleTetFixer
mesh	crv/crvShapeFixer.h	/^    apf::Mesh2* mesh;$/;"	m	class:crv::CrvLargeAngleTriFixer
mesh	crv/crvShapeFixer.h	/^    apf::Mesh2* mesh;$/;"	m	class:crv::CrvShortEdgeFixer
mesh	crv/crvShapeHandler.cc	/^    ma::Mesh* mesh;$/;"	m	class:crv::BezierHandler	file:
mesh	crv/crvShapeHandler.cc	/^    ma::Mesh* mesh;$/;"	m	class:crv::BezierTransfer	file:
mesh	ma/maAdapt.h	/^    Mesh* mesh;$/;"	m	class:ma::Adapt
mesh	ma/maAdapt.h	/^  Mesh* mesh;$/;"	m	struct:ma::HasTag
mesh	ma/maCrawler.h	/^  Mesh* mesh;$/;"	m	struct:ma::Crawler
mesh	ma/maEdgeSwap.cc	/^    Mesh* mesh;$/;"	m	class:ma::EdgeSwap2D	file:
mesh	ma/maEdgeSwap.cc	/^    Mesh* mesh;$/;"	m	class:ma::EdgeSwap3D	file:
mesh	ma/maEdgeSwap.cc	/^    Mesh* mesh;$/;"	m	class:ma::SwapCavity	file:
mesh	ma/maEdgeSwap.cc	/^    Mesh* mesh;$/;"	m	class:ma::SwapLoop	file:
mesh	ma/maExtrude.cc	/^  Mesh* mesh;$/;"	m	class:ma::__anon28::DebugBuildCallback	file:
mesh	ma/maExtrude.cc	/^  Mesh* mesh;$/;"	m	struct:ma::__anon28::ZDataSetter	file:
mesh	ma/maExtrude.cc	/^  apf::Mesh* mesh;$/;"	m	struct:ma::__anon28::ZDataGetter	file:
mesh	ma/maInput.h	/^    Mesh* mesh;$/;"	m	class:ma::Input
mesh	ma/maMatchedCollapse.h	/^  Mesh* mesh;$/;"	m	struct:ma::MatchedCollapse
mesh	ma/maMatchedCollapse.h	/^  Mesh* mesh;$/;"	m	struct:ma::Rebuilds
mesh	ma/maQuality.cc	/^    Mesh* mesh;$/;"	m	class:ma::FixedMetricIntegrator	file:
mesh	ma/maShape.cc	/^    Mesh* mesh;$/;"	m	class:ma::EdgeEdgeFixer	file:
mesh	ma/maShape.cc	/^    Mesh* mesh;$/;"	m	class:ma::FaceVertFixer	file:
mesh	ma/maShape.cc	/^    Mesh* mesh;$/;"	m	class:ma::FixBySwap	file:
mesh	ma/maShape.cc	/^    Mesh* mesh;$/;"	m	class:ma::LargeAngleTetAligner	file:
mesh	ma/maShape.cc	/^    Mesh* mesh;$/;"	m	class:ma::LargeAngleTetFixer	file:
mesh	ma/maShape.cc	/^    Mesh* mesh;$/;"	m	class:ma::LargeAngleTriFixer	file:
mesh	ma/maShape.cc	/^    Mesh* mesh;$/;"	m	class:ma::QualityImprover2D	file:
mesh	ma/maShape.cc	/^    Mesh* mesh;$/;"	m	class:ma::ShortEdgeFixer	file:
mesh	ma/maShapeHandler.cc	/^    Mesh* mesh;$/;"	m	class:ma::LinearHandler	file:
mesh	ma/maShapeHandler.cc	/^    Mesh* mesh;$/;"	m	class:ma::QuadraticHandler	file:
mesh	ma/maShortEdgeRemover.h	/^    Mesh* mesh;$/;"	m	class:ma::ShortEdgeRemover
mesh	ma/maSize.cc	/^  Mesh* mesh;$/;"	m	struct:ma::MetricSizeField	file:
mesh	ma/maSize.h	/^  Mesh* mesh;$/;"	m	struct:ma::IdentitySizeField
mesh	ma/maSolutionTransfer.cc	/^    apf::Mesh* mesh;$/;"	m	class:ma::FieldTransfer	file:
mesh	ma/maVertRemover.h	/^    Mesh* mesh;$/;"	m	class:ma::VertRemover
mesh	mds/apfMDS.cc	/^    mds_apf* mesh;$/;"	m	class:apf::MeshMDS	file:
mesh	mds/mdsGmsh.cc	/^  apf::Mesh2* mesh;$/;"	m	struct:__anon96::Reader	file:
mesh	mds/mdsUgrid.cc	/^    apf::Mesh2* mesh;$/;"	m	struct:__anon101::Reader	file:
mesh	parma/diffMC/parma_balancer.h	/^      apf::Mesh* mesh;$/;"	m	class:parma::Balancer
mesh	parma/diffMC/parma_ghostMPASWeights.cc	/^      apf::Mesh* mesh;$/;"	m	class:parma::GhostElementFinder	file:
mesh	parma/diffMC/parma_ghostWeights.cc	/^      apf::Mesh* mesh;$/;"	m	class:parma::ElmGhostFinder	file:
mesh	parma/diffMC/parma_ghostWeights.cc	/^      apf::Mesh* mesh;$/;"	m	class:parma::VtxGhostFinder	file:
mesh	parma/diffMC/parma_selector.h	/^      apf::Mesh* mesh;$/;"	m	class:parma::Selector
mesh	parma/group/parma_group.cc	/^  apf::Mesh* mesh;$/;"	m	struct:RetreatCode	file:
mesh	parma/rib/parma_mesh_rib.cc	/^    apf::Mesh* mesh;$/;"	m	class:parma::RibSplitter	file:
mesh	phasta/condense.cc	/^    apf::Mesh2* mesh;$/;"	m	struct:__anon85::GroupCode	file:
mesh	phasta/phAdapt.cc	/^  apf::Mesh2* mesh;$/;"	m	struct:ph::AdaptCallback	file:
mesh	phasta/phLinks.cc	/^  apf::Mesh* mesh;$/;"	m	struct:ph::PhastaSharing	file:
mesh	phasta/phOutput.h	/^  apf::Mesh* mesh;$/;"	m	struct:ph::Output
mesh	pumi/pumi.h	/^  pMesh mesh;$/;"	m	class:pumi
mesh	spr/sprEstimateError.cc	/^  apf::Mesh* mesh;$/;"	m	struct:spr::Estimation	file:
mesh	spr/sprEstimateTargetError.cc	/^  apf::Mesh* mesh;$/;"	m	struct:spr::target::Estimation	file:
mesh	spr/sprRecoverField.cc	/^  apf::Mesh* mesh;$/;"	m	struct:spr::Patch	file:
mesh	spr/sprRecoverField.cc	/^  apf::Mesh* mesh;$/;"	m	struct:spr::Recovery	file:
mesh	test/aniso_ma_test.cc	/^    ma::Mesh* mesh;$/;"	m	class:AnIso	file:
mesh	test/capStoneAnisoAdaptWing.cc	/^    ma::Mesh* mesh;$/;"	m	class:WingShock	file:
mesh	test/capStoneIsoAdaptB737.cc	/^    ma::Mesh* mesh;$/;"	m	class:B737	file:
mesh	test/capStoneSizeFields.h	/^    ma::Mesh* mesh;$/;"	m	class:GeomB737
mesh	test/capStoneSizeFields.h	/^    ma::Mesh* mesh;$/;"	m	class:GeomRobin
mesh	test/capStoneSizeFields.h	/^    ma::Mesh* mesh;$/;"	m	class:Linear1
mesh	test/capStoneSizeFields.h	/^    ma::Mesh* mesh;$/;"	m	class:Linear2
mesh	test/capStoneSizeFields.h	/^    ma::Mesh* mesh;$/;"	m	class:Linear3
mesh	test/capStoneSizeFields.h	/^    ma::Mesh* mesh;$/;"	m	class:Shock
mesh	test/capStoneSizeFields.h	/^    ma::Mesh* mesh;$/;"	m	class:Uniform
mesh	test/capStoneSizeFields.h	/^    ma::Mesh* mesh;$/;"	m	class:UniformAniso
mesh	test/capStoneSizeFields.h	/^    ma::Mesh* mesh;$/;"	m	class:WingShock
mesh	test/collapse.cc	/^    apf::Mesh2* mesh;$/;"	m	struct:__anon6::GroupCode	file:
mesh	test/curvetest.cc	/^    ma::Mesh* mesh;$/;"	m	class:Linear	file:
mesh	test/dg_ma_test.cc	/^    ma::Mesh* mesh;$/;"	m	class:Linear	file:
mesh	test/fusion.cc	/^    ma::Mesh* mesh;$/;"	m	class:Vortex	file:
mesh	test/fusion.cc	/^  apf::Mesh2* mesh;$/;"	m	struct:GroupCode	file:
mesh	test/fusion2.cc	/^  apf::Mesh2* mesh;$/;"	m	struct:GroupCode	file:
mesh	test/fusion3.cc	/^    ma::Mesh* mesh;$/;"	m	class:Vortex	file:
mesh	test/hierarchic.cc	/^    apf::Mesh* mesh;$/;"	m	class:__anon20::L2Projector	file:
mesh	test/ma_test.cc	/^    ma::Mesh* mesh;$/;"	m	class:Linear	file:
mesh	test/poisson.cc	/^    apf::Mesh2* mesh;$/;"	m	class:__anon17::Poisson	file:
mesh	test/serialize.cc	/^  apf::Mesh2* mesh;$/;"	m	struct:GroupCode	file:
mesh	test/torus_ma_test.cc	/^    ma::Mesh* mesh;$/;"	m	class:CylindricalShock	file:
mesh	zoltan/apfZoltanMesh.h	/^    Mesh* mesh;$/;"	m	class:apf::ZoltanMesh
mesh2geom	phasta/phInput.h	/^    int mesh2geom;$/;"	m	class:ph::Input
meshElem	apf/apfHierarchic.cc	/^    VectorElement* meshElem;$/;"	m	class:apf::Projector	file:
meshElement	apf/apfFieldOf.cc	/^    VectorElement* meshElement;$/;"	m	class:apf::Project	file:
meshElement	ma/maSize.cc	/^    apf::MeshElement* meshElement;$/;"	m	class:ma::SizeFieldIntegrator	file:
meshFile	test/box.cc	/^const char* meshFile = 0;$/;"	m	namespace:__anon8	file:
meshFile	test/collapse.cc	/^  const char* meshFile = 0;$/;"	m	namespace:__anon6	file:
meshFile	test/degenerateSurfs.cc	/^const char* meshFile = 0;$/;"	v
meshFile	test/fieldReduce.cc	/^const char* meshFile = 0;$/;"	m	namespace:__anon15	file:
meshFile	test/fusion.cc	/^  const char* meshFile;$/;"	m	struct:GroupCode	file:
meshFile	test/ghost.cc	/^  const char* meshFile = 0;$/;"	m	namespace:__anon11	file:
meshFile	test/ghostEdge.cc	/^  const char* meshFile = 0;$/;"	m	namespace:__anon12	file:
meshFile	test/ghostMPAS.cc	/^  const char* meshFile = 0;$/;"	m	namespace:__anon9	file:
meshFile	test/ptnParma.cc	/^const char* meshFile = 0;$/;"	m	namespace:__anon10	file:
meshFile	test/pumi.cc	/^const char* meshFile = 0;$/;"	v
meshFile	test/quality.cc	/^const char* meshFile = 0;$/;"	m	namespace:__anon21	file:
meshFile	test/repartition.cc	/^const char* meshFile = 0;$/;"	m	namespace:__anon22	file:
meshFile	test/serialize.cc	/^  const char* meshFile;$/;"	m	struct:GroupCode	file:
meshFile	test/split.cc	/^const char* meshFile = 0;$/;"	m	namespace:__anon13	file:
meshFile	test/uniform.cc	/^const char* meshFile = 0;$/;"	v
meshFile	test/viz.cc	/^  const char* meshFile = 0;$/;"	m	namespace:__anon2	file:
meshFile	test/writeVtxPtn.cc	/^  const char* meshFile = 0;$/;"	m	namespace:__anon1	file:
meshFile	test/xgc_split.cc	/^const char* meshFile = 0;$/;"	v
meshFile	test/zsplit.cc	/^const char* meshFile = 0;$/;"	m	namespace:__anon4	file:
meshFileName	phasta/phInput.h	/^    std::string meshFileName;$/;"	m	class:ph::Input
meshFilename	test/simDiscrete.cc	/^const char* meshFilename;$/;"	v
meshFilename	test/sim_countBL.cc	/^const char* meshFilename;$/;"	v
meshFilename	test/sim_part.cc	/^const char* meshFilename;$/;"	v
meshInterface	apf_cap/apfCAP.h	/^    MeshDatabaseInterface* meshInterface;$/;"	m	class:apf::MeshCAP
mesh_elmt	test/test_matrix_grad.cc	/^    apf::MeshElement * mesh_elmt;$/;"	m	class:CheckMatrixDerivIntegrator	file:
mesh_elmt	test/test_matrix_grad.cc	/^    apf::MeshElement * mesh_elmt;$/;"	m	class:MatrixDerivIntegrator	file:
mesh_has_ext	phasta/ph.cc	/^bool mesh_has_ext(const char* filename, const char* ext)$/;"	f	namespace:ph
meshfile	phasta/cut_interface.cc	/^char const* meshfile;$/;"	v
meshqCrtn	phasta/phInput.h	/^    double meshqCrtn;$/;"	m	class:ph::Input
message	pcu/pcu_coll.h	/^  pcu_message message; \/\/local data being operated on$/;"	m	struct:__anon40
message	pcu/pcu_msg.h	/^  pcu_message message; \/\/send buffer and peer id$/;"	m	struct:__anon35
message	pcu/pcu_order.c	/^struct message {$/;"	s	file:
messageHandler	test/generate.cc	/^void messageHandler(int type, const char* msg)$/;"	f	namespace:__anon19
messageHandler	test/simDiscrete.cc	/^void messageHandler(int type, const char *msg)$/;"	f
messageHandler	test/simTranslate.cc	/^void messageHandler(int type, const char *msg)$/;"	f
messageHandler	test/sim_countBL.cc	/^void messageHandler(int type, const char *msg)$/;"	f
messageHandler	test/sim_part.cc	/^void messageHandler(int type, const char *msg)$/;"	f
message_less	pcu/pcu_order.c	/^static bool message_less(pcu_aa_node* a, pcu_aa_node* b)$/;"	f	file:
method	test/ptnParma.cc	/^const char* method = 0;$/;"	m	namespace:__anon10	file:
method	zoltan/apfZoltanMesh.h	/^    int method;$/;"	m	class:apf::ZoltanMesh
metric	parma/extractParmaResults.py	/^class metric():$/;"	c
metrics	parma/extractParmaResults.py	/^metrics = []$/;"	v
meu	parma/diffMC/parma_vtxSelector.cc	/^  typedef std::map<apf::MeshEntity*,unsigned> meu;$/;"	t	namespace:__anon59	file:
mgrid	mds/apfBox.h	/^  Grid mgrid;$/;"	m	struct:apf::BoxBuilder
midAdaptBalanceMethod	phasta/phInput.h	/^    std::string midAdaptBalanceMethod;$/;"	m	class:ph::Input
midBalance	ma/maBalance.cc	/^void midBalance(Adapt* a)$/;"	f	namespace:ma
middle	ma/maExtrude.h	/^  Model* middle;$/;"	m	struct:ma::ModelExtrusion
migrate	apf/apfMigrate.cc	/^void migrate(Mesh2* m, Migration* plan)$/;"	f	namespace:apf
migrate	apf_cap/apfCAP.cc	/^void MeshCAP::migrate(Migration* plan)$/;"	f	class:apf::MeshCAP
migrate	apf_sim/apfSIM.cc	/^void MeshSIM::migrate(Migration* plan)$/;"	f	class:apf::MeshSIM
migrate	mds/apfMDS.cc	/^    void migrate(Migration* plan)$/;"	f	class:apf::MeshMDS
migrate1	apf/apfMigrate.cc	/^static void migrate1(Mesh2* m, Migration* plan)$/;"	f	namespace:apf
migrate2	apf/apfMigrate.cc	/^static void migrate2(Mesh2* m, Migration* plan)$/;"	f	namespace:apf
migrateForLayerCollapse	ma/maLayerCoarsen.cc	/^static void migrateForLayerCollapse(Adapt* a, int d, int round)$/;"	f	namespace:ma
migrateInterface	phasta/phInterfaceCutter.cc	/^int migrateInterface(apf::Mesh2*& m, ph::BCs& bcs) {$/;"	f	namespace:ph
migrateInterfaceItr	phasta/phInterfaceCutter.cc	/^bool migrateInterfaceItr(apf::Mesh2*& m, ph::BCs& bcs) {$/;"	f	namespace:ph
migrateSilent	apf/apfMigrate.cc	/^void migrateSilent(Mesh2* m, Migration* plan)$/;"	f	namespace:apf
migrationLimit	apf/apfMigrate.cc	/^static size_t migrationLimit = maxMigrationLimit;$/;"	m	namespace:apf	file:
mii	parma/parma.cc	/^  typedef std::map<int,int> mii;$/;"	t	namespace:__anon75	file:
minAcceptable	crv/crvQuality.cc	/^static double minAcceptable = 0.0;$/;"	m	namespace:crv	file:
minDim	ma/maSolutionTransfer.cc	/^    int minDim;$/;"	m	class:ma::CavityTransfer	file:
minQuality	test/quality.cc	/^double minQuality = 1.0;$/;"	m	namespace:__anon21	file:
minRandNum	parma/diffMC/maximalIndependentSet/misLuby.cc	/^  int minRandNum(mapiuItr first, mapiuItr last) {$/;"	f	namespace:__anon50
min_cavity_quality	ma/maReposition.cc	/^static AD min_cavity_quality(Mesh* m, apf::Adjacent& tets, Entity* v)$/;"	f	namespace:ma
mis	parma/diffMC/maximalIndependentSet/misLuby.cc	/^int mis(partInfo& part, bool randNumsPredefined,bool isNeighbors) {$/;"	f
misColor	test/viz.cc	/^  Color misColor(apf::Mesh* m) {$/;"	f	namespace:__anon2
misFinalize	parma/diffMC/maximalIndependentSet/misLuby.cc	/^void misFinalize() {}$/;"	f
misLuby	parma/diffMC/maximalIndependentSet/mis.h	/^namespace misLuby {$/;"	n
mis_init	parma/diffMC/maximalIndependentSet/misLuby.cc	/^void mis_init(unsigned randNumSeed, int, const char*,$/;"	f
model	apf_cap/apfCAP.h	/^    gmi_model* model;$/;"	m	class:apf::MeshCAP
model	apf_sim/apfSIM.h	/^    gmi_model* model;$/;"	m	class:apf::MeshSIM
model	gmi/gmi_base.h	/^  struct gmi_model model;$/;"	m	struct:gmi_base	typeref:struct:gmi_base::gmi_model
model	gmi_cap/gmi_cap.cc	/^  struct gmi_model model;$/;"	m	struct:cap_model	typeref:struct:cap_model::gmi_model	file:
model	gmi_sim/gmi_sim.cc	/^  struct gmi_model model;$/;"	m	struct:sim_model	typeref:struct:sim_model::gmi_model	file:
model	ma/maEdgeSwap.cc	/^    Model* model;$/;"	m	class:ma::SwapLoop	file:
model	mds/mds_apf.h	/^  struct gmi_ent** model[MDS_TYPES];$/;"	m	struct:mds_apf	typeref:struct:mds_apf::gmi_ent
model	pumi/pumi.h	/^  pGeom model;  $/;"	m	class:pumi
model	test/fusion.cc	/^  gmi_model* model;$/;"	m	struct:GroupCode	file:
modelCounts	mds/apfBox.h	/^  int modelCounts[4];$/;"	m	struct:apf::BoxBuilder
modelDim	phasta/phConstraint.cc	/^  int modelDim;$/;"	m	struct:ph::DebugConstraint	file:
modelDimension	ma/maCoarsen.cc	/^    int modelDimension;$/;"	m	class:ma::AllEdgeCollapser	file:
modelDimension	ma/maCoarsen.cc	/^    int modelDimension;$/;"	m	class:ma::CollapseChecker	file:
modelDimension	ma/maCoarsen.cc	/^    int modelDimension;$/;"	m	class:ma::MatchedEdgeCollapser	file:
modelEntity	apf/apfMesh2.cc	/^    ModelEntity* modelEntity;$/;"	m	class:apf::ElementBuilder	file:
modelFile	phasta/migrate_interface.cc	/^  const char* modelFile = 0;$/;"	m	namespace:__anon78	file:
modelFile	test/box.cc	/^const char* modelFile = 0;$/;"	m	namespace:__anon8	file:
modelFile	test/collapse.cc	/^  const char* modelFile = 0;$/;"	m	namespace:__anon6	file:
modelFile	test/degenerateSurfs.cc	/^const char* modelFile = 0;$/;"	v
modelFile	test/fieldReduce.cc	/^const char* modelFile = 0;$/;"	m	namespace:__anon15	file:
modelFile	test/generate.cc	/^std::string modelFile;$/;"	m	namespace:__anon19	file:
modelFile	test/ghost.cc	/^  const char* modelFile = 0;$/;"	m	namespace:__anon11	file:
modelFile	test/ghostEdge.cc	/^  const char* modelFile = 0;$/;"	m	namespace:__anon12	file:
modelFile	test/ghostMPAS.cc	/^  const char* modelFile = 0;$/;"	m	namespace:__anon9	file:
modelFile	test/ptnParma.cc	/^const char* modelFile = 0;$/;"	m	namespace:__anon10	file:
modelFile	test/pumi.cc	/^const char* modelFile = 0;$/;"	v
modelFile	test/quality.cc	/^const char* modelFile = 0;$/;"	m	namespace:__anon21	file:
modelFile	test/repartition.cc	/^const char* modelFile = 0;$/;"	m	namespace:__anon22	file:
modelFile	test/split.cc	/^const char* modelFile = 0;$/;"	m	namespace:__anon13	file:
modelFile	test/uniform.cc	/^const char* modelFile = 0;$/;"	v
modelFile	test/viz.cc	/^  const char* modelFile = 0;$/;"	m	namespace:__anon2	file:
modelFile	test/writeVtxPtn.cc	/^  const char* modelFile = 0;$/;"	m	namespace:__anon1	file:
modelFile	test/xgc_split.cc	/^const char* modelFile = 0;$/;"	v
modelFile	test/zsplit.cc	/^const char* modelFile = 0;$/;"	m	namespace:__anon4	file:
modelFileName	phasta/phInput.h	/^    std::string modelFileName;$/;"	m	class:ph::Input
modelFilename	test/simDiscrete.cc	/^const char* modelFilename;$/;"	v
modelFilename	test/sim_countBL.cc	/^const char* modelFilename;$/;"	v
modelFilename	test/sim_part.cc	/^const char* modelFilename;$/;"	v
modelLen	test/fusion3.cc	/^    double modelLen;$/;"	m	class:Vortex	file:
modelLen	test/fusion3.cc	/^double modelLen=2.5;$/;"	v
modelTable	mds/apfBox.h	/^  struct { int dim; int tag; } modelTable[27];$/;"	m	struct:apf::BoxBuilder	typeref:struct:apf::BoxBuilder::__anon95
modelTag	phasta/phConstraint.cc	/^  int modelTag;$/;"	m	struct:ph::DebugConstraint	file:
modelfile	phasta/cut_interface.cc	/^char const* modelfile;$/;"	v
models	stk/apfAlbany.h	/^  Vector models[4];$/;"	m	struct:apf::StkModels
monitorUpdate	parma/diffMC/parma_balancer.cc	/^  void Balancer::monitorUpdate(double v, Slope* s, Average* a) {$/;"	f	class:parma::Balancer
moveEntities	apf/apfMigrate.cc	/^void moveEntities($/;"	f	namespace:apf
moved	ma/maSnapper.h	/^    bool moved;$/;"	m	class:ma::Snapper
movedByDeletion	apf/apfCavityOp.h	/^    bool movedByDeletion;$/;"	m	class:apf::CavityOp
mrm	mds/mds.h	/^  int mrm[4][4];$/;"	m	struct:mds
mt	parma/diffMC/maximalIndependentSet/mersenne_twister.cc	/^static unsigned long mt[N]; \/* the array for the state vector *\/$/;"	v	file:
mth	mth/mth.h	/^namespace mth {$/;"	n
mth	mth/mthAD.h	/^namespace mth {$/;"	n
mth	mth/mthMatrix.h	/^namespace mth {$/;"	n
mth	mth/mthQR.cc	/^namespace mth {$/;"	n	file:
mth	mth/mthQR.h	/^namespace mth {$/;"	n
mth	mth/mthTensor.h	/^namespace mth {$/;"	n
mth	mth/mthVector.h	/^namespace mth {$/;"	n
mth	mth/mth_def.h	/^namespace mth {$/;"	n
mti	parma/diffMC/maximalIndependentSet/mersenne_twister.cc	/^static int mti = N + 1; \/* mti == N + 1 means mt is not initialized *\/$/;"	v	file:
mult	apf/apfFieldData.cc	/^    T mult;$/;"	m	class:apf::MultiplyOp	file:
multiple	zoltan/apfZoltanMesh.h	/^    int multiple;$/;"	m	class:apf::ZoltanMesh
multiply	apf/apfDynamicMatrix.h	/^inline void multiply(DynamicMatrix const& a,$/;"	f	namespace:apf
multiply	apf/apfDynamicMatrix.h	/^inline void multiply(DynamicVector const& b,$/;"	f	namespace:apf
multiply	mth/mth_def.h	/^void multiply(Matrix<T,M,N> const& a, Vector<T,N> const& b,$/;"	f	namespace:mth
multiply	mth/mth_def.h	/^void multiply(Matrix<T,M,O> const& a, Matrix<T,O,N> const& b,$/;"	f	namespace:mth
multiplyFieldData	apf/apfFieldData.cc	/^void multiplyFieldData(FieldDataOf<T>* from, T d, FieldDataOf<T>* to)$/;"	f	namespace:apf
multiplySF	sam/sam.cc	/^void multiplySF(apf::Mesh* m, apf::Field* sf, double factor) {$/;"	f	namespace:sam
multiplySFBox	sam/sam.cc	/^void multiplySFBox(apf::Mesh* m, apf::Field* sf, double factor, double* box) {$/;"	f	namespace:sam
multiplySFCyl	sam/sam.cc	/^void multiplySFCyl(apf::Mesh* m, apf::Field* sf, double factor, double* cyl) {$/;"	f	namespace:sam
multiplySFRegion	sam/sam.cc	/^void multiplySFRegion(apf::Mesh* m, apf::Field* sf, double factor, int tag) {$/;"	f	namespace:sam
muu	parma/diffMC/parma_dcpart.cc	/^typedef std::map<unsigned, unsigned> muu;$/;"	t	file:
muu	parma/diffMC/parma_dcpartFixer.cc	/^typedef std::map<unsigned, unsigned> muu;$/;"	t	file:
muu	parma/diffMC/parma_shapeSelector.cc	/^typedef std::map<uint,uint> muu;$/;"	t	file:
muu	parma/diffMC/parma_vtxSelector.cc	/^typedef std::map<uint,uint> muu;$/;"	t	file:
myFunction	dsp/dspAdapters.cc	/^  MyFunction myFunction;$/;"	m	class:dsp::UniformAdapter	file:
my_chdir	phasta/ph.cc	/^static void my_chdir(const char* name)$/;"	f	namespace:ph
my_fread	phasta/phIO.c	/^static void my_fread(void* p, size_t size, size_t nmemb, FILE* f)$/;"	f	file:
my_mkdir	phasta/ph.cc	/^static bool my_mkdir(const char* name)$/;"	f	namespace:ph
mymain	test/ptnParma.cc	/^void mymain(bool ismaster)$/;"	f	namespace:__anon10
myrank	test/fieldReduce.cc	/^int myrank = -1;$/;"	m	namespace:__anon15	file:
n	apf/apfMIS.h	/^    int n;$/;"	m	class:apf::MIS
n	apf/apfMesh.h	/^  int n;$/;"	m	struct:apf::Up
n	crv/crvQuality.cc	/^  int n;$/;"	m	class:crv::Quality2D	file:
n	crv/crvQuality.cc	/^  int n;$/;"	m	class:crv::Quality3D	file:
n	gmi/agm.c	/^  int n[AGM_BDRY_TYPES];$/;"	m	struct:bdrys	file:
n	gmi/agm.c	/^  int n[AGM_ENT_TYPES];$/;"	m	struct:ents	file:
n	gmi/agm.c	/^  int n[AGM_USE_TYPES];$/;"	m	struct:uses	file:
n	gmi/gmi.c	/^  int n;$/;"	m	struct:creators	file:
n	gmi/gmi.h	/^  int n;$/;"	m	struct:gmi_set
n	gmi/gmi.h	/^  int n[4];$/;"	m	struct:gmi_model
n	mds/mds.c	/^  int n;$/;"	m	struct:down	file:
n	mds/mds.h	/^  int n;$/;"	m	struct:mds_set
n	mds/mds.h	/^  mds_id n[MDS_TYPES];$/;"	m	struct:mds
n	mds/mds_net.h	/^  int n;$/;"	m	struct:mds_copies
n	mds/mds_net.h	/^  mds_id n[MDS_TYPES];$/;"	m	struct:mds_net
n	mds/mds_net.h	/^  unsigned* n;$/;"	m	struct:mds_links
n	parma/diffMC/parma_components.h	/^      unsigned n;$/;"	m	class:parma::dcComponents::Components
n	parma/rib/parma_rib.h	/^  int n;$/;"	m	struct:parma::Bodies
nBoundaryElements	phasta/phOutput.h	/^  int nBoundaryElements;$/;"	m	struct:ph::Output
nBoundaryFaceEdges	phasta/phBlock.h	/^  int nBoundaryFaceEdges;$/;"	m	struct:ph::BlockKey
nElementNodes	phasta/phBlock.h	/^  int nElementNodes[MAX_BLOCK_KEYS];$/;"	m	struct:ph::BlocksCommon
nElementVertices	phasta/phBlock.h	/^  int nElementVertices;$/;"	m	struct:ph::BlockKey
nElementVertices1	phasta/phBlock.h	/^  int nElementVertices1;$/;"	m	struct:ph::BlockKeyInterface
nElements	phasta/phBlock.h	/^  int nElements[MAX_BLOCK_KEYS];$/;"	m	struct:ph::BlocksCommon
nEssentialBCNodes	phasta/phOutput.h	/^  int nEssentialBCNodes;$/;"	m	struct:ph::Output
nGrowthCurves	phasta/phOutput.h	/^  int nGrowthCurves; \/* number of growth curves *\/$/;"	m	struct:ph::Output
nInterfaceElements	phasta/phOutput.h	/^  int nInterfaceElements;$/;"	m	struct:ph::Output
nLayeredMeshVertices	phasta/phOutput.h	/^  int nLayeredMeshVertices; \/* number of layered mesh vertices *\/$/;"	m	struct:ph::Output
nMaxElementNodes	phasta/phOutput.h	/^  int nMaxElementNodes;$/;"	m	struct:ph::Output
nOverlapEdges	phasta/phOutput.h	/^  int nOverlapEdges;$/;"	m	struct:ph::Output
nOverlapNodes	phasta/phOutput.h	/^  int nOverlapNodes;$/;"	m	struct:ph::Output
nOwnedNodes	phasta/phOutput.h	/^  int nOwnedNodes;$/;"	m	struct:ph::Output
nRBParam	phasta/phInput.h	/^    int nRBParam;$/;"	m	class:ph::Input
nRigidBody	phasta/phInput.h	/^    int nRigidBody;$/;"	m	class:ph::Input
naiveOrder	apf/apfAdjReorder.cc	/^  int naiveOrder(Numbering * num, Sharing * shr)$/;"	f	namespace:apf
name	apf/apfField.h	/^    std::string name;$/;"	m	class:apf::FieldBase
name	apf/apfIPShape.cc	/^    std::string name;$/;"	m	class:apf::ConstantIPFit	file:
name	apf/apfIPShape.cc	/^    std::string name;$/;"	m	class:apf::IPShape	file:
name	apf/apfIPShape.cc	/^    std::string name;$/;"	m	class:apf::LinearIPFit	file:
name	apf/apfIPShape.cc	/^    std::string name;$/;"	m	class:apf::VoronoiShape	file:
name	apf/apfShape.cc	/^    std::string name;$/;"	m	class:apf::Constant	file:
name	apf_cap/apfCAP.cc	/^    std::string name;$/;"	m	class:apf::TagCAP	file:
name	apf_sim/apfSIM.cc	/^    std::string name; \/\/Simmetrix has no "get tag name" API$/;"	m	class:apf::TagSIM	file:
name	crv/crvBezier.cc	/^    std::string name;$/;"	m	class:crv::Bezier	file:
name	crv/crvBezier.cc	/^  std::string name;$/;"	m	class:crv::GregorySurface4	file:
name	mds/mds_tag.h	/^  char* name;$/;"	m	struct:mds_tag
name	parma/diffMC/parma_balancer.h	/^      const char* name;$/;"	m	class:parma::Balancer
name	parma/diffMC/parma_step.h	/^      const char* name;$/;"	m	class:parma::Stepper
name	phasta/phBC.cc	/^  const char* name;$/;"	m	struct:ph::KnownBC	file:
name	phasta/phBC.cc	/^static struct { const char* name; int size; } const knownSizes[7] =$/;"	m	struct:ph::__anon90	file:
name	stk/apfSTK.cc	/^  const char * name() const$/;"	f	struct:apf::QPDimTag
nativeModelFile	test/generate.cc	/^std::string nativeModelFile;$/;"	m	namespace:__anon19	file:
naturalBCs	phasta/phBC.cc	/^static KnownBC const naturalBCs[11] = {$/;"	m	namespace:ph	file:
nb	parma/diffMC/parma_shapeOptimizer.cc	/^      parma::Average* nb;$/;"	m	class:__anon47::ImbOrMaxNeighbor	file:
nbAvg	parma/extractParmaResults.py	/^nbAvg = metric("neighborsAvg")$/;"	v
nbMax	parma/extractParmaResults.py	/^nbMax = metric("neighborsMax")$/;"	v
nbTol	parma/diffMC/parma_shapeOptimizer.cc	/^      double nbTol;$/;"	m	class:__anon47::ImbOrMaxNeighbor	file:
nbc	phasta/phOutput.h	/^  int* nbc;$/;"	m	struct:ph::EnsaArrays
nc	apf/apfElement.h	/^    int nc;$/;"	m	class:apf::Element
ncomps	ma/maExtrude.cc	/^  virtual int ncomps() const { return 1; }$/;"	f	struct:ma::__anon28::ZDataGetter
ncomps	ma/maExtrude.cc	/^  virtual int ncomps() const { return 1; }$/;"	f	struct:ma::__anon28::ZDataSetter
ncomps	ma/maExtrude.cc	/^  virtual int ncomps() const { return apf::countComponents(field); }$/;"	f	struct:ma::__anon28::FieldDataGetter
ncomps	ma/maExtrude.cc	/^  virtual int ncomps() const { return apf::countComponents(field); }$/;"	f	struct:ma::__anon28::FieldDataSetter
ncurves	ma/maLayerSnap.cc	/^  long ncurves;$/;"	m	struct:ma::LayerSnapper	file:
ncurves	ma/maLayerSnap.cc	/^  long ncurves;$/;"	m	struct:ma::Unsnapper	file:
ndsc	crv/crvShapeFixer.h	/^    int ndsc;$/;"	m	class:crv::CrvEdgeEdgeFixer
ndsc	ma/maShape.cc	/^    int ndsc;$/;"	m	class:ma::EdgeEdgeFixer	file:
ne	crv/crvShape.cc	/^  int ne;$/;"	m	class:crv::EdgeReshaper	file:
ne	crv/crvShape.cc	/^  int ne;$/;"	m	class:crv::EdgeSwapper	file:
neighborReduction	phasta/phPartition.cc	/^void neighborReduction(apf::Mesh2* m, apf::MeshTag* weights, int verbose, bool fineStats) {$/;"	f	namespace:ph
nen	apf/apfElement.h	/^    int nen;$/;"	m	class:apf::Element
nes	crv/crvShapeFixer.h	/^    int nes;$/;"	m	class:crv::CrvEdgeEdgeFixer
nes	crv/crvShapeFixer.h	/^    int nes;$/;"	m	class:crv::CrvFaceVertFixer
nes	ma/maShape.cc	/^    int nes; \/* number of edge swaps done *\/$/;"	m	class:ma::FaceVertFixer	file:
nes	ma/maShape.cc	/^    int nes;$/;"	m	class:ma::EdgeEdgeFixer	file:
nes	ma/maShape.cc	/^    int nes;$/;"	m	class:ma::FixBySwap	file:
net	parma/diffMC/maximalIndependentSet/mis.h	/^        std::vector<int> net;$/;"	m	struct:misLuby::AdjPart
net	parma/diffMC/maximalIndependentSet/mis.h	/^        std::vector<int> net;$/;"	m	struct:misLuby::PartInfo
netAdjParts	parma/diffMC/maximalIndependentSet/mis.h	/^        mapiu netAdjParts; \/\/ (partId, randNum)$/;"	m	struct:misLuby::PartInfo
newElements	ma/maCollapse.h	/^    EntityArray newElements;$/;"	m	class:ma::Collapse
newEntities	ma/maAdapt.h	/^    NewEntities newEntities;$/;"	m	class:ma::Cavity
newEntities	ma/maFaceSplit.h	/^    apf::DynamicArray<EntityArray> newEntities[4];$/;"	m	class:ma::FaceSplit
newEntities	ma/maRefine.h	/^    apf::DynamicArray<EntityArray> newEntities[4];$/;"	m	class:ma::Refine
newFaces	ma/maEdgeSwap.cc	/^    Entity* newFaces[2];$/;"	m	class:ma::EdgeSwap2D	file:
newFromOld	apf/apfConvert.cc	/^    std::map<MeshEntity*,MeshEntity*> newFromOld;$/;"	m	class:apf::Converter	file:
newLayer	ma/maLayerCollapse.h	/^  EntityVector newLayer;$/;"	m	struct:ma::LayerCollapse
newSimplices	ma/maLayerCollapse.h	/^  EntityArray newSimplices;$/;"	m	struct:ma::LayerCollapse
next	gmi/agm.c	/^  struct agm_tag* next;$/;"	m	struct:agm_tag	typeref:struct:agm_tag::agm_tag	file:
next	gmi/gmi.h	/^  struct gmi_ent* (*next)(struct gmi_model* m, struct gmi_iter* i);$/;"	m	struct:gmi_model_ops	typeref:struct:gmi_model_ops::next
next	gmi_cap/gmi_cap.cc	/^static gmi_ent* next(gmi_model*m, gmi_iter* i)$/;"	f	file:
next	gmi_sim/gmi_sim.cc	/^static gmi_ent* next(gmi_model*, gmi_iter* i)$/;"	f	file:
next	mds/mds_tag.h	/^  struct mds_tag* next;$/;"	m	struct:mds_tag	typeref:struct:mds_tag::mds_tag
next	parma/diffMC/parma_bdryVtx.cc	/^      apf::MeshEntity* next() $/;"	f	class:__anon54::DistItr
next	parma/diffMC/parma_monitor.h	/^      unsigned int next; \/* currently available *\/$/;"	m	class:parma::CircBuffer
next	parma/group/parma_group.cc	/^  GroupCode* next;$/;"	m	struct:RetreatCode	file:
next	pumi/GenIterator.h	/^    inline void next ()$/;"	f	class:GenIterator
next	pumi/pumi_list.h	/^    ListMember* next;$/;"	m	class:ListMember
next_bdry	gmi/agm.c	/^  int* next_bdry[AGM_BDRY_TYPES];$/;"	m	struct:bdrys	file:
next_use_by	gmi/agm.c	/^  int* next_use_by[AGM_USE_TYPES];$/;"	m	struct:uses	file:
next_use_of	gmi/agm.c	/^  int* next_use_of[AGM_USE_TYPES];$/;"	m	struct:uses	file:
nf	crv/crvShapeFixer.h	/^    int nf;$/;"	m	class:crv::CrvEdgeEdgeFixer
nf	crv/crvShapeFixer.h	/^    int nf;$/;"	m	class:crv::CrvFaceVertFixer
nf	crv/crvShapeFixer.h	/^    int nf;$/;"	m	class:crv::CrvShortEdgeFixer
nf	ma/maShape.cc	/^    int nf; \/* number of failures *\/$/;"	m	class:ma::FaceVertFixer	file:
nf	ma/maShape.cc	/^    int nf;$/;"	m	class:ma::EdgeEdgeFixer	file:
nf	ma/maShape.cc	/^    int nf;$/;"	m	class:ma::FixBySwap	file:
nf	ma/maShape.cc	/^    int nf;$/;"	m	class:ma::LargeAngleTriFixer	file:
nf	ma/maShape.cc	/^    int nf;$/;"	m	class:ma::QualityImprover2D	file:
nf	ma/maShape.cc	/^    int nf;$/;"	m	class:ma::ShortEdgeFixer	file:
nfsc	ma/maShape.cc	/^    int nfsc; \/* number of FSCs done *\/$/;"	m	class:ma::FaceVertFixer	file:
nhex	mds/mdsUgrid.cc	/^    unsigned nvtx, ntri, nquad, ntet, npyr, nprz, nhex;$/;"	m	struct:__anon101::header	file:
nlwork	phasta/phOutput.h	/^  int nlwork; \/* size of arrays.ilwork *\/$/;"	m	struct:ph::Output
nlworkf	phasta/phOutput.h	/^  int nlworkf; \/* size of arrays.ilworkf *\/$/;"	m	struct:ph::Output
nlworkl	phasta/phOutput.h	/^  int nlworkl; \/* size of arrays.ilworkl *\/$/;"	m	struct:ph::Output
node	apf/apfNumbering.h	/^  int node;$/;"	m	struct:apf::Node
node	pcu/pcu_msg.h	/^  pcu_aa_node node; \/\/binary tree node for lookup$/;"	m	struct:__anon35
node	pcu/pcu_order.c	/^  pcu_aa_node node;$/;"	m	struct:message	file:
nodeData	apf/apfElement.h	/^    NewArray<double> nodeData;$/;"	m	class:apf::Element
nodeData	apf/apfNumbering.cc	/^    std::vector<T> nodeData;$/;"	m	class:apf::Globalizer	file:
nodeMap	mds/mdsGmsh.cc	/^  std::map<long, Node> nodeMap;$/;"	m	struct:__anon96::Reader	file:
nodeMap	mds/mdsUgrid.cc	/^    std::map<long, apf::MeshEntity*> nodeMap;$/;"	m	struct:__anon101::Reader	file:
norm	mth/mth_def.h	/^T norm(Tensor<T> const& a)$/;"	f	namespace:mth
norm	mth/mth_def.h	/^T norm(Vector<T,M> const& a)$/;"	f	namespace:mth
normal	apf/apfGeometry.h	/^  Vector3 normal;$/;"	m	struct:apf::Plane
normal	gmi/gmi.h	/^  void (*normal)(struct gmi_model* m, struct gmi_ent* e,$/;"	m	struct:gmi_model_ops
normal	gmi_cap/gmi_cap.cc	/^static void normal(struct gmi_model* m, struct gmi_ent* e,$/;"	f	file:
normal	gmi_sim/gmi_sim.cc	/^static void normal(struct gmi_model* m, struct gmi_ent* e,$/;"	f	file:
normal	parma/rib/parma_rib.cc	/^  mth::Vector3<double> normal;$/;"	m	struct:parma::Compare	file:
normalize	apf/apfVector.h	/^    Vector<N> normalize() const {return (*this) \/ getLength();}$/;"	f	class:apf::Vector
normalize	mth/mthVector.h	/^    Vector<T,N> normalize() const {return (*this)\/getLength();}$/;"	f	class:mth::Vector
normalize	parma/rib/parma_rib.cc	/^static mth::Matrix3x3<double> normalize(mth::Matrix3x3<double> const& A)$/;"	f	namespace:parma
note_local_link	mds/mds_net.c	/^static void note_local_link(mds_id i, struct mds_copy c, void* u)$/;"	f	file:
note_peer	mds/mds_net.c	/^static void note_peer(struct mds_links* ln, int p)$/;"	f	file:
note_remote_link	mds/mds_net.c	/^static void note_remote_link(mds_id i, struct mds_copy c, void* u)$/;"	f	file:
noto_free	pcu/noto/noto_malloc.c	/^void noto_free(void* p)$/;"	f
noto_malloc	pcu/noto/noto_malloc.c	/^void* noto_malloc(size_t size)$/;"	f
noto_malloced	pcu/noto/noto_malloc.c	/^size_t noto_malloced(void)$/;"	f
noto_realloc	pcu/noto/noto_malloc.c	/^void* noto_realloc(void* p, size_t size)$/;"	f
np	mds/mds_net.h	/^  unsigned np;$/;"	m	struct:mds_links
nprz	mds/mdsUgrid.cc	/^    unsigned nvtx, ntri, nquad, ntet, npyr, nprz, nhex;$/;"	m	struct:__anon101::header	file:
npyr	mds/mdsUgrid.cc	/^    unsigned nvtx, ntri, nquad, ntet, npyr, nprz, nhex;$/;"	m	struct:__anon101::header	file:
nquad	mds/mdsUgrid.cc	/^    unsigned nvtx, ntri, nquad, ntet, npyr, nprz, nhex;$/;"	m	struct:__anon101::header	file:
nr	crv/crvShape.cc	/^  int nr;$/;"	m	class:crv::EdgeReshaper	file:
nr	crv/crvShapeFixer.h	/^    int nr;$/;"	m	class:crv::CrvShortEdgeFixer
nr	ma/maShape.cc	/^    int nr;$/;"	m	class:ma::ShortEdgeFixer	file:
ns	crv/crvShape.cc	/^  int ns;$/;"	m	class:crv::EdgeSwapper	file:
ns	ma/maShape.cc	/^    int ns;$/;"	m	class:ma::LargeAngleTriFixer	file:
ns	ma/maShape.cc	/^    int ns;$/;"	m	class:ma::QualityImprover2D	file:
ntet	mds/mdsUgrid.cc	/^    unsigned nvtx, ntri, nquad, ntet, npyr, nprz, nhex;$/;"	m	struct:__anon101::header	file:
ntri	mds/mdsUgrid.cc	/^    unsigned nvtx, ntri, nquad, ntet, npyr, nprz, nhex;$/;"	m	struct:__anon101::header	file:
numBdryFaces	ma/maRegionCollapse.h	/^    int numBdryFaces;$/;"	m	class:ma::RegionCollapse
numBdryVtx	parma/parma.cc	/^  int numBdryVtx(apf::Mesh* m, bool onlyShared=false) {$/;"	f	namespace:__anon75
numDisconnectedComps	parma/diffMC/parma_dcpart.cc	/^unsigned dcPart::numDisconnectedComps() {$/;"	f	class:dcPart
numElemsBelowTol	test/quality.cc	/^long numElemsBelowTol = 0;$/;"	m	namespace:__anon21	file:
numElms	test/icesheet.cc	/^  unsigned numElms;$/;"	m	struct:MeshInfo	file:
numEnt	test/test_integrator.cc	/^    unsigned int numEnt;$/;"	m	class:CountIntegrator	file:
numGE	test/fusion3.cc	/^const int numGE=6;$/;"	v
numGF	test/fusion3.cc	/^const int numGF=3;$/;"	v
numGV	test/fusion3.cc	/^const int numGV=6;$/;"	v
numIso	parma/diffMC/parma_components.cc	/^  unsigned dcComponents::numIso() { return c->iso(); }$/;"	f	class:parma::dcComponents
numIso	parma/diffMC/parma_dcpart.h	/^      unsigned numIso;$/;"	m	class:dcPart
numItems	parma/diffMC/zeroOneKnapsack.c	/^    size_t numItems;$/;"	m	struct:zeroOneKnapsack	file:
numMdlBdryVtx	parma/parma.cc	/^  int numMdlBdryVtx(apf::Mesh* m) {$/;"	f	namespace:__anon75
numRigidBody	phasta/phOutput.h	/^  bool numRigidBody;$/;"	m	struct:ph::Output
numSharedSides	parma/parma.cc	/^  int numSharedSides(apf::Mesh* m) {$/;"	f	namespace:__anon75
numSplits	crv/crvQuality.cc	/^static int numSplits[apf::Mesh::TYPES] =$/;"	m	namespace:crv	file:
numToTry	ma/maShape.cc	/^    int numToTry;$/;"	m	class:ma::FixBySwap	file:
numVerts	test/icesheet.cc	/^  unsigned numVerts;$/;"	m	struct:MeshInfo	file:
numVtxPerElm	test/icesheet.cc	/^  unsigned numVtxPerElm;$/;"	m	struct:MeshInfo	file:
num_dims	test/poisson.cc	/^    int num_dims;$/;"	m	class:__anon17::Poisson	file:
num_dofs	test/poisson.cc	/^    int num_dofs;$/;"	m	class:__anon17::Poisson	file:
num_exported	zoltan/apfZoltanCallbacks.h	/^    int num_exported; \/* Number of nodes to be exported. *\/$/;"	m	class:apf::ZoltanData
num_global_ent	pumi/pumi.h	/^  int* num_global_ent;$/;"	m	class:pumi
num_grid	test/poisson.cc	/^    int num_grid;$/;"	m	class:__anon17::Poisson	file:
num_imported	zoltan/apfZoltanCallbacks.h	/^    int num_imported; \/* Number of nodes to be imported. *\/$/;"	m	class:apf::ZoltanData
num_in_part	test/pumi.cc	/^int num_in_part = 0;$/;"	v
num_local_ent	pumi/pumi.h	/^  int* num_local_ent;$/;"	m	class:pumi
num_own_ent	pumi/pumi.h	/^  int* num_own_ent;$/;"	m	class:pumi
num_points	spr/sprRecoverField.cc	/^  int num_points;$/;"	m	struct:spr::Samples	file:
num_var	apf/apfArrayData.cc	/^    Numbering* num_var; $/;"	m	class:apf::ArrayDataOf	file:
number	apf/apfNumbering.cc	/^void number(GlobalNumbering* n, MeshEntity* e, int node, long number)$/;"	f	namespace:apf
number	apf/apfNumbering.cc	/^void number(GlobalNumbering* n, Node node, long number, int component)$/;"	f	namespace:apf
number	apf/apfNumbering.cc	/^void number(Numbering* n, MeshEntity* e, int node, int component, int number)$/;"	f	namespace:apf
numberElements	apf/apfNumbering.cc	/^Numbering* numberElements(Mesh* mesh, const char* name)$/;"	f	namespace:apf
numberGhost	apf/apfMixedNumbering.cc	/^int numberGhost($/;"	f	namespace:apf
numberLayer	ma/maCrawler.cc	/^static Tag* numberLayer(Adapt* a)$/;"	f	namespace:ma
numberNodes	apf/apfNumbering.cc	/^Numbering* numberNodes($/;"	f	namespace:apf
numberOverlapDimension	apf/apfNumbering.cc	/^Numbering* numberOverlapDimension(Mesh* mesh, const char* name, int dim)$/;"	f	namespace:apf
numberOverlapNodes	apf/apfNumbering.cc	/^Numbering* numberOverlapNodes(Mesh* mesh, const char* name, FieldShape* s)$/;"	f	namespace:apf
numberOwned	apf/apfMixedNumbering.cc	/^int numberOwned($/;"	f	namespace:apf
numberOwnedDimension	apf/apfNumbering.cc	/^Numbering* numberOwnedDimension(Mesh* mesh, const char* name, int dim,$/;"	f	namespace:apf
numberOwnedNodes	apf/apfNumbering.cc	/^Numbering* numberOwnedNodes($/;"	f	namespace:apf
numberTag	ma/maRefine.h	/^    Tag* numberTag;$/;"	m	class:ma::Refine
number_connected_verts	mds/mds_order.c	/^static void number_connected_verts(struct mds* m, mds_id v,$/;"	f	file:
number_dim	test/renderClass.cc	/^static void number_dim(apf::Mesh* m, apf::FieldShape* shape, int dim, std::string const& prefix) {$/;"	f	file:
number_ent	apf/apfMixedNumbering.cc	/^static void number_ent($/;"	f	namespace:apf
number_ents_of_type	mds/mds_order.c	/^static void number_ents_of_type(struct mds* m,$/;"	f	file:
number_ghost	apf/apfMixedNumbering.cc	/^static int number_ghost($/;"	f	namespace:apf
number_other_ents	mds/mds_order.c	/^static void number_other_ents(struct mds_apf* m, struct mds_tag* tag)$/;"	f	file:
number_owned	apf/apfMixedNumbering.cc	/^static int number_owned($/;"	f	namespace:apf
numbering	apf/apfNumbering.cc	/^    NumberingOf<T>* numbering;$/;"	m	class:apf::Globalizer	file:
numbering	test/hierarchic.cc	/^    apf::GlobalNumbering* numbering;$/;"	m	class:__anon20::L2Projector	file:
numbering	test/poisson.cc	/^    apf::GlobalNumbering* numbering;$/;"	m	class:__anon17::Poisson	file:
numberings	apf/apfMesh.h	/^    std::vector<Numbering*> numberings;$/;"	m	class:apf::Mesh
numbers	test/poisson.cc	/^    apf::NewArray<long> numbers;$/;"	m	class:__anon17::Poisson	file:
numparts	mds/mdsUgrid.cc	/^      int numparts;$/;"	m	class:__anon101::ptnstats	file:
nvtx	mds/mdsUgrid.cc	/^    unsigned nvtx, ntri, nquad, ntet, npyr, nprz, nhex;$/;"	m	struct:__anon101::header	file:
nx	test/box.cc	/^int nx = 0;$/;"	m	namespace:__anon8	file:
ny	test/box.cc	/^int ny = 0;$/;"	m	namespace:__anon8	file:
nz	test/box.cc	/^int nz = 0;$/;"	m	namespace:__anon8	file:
o	test/pumi.cc	/^  pOwnership o;$/;"	m	struct:testOwnership	file:
octToTets	ma/maTemplates.cc	/^void octToTets(Refine* r, Entity* parent, Entity** v)$/;"	f	namespace:ma
octToTetsGeometric	ma/maTemplates.cc	/^void octToTetsGeometric(Refine* r, Entity* parent, Entity** v)$/;"	f	namespace:ma
oct_rotation	ma/maTables.cc	/^int const oct_rotation[24][6] =$/;"	m	namespace:ma	file:
offset	apf/apfPartition.h	/^  int offset;$/;"	m	struct:apf::Unmodulo
offset	parma/diffMC/parma_graphDist.cc	/^  void offset(apf::Mesh* m, parma::dcComponents& c,$/;"	f	namespace:__anon74
offset	phasta/phBC.cc	/^  int offset;$/;"	m	struct:ph::KnownBC	file:
ok	apf/apfVtk.h	/^    bool ok;$/;"	m	class:apf::HasAll
oldFaces	ma/maEdgeSwap.cc	/^    EntityArray oldFaces;$/;"	m	class:ma::EdgeSwap2D	file:
oldQuality	ma/maDoubleSplitCollapse.h	/^    double oldQuality;$/;"	m	class:ma::DoubleSplitCollapse
oldQuality	ma/maFaceSplitCollapse.h	/^    double oldQuality;$/;"	m	class:ma::FaceSplitCollapse
oldTets	ma/maEdgeSwap.cc	/^    Upward oldTets;$/;"	m	class:ma::EdgeSwap3D	file:
oldTets	ma/maEdgeSwap.cc	/^    Upward* oldTets;$/;"	m	class:ma::SwapCavity	file:
onBoundary	parma/diffMC/parma_meshaux.h	/^bool onBoundary(apf::Mesh* m, apf::MeshEntity* e) {$/;"	f
onCavity	crv/crvShapeHandler.cc	/^    virtual void onCavity($/;"	f	class:crv::BezierHandler
onCavity	ma/maShapeHandler.cc	/^    virtual void onCavity($/;"	f	class:ma::QuadraticHandler
onCavity	ma/maSolutionTransfer.cc	/^    virtual void onCavity($/;"	f	class:ma::CavityTransfer
onCavity	ma/maSolutionTransfer.cc	/^    virtual void onCavity($/;"	f	class:ma::HighOrderTransfer
onCavity	ma/maSolutionTransfer.cc	/^void SolutionTransfer::onCavity($/;"	f	class:ma::SolutionTransfer
onCavity	ma/maSolutionTransfer.cc	/^void SolutionTransfers::onCavity($/;"	f	class:ma::SolutionTransfers
onMdlBdry	parma/diffMC/parma_graphDist.cc	/^  inline bool onMdlBdry(apf::Mesh* m, apf::MeshEntity* v) {$/;"	f	namespace:__anon74
onRefine	crv/crvShapeHandler.cc	/^    virtual void onRefine($/;"	f	class:crv::BezierHandler
onRefine	crv/crvShapeHandler.cc	/^    virtual void onRefine($/;"	f	class:crv::BezierTransfer
onRefine	ma/maShapeHandler.cc	/^    virtual void onRefine($/;"	f	class:ma::QuadraticHandler
onRefine	ma/maSolutionTransfer.cc	/^    virtual void onRefine($/;"	f	class:ma::CavityTransfer
onRefine	ma/maSolutionTransfer.cc	/^    virtual void onRefine($/;"	f	class:ma::HighOrderTransfer
onRefine	ma/maSolutionTransfer.cc	/^void SolutionTransfer::onRefine($/;"	f	class:ma::SolutionTransfer
onRefine	ma/maSolutionTransfer.cc	/^void SolutionTransfers::onRefine($/;"	f	class:ma::SolutionTransfers
onVertex	ma/maShapeHandler.cc	/^    virtual void onVertex($/;"	f	class:ma::LinearHandler
onVertex	ma/maShapeHandler.cc	/^    virtual void onVertex($/;"	f	class:ma::QuadraticHandler
onVertex	ma/maSolutionTransfer.cc	/^    virtual void onVertex($/;"	f	class:ma::HighOrderTransfer
onVertex	ma/maSolutionTransfer.cc	/^    virtual void onVertex($/;"	f	class:ma::LinearTransfer
onVertex	ma/maSolutionTransfer.cc	/^void SolutionTransfer::onVertex($/;"	f	class:ma::SolutionTransfer
onVertex	ma/maSolutionTransfer.cc	/^void SolutionTransfers::onVertex($/;"	f	class:ma::SolutionTransfers
op	ma/maOperator.cc	/^    Operator* op;$/;"	m	class:ma::CollectiveOperation	file:
open	parma/diffMC/parma_vtxPtnWriter.cc	/^  void open(const char* name, std::fstream& f) {$/;"	f	namespace:__anon72
openFileRead	phasta/ph_convert.cc	/^  static FILE* openFileRead(ph::Input&, const char* path) {$/;"	f	namespace:__anon94
openFileWrite	phasta/ph_convert.cc	/^  static FILE* openFileWrite(ph::Output&, const char* path) {$/;"	f	namespace:__anon94
openGRStreamRead	phasta/phstream.cc	/^FILE* openGRStreamRead(GRStream* grs, const char* named) {$/;"	f
openGRStreamRead	phasta/phstream.cc	/^FILE* openGRStreamRead(GRStream*, const char*) {$/;"	f
openGRStreamWrite	phasta/phstream.cc	/^FILE* openGRStreamWrite(GRStream* grs, const char* named) {$/;"	f
openGRStreamWrite	phasta/phstream.cc	/^FILE* openGRStreamWrite(GRStream*, const char*) {$/;"	f
openRStreamRead	phasta/phstream.cc	/^FILE* openRStreamRead(RStream* rs) {$/;"	f
openRStreamRead	phasta/phstream.cc	/^FILE* openRStreamRead(RStream*) {$/;"	f
openRStreamWrite	phasta/phstream.cc	/^FILE* openRStreamWrite(RStream* rs) {$/;"	f
openRStreamWrite	phasta/phstream.cc	/^FILE* openRStreamWrite(RStream*) {$/;"	f
openTime	phasta/phiotimer.cc	/^  size_t openTime[NUM_PHASTAIO_MODES];$/;"	m	struct:phastaio_stats	file:
open_compressed	pcu/pcu_io.c	/^static void open_compressed(pcu_file* pf)$/;"	f	file:
open_compressed_read	pcu/pcu_io.c	/^static void open_compressed_read(pcu_file* pf)$/;"	f	file:
open_compressed_write	pcu/pcu_io.c	/^static void open_compressed_write(pcu_file* pf)$/;"	f	file:
openfile_read	phasta/condense.cc	/^  static FILE* openfile_read(ph::Input&, const char* path) {$/;"	f	namespace:__anon85
openfile_read	phasta/phCook.cc	/^  static FILE* openfile_read(ph::Input&, const char* path) {$/;"	f	namespace:chef
openfile_read	phasta/phInput.h	/^    FILE* (*openfile_read)(Input& in, const char* path);$/;"	m	class:ph::Input
openfile_read	phasta/readUrPrep.cc	/^  static FILE* openfile_read(ph::Input&, const char* path) {$/;"	f	namespace:__anon89
openfile_read	test/ph_adapt.cc	/^static FILE* openfile_read(ph::Input&, const char* path) {$/;"	f	file:
openfile_write	phasta/phCook.cc	/^  static FILE* openfile_write(ph::Output&, const char* path) {$/;"	f	namespace:chef
openfile_write	phasta/phOutput.h	/^  FILE* (*openfile_write)(Output& out, const char* path);$/;"	m	struct:ph::Output
opens	phasta/phiotimer.cc	/^  size_t opens[NUM_PHASTAIO_MODES];$/;"	m	struct:phastaio_stats	file:
openstream_read	phasta/phCook.cc	/^  static FILE* openstream_read(ph::Input& in, const char* path) {$/;"	f	namespace:chef
openstream_write	phasta/phCook.cc	/^  static FILE* openstream_write(ph::Output& out, const char* path) {$/;"	f	namespace:chef
operator !=	pumi/GenIterator.h	/^inline bool GenIterator<Iterator, Entity> :: operator != (GenIterator const & other) const$/;"	f	class:GenIterator
operator !=	pumi/pumi_list.h	/^    bool operator!=(ListIterator<T> const& other) const$/;"	f	class:ListIterator
operator ()	apf/apfDynamicMatrix.h	/^    double operator()(std::size_t i, std::size_t j) const$/;"	f	class:apf::DynamicMatrix
operator ()	apf/apfDynamicMatrix.h	/^    double& operator()(std::size_t i, std::size_t j)$/;"	f	class:apf::DynamicMatrix
operator ()	apf/apfDynamicVector.h	/^    double operator()(std::size_t i) const$/;"	f	class:apf::DynamicVector
operator ()	apf/apfDynamicVector.h	/^    double& operator()(std::size_t i)$/;"	f	class:apf::DynamicVector
operator ()	apf/apfGradientByVolume.cc	/^    Matrix3x3 operator()(Element* e, Vector3 const& xi)$/;"	f	class:apf::GetGradient
operator ()	apf/apfGradientByVolume.cc	/^    Vector3 operator()(Element* e, Vector3 const& xi)$/;"	f	class:apf::GetGradient
operator ()	apf/apfGradientByVolume.cc	/^    void operator()(Field* f, MeshEntity* v, Matrix3x3 const& value)$/;"	f	class:apf::SetValue
operator ()	apf/apfGradientByVolume.cc	/^    void operator()(Field* f, MeshEntity* v, Vector3 const& value)$/;"	f	class:apf::SetValue
operator ()	apf/apfPartition.h	/^  int operator()(int in)$/;"	f	struct:apf::Expand
operator ()	apf/apfPartition.h	/^  int operator()(int n) {return (n \/ factor) * factor;}$/;"	f	struct:apf::Round
operator ()	apf/apfPartition.h	/^  int operator()(int n) {return n % by;}$/;"	f	struct:apf::Modulo
operator ()	apf/apfPartition.h	/^  int operator()(int n) {return n * by;}$/;"	f	struct:apf::Multiply
operator ()	apf/apfPartition.h	/^  int operator()(int n) {return n + offset;}$/;"	f	struct:apf::Unmodulo
operator ()	apf/apfPartition.h	/^  int operator()(int n) {return n \/ by;}$/;"	f	struct:apf::Divide
operator ()	apf/apfPartition.h	/^  int operator()(int out)$/;"	f	struct:apf::Contract
operator ()	crv/crvShape.cc	/^  bool operator()(apf::MeshEntity* e)$/;"	f	struct:crv::IsBadCrvQuality
operator ()	ma/maAdapt.cc	/^bool HasFlag::operator()(Entity* e)$/;"	f	class:ma::HasFlag
operator ()	ma/maAdapt.cc	/^bool HasTag::operator()(Entity* e)$/;"	f	class:ma::HasTag
operator ()	ma/maCoarsen.cc	/^  bool operator()(Entity* e)$/;"	f	struct:ma::ShouldCollapse
operator ()	ma/maMatchedCollapse.cc	/^  bool operator()(Rebuild const& r) const$/;"	f	struct:ma::IsFalseRebuild
operator ()	ma/maRefine.cc	/^  bool operator()(Entity* e)$/;"	f	struct:ma::ShouldSplit
operator ()	ma/maShape.cc	/^  bool operator()(Entity* e)$/;"	f	struct:ma::IsBadQuality
operator ()	mth/mthMatrix.h	/^    T const& operator()(unsigned i, unsigned j) const {return (*this)[i][j];}$/;"	f	class:mth::Matrix
operator ()	mth/mthMatrix.h	/^    T const& operator()(unsigned i, unsigned j) const$/;"	f	class:mth::Matrix
operator ()	mth/mthMatrix.h	/^    T& operator()(unsigned i, unsigned j) {return (*this)[i][j];}$/;"	f	class:mth::Matrix
operator ()	mth/mthMatrix.h	/^    T& operator()(unsigned i, unsigned j)$/;"	f	class:mth::Matrix
operator ()	mth/mthVector.h	/^    T const& operator()(unsigned i) const {return (*this)[i];}$/;"	f	class:mth::Vector
operator ()	mth/mthVector.h	/^    T& operator()(unsigned i) {return (*this)[i];}$/;"	f	class:mth::Vector
operator ()	parma/diffMC/parma_distQ.h	/^    bool operator() (const int& l, const int& r) const {$/;"	f	struct:parma::Greater
operator ()	parma/diffMC/parma_distQ.h	/^    bool operator() (const int& l, const int& r) const {$/;"	f	struct:parma::Less
operator ()	parma/diffMC/parma_edgeEqVtxSelector.cc	/^        bool operator()(const Migr& a, const Migr& b) const {$/;"	f	struct:__anon52::EdgeEqVtx::CompareMigr
operator ()	parma/diffMC/parma_elmLtVtxEdgeSelector.cc	/^        bool operator()(const Migr& a, const Migr& b) const {$/;"	f	struct:__anon64::ElmLtVtxEdgeSelector::CompareMigr
operator ()	parma/diffMC/parma_ltSelector.cc	/^        bool operator()(const Migr& a, const Migr& b) const {$/;"	f	struct:__anon58::LtSelector::CompareMigr
operator ()	parma/rib/parma_rib.cc	/^  bool operator()(Body* a, Body* b)$/;"	f	struct:parma::Compare
operator ()	phasta/phBC.h	/^  bool operator()(BC const* a, BC const* b) const { return *a < *b; };$/;"	f	struct:ph::BCPointerLess
operator ()	test/eigen_test.cc	/^  bool operator()(apf::Vector<4> const& a, apf::Vector<4> const& b)$/;"	f	struct:VectorLess
operator *	apf/apfDynamicVector.h	/^    double operator*(DynamicVector const& b) const$/;"	f	class:apf::DynamicVector
operator *	apf/apfGeometry.cc	/^Frame operator*(Frame const& a, Frame const& b)$/;"	f	namespace:apf
operator *	apf/apfGeometry.cc	/^Vector3 operator*(Frame const& a, Vector3 const& b)$/;"	f	namespace:apf
operator *	apf/apfMatrix.h	/^    Matrix<M,N> operator*(double s) const$/;"	f	class:apf::Matrix
operator *	apf/apfMatrix.h	/^    Matrix<M,O> operator*(Matrix<N,O> const& b) const$/;"	f	class:apf::Matrix
operator *	apf/apfMatrix.h	/^    Vector<M> operator*(Vector<N> const& b) const$/;"	f	class:apf::Matrix
operator *	apf/apfVector.h	/^    Vector<N> operator*(double s) const$/;"	f	class:apf::Vector
operator *	apf/apfVector.h	/^    double operator*(Vector<N> const& b) const$/;"	f	class:apf::Vector
operator *	ma/maAffine.h	/^    apf::Vector3 operator*(apf::Vector3 const& x) const$/;"	f	class:ma::Affine
operator *	mds/apfBox.cc	/^Indices Indices::operator*(int s)$/;"	f	class:apf::Indices
operator *	mth/mthAD.h	/^AD<T, N> operator*(AD<T, N> const& L, AD<B, N> const& R)$/;"	f	namespace:mth
operator *	mth/mthAD.h	/^AD<T, N> operator*(AD<T, N> const& L, double R)$/;"	f	namespace:mth
operator *	mth/mthAD.h	/^AD<T, N> operator*(double L, AD<T, N> const& R)$/;"	f	namespace:mth
operator *	mth/mthMatrix.h	/^    Matrix<T,M,N> operator*(T const& s) const$/;"	f	class:mth::Matrix
operator *	mth/mthMatrix.h	/^    Matrix<T,M,O> operator*(Matrix<T,N,O> const& b) const$/;"	f	class:mth::Matrix
operator *	mth/mthMatrix.h	/^    Vector<T,M> operator*(Vector<T,N> const& b) const$/;"	f	class:mth::Matrix
operator *	mth/mthTensor.h	/^    Tensor<T> operator*(T const& s)$/;"	f	class:mth::Tensor
operator *	mth/mthTensor.h	/^    Tensor<T> operator*(Tensor<T> const& b)$/;"	f	class:mth::Tensor
operator *	mth/mthVector.h	/^    T operator*(Vector<T,N> const& b) const$/;"	f	class:mth::Vector
operator *	mth/mthVector.h	/^    Vector<T,N> operator*(T const& s) const$/;"	f	class:mth::Vector
operator *	mth/mthVector.h	/^    double operator*(Vector<T,0> const& b)$/;"	f	class:mth::Vector
operator *	pumi/GenIterator.h	/^   inline Entity * operator *() const$/;"	f	class:GenIterator
operator *	pumi/pumi_list.h	/^    T* operator*() const$/;"	f	class:ListIterator
operator *=	apf/apfDynamicMatrix.h	/^    DynamicMatrix& operator*=(double s)$/;"	f	class:apf::DynamicMatrix
operator *=	apf/apfDynamicVector.h	/^    DynamicVector& operator*=(double s)$/;"	f	class:apf::DynamicVector
operator *=	mth/mthAD.h	/^    AD<T, 0>& operator*=(AD<T, 0> const& other)$/;"	f	class:mth::AD
operator *=	mth/mthAD.h	/^    AD<T, 0>& operator*=(double other)$/;"	f	class:mth::AD
operator *=	mth/mthAD.h	/^    AD<T, N>& operator*=(AD<B, N> const& other)$/;"	f	class:mth::AD
operator *=	mth/mthAD.h	/^    AD<T, N>& operator*=(double other)$/;"	f	class:mth::AD
operator *=	mth/mthMatrix.h	/^    Matrix<T>& operator*=(T const& s)$/;"	f	class:mth::Matrix
operator *=	mth/mthVector.h	/^    Vector<T,0>& operator*=(T const& s)$/;"	f	class:mth::Vector
operator +	apf/apfMatrix.h	/^    Matrix<M,N> operator+(Matrix<M,N> const& b) const$/;"	f	class:apf::Matrix
operator +	apf/apfVector.h	/^    Vector<N> operator+(Vector<N> const& b) const$/;"	f	class:apf::Vector
operator +	mds/apfBox.cc	/^Indices Indices::operator+(Indices oi)$/;"	f	class:apf::Indices
operator +	mth/mthAD.h	/^AD<T, N> operator+(AD<T, N> const& L, AD<B, N> const& R)$/;"	f	namespace:mth
operator +	mth/mthAD.h	/^AD<T, N> operator+(AD<T, N> const& L, double R)$/;"	f	namespace:mth
operator +	mth/mthAD.h	/^AD<T, N> operator+(double L, AD<T, N> const& R)$/;"	f	namespace:mth
operator +	mth/mthMatrix.h	/^    Matrix<T,M,N> operator+(Matrix<T,M,N> const& b) const$/;"	f	class:mth::Matrix
operator +	mth/mthTensor.h	/^    Tensor<T> operator+(Tensor<T> const& b)$/;"	f	class:mth::Tensor
operator +	mth/mthVector.h	/^    Vector<T,N> operator+(Vector<T,N> const& b) const$/;"	f	class:mth::Vector
operator ++	pumi/GenIterator.h	/^    inline GenIterator & operator++() $/;"	f	class:GenIterator
operator ++	pumi/GenIterator.h	/^    inline GenIterator operator++(int) $/;"	f	class:GenIterator
operator ++	pumi/pumi_list.h	/^    ListIterator<T> operator++(int)$/;"	f	class:ListIterator
operator ++	pumi/pumi_list.h	/^    ListIterator<T>& operator++()$/;"	f	class:ListIterator
operator +=	apf/apfDynamicMatrix.h	/^    DynamicMatrix& operator+=(DynamicMatrix const& b)$/;"	f	class:apf::DynamicMatrix
operator +=	apf/apfDynamicVector.h	/^    DynamicVector& operator+=(DynamicVector const& b)$/;"	f	class:apf::DynamicVector
operator +=	apf/apfVector.h	/^    Vector<N>& operator+=(Vector<N> const& b)$/;"	f	class:apf::Vector
operator +=	mth/mthAD.h	/^    AD<T, 0>& operator+=(AD<T, 0> const& other)$/;"	f	class:mth::AD
operator +=	mth/mthAD.h	/^    AD<T, 0>& operator+=(double other)$/;"	f	class:mth::AD
operator +=	mth/mthAD.h	/^    AD<T, N>& operator+=(AD<B, N> const& other)$/;"	f	class:mth::AD
operator +=	mth/mthAD.h	/^    AD<T, N>& operator+=(double other)$/;"	f	class:mth::AD
operator +=	mth/mthMatrix.h	/^    Matrix<T>& operator+=(Matrix<T> const& b)$/;"	f	class:mth::Matrix
operator +=	mth/mthVector.h	/^    Vector<T,0>& operator+=(Vector<T,0> const& b)$/;"	f	class:mth::Vector
operator +=	mth/mthVector.h	/^    Vector<T,N>& operator+=(Vector<T,N> const& b)$/;"	f	class:mth::Vector
operator -	apf/apfMatrix.h	/^    Matrix<M,N> operator-(Matrix<M,N> const& b) const$/;"	f	class:apf::Matrix
operator -	apf/apfVector.h	/^    Vector<N> operator-(Vector<N> const& b) const$/;"	f	class:apf::Vector
operator -	mth/mthAD.h	/^AD<T, N> operator-(AD<T, N> const& A)$/;"	f	namespace:mth
operator -	mth/mthAD.h	/^AD<T, N> operator-(AD<T, N> const& L, AD<B, N> const& R)$/;"	f	namespace:mth
operator -	mth/mthAD.h	/^AD<T, N> operator-(AD<T, N> const& L, double R)$/;"	f	namespace:mth
operator -	mth/mthAD.h	/^AD<T, N> operator-(double L, AD<T, N> const& R)$/;"	f	namespace:mth
operator -	mth/mthMatrix.h	/^    Matrix<T,M,N> operator-(Matrix<T,M,N> const& b) const$/;"	f	class:mth::Matrix
operator -	mth/mthTensor.h	/^    Tensor<T> operator-(Tensor<T> const& b)$/;"	f	class:mth::Tensor
operator -	mth/mthVector.h	/^    Vector<T,N> operator-(Vector<T,N> const& b) const$/;"	f	class:mth::Vector
operator -=	apf/apfDynamicMatrix.h	/^    DynamicMatrix& operator-=(DynamicMatrix const& b)$/;"	f	class:apf::DynamicMatrix
operator -=	apf/apfDynamicVector.h	/^    DynamicVector& operator-=(DynamicVector const& b)$/;"	f	class:apf::DynamicVector
operator -=	mth/mthAD.h	/^    AD<T, 0>& operator-=(AD<T, 0> const& other)$/;"	f	class:mth::AD
operator -=	mth/mthAD.h	/^    AD<T, 0>& operator-=(double other)$/;"	f	class:mth::AD
operator -=	mth/mthAD.h	/^    AD<T, N>& operator-=(AD<B, N> const& other)$/;"	f	class:mth::AD
operator -=	mth/mthAD.h	/^    AD<T, N>& operator-=(double other)$/;"	f	class:mth::AD
operator -=	mth/mthMatrix.h	/^    Matrix<T>& operator-=(Matrix<T> const& b)$/;"	f	class:mth::Matrix
operator -=	mth/mthVector.h	/^    Vector<T,0>& operator-=(Vector<T,0> const& b)$/;"	f	class:mth::Vector
operator -=	mth/mthVector.h	/^    Vector<T,N>& operator-=(Vector<T,N> const& b)$/;"	f	class:mth::Vector
operator /	apf/apfMatrix.h	/^    Matrix<M,N> operator\/(double s) const$/;"	f	class:apf::Matrix
operator /	apf/apfVector.h	/^    Vector<N> operator\/(double s) const$/;"	f	class:apf::Vector
operator /	mth/mthAD.h	/^AD<T, N> operator\/(AD<B, N> const& L, AD<T, N> const& R)$/;"	f	namespace:mth
operator /	mth/mthAD.h	/^AD<T, N> operator\/(AD<T, N> const& L, double R)$/;"	f	namespace:mth
operator /	mth/mthAD.h	/^AD<T, N> operator\/(double L, AD<T, N> const& R)$/;"	f	namespace:mth
operator /	mth/mthMatrix.h	/^    Matrix<T,M,N> operator\/(T const& s) const$/;"	f	class:mth::Matrix
operator /	mth/mthTensor.h	/^    Tensor<T> operator\/(T const& s)$/;"	f	class:mth::Tensor
operator /	mth/mthVector.h	/^    Vector<T,N> operator\/(T const& s) const$/;"	f	class:mth::Vector
operator /=	apf/apfDynamicMatrix.h	/^    DynamicMatrix& operator\/=(double s)$/;"	f	class:apf::DynamicMatrix
operator /=	apf/apfDynamicVector.h	/^    DynamicVector& operator\/=(double s)$/;"	f	class:apf::DynamicVector
operator /=	mth/mthAD.h	/^    AD<T, 0>& operator\/=(AD<T, 0> const& other)$/;"	f	class:mth::AD
operator /=	mth/mthAD.h	/^    AD<T, 0>& operator\/=(double other)$/;"	f	class:mth::AD
operator /=	mth/mthAD.h	/^    AD<T, N>& operator\/=(AD<B, N> const& other)$/;"	f	class:mth::AD
operator /=	mth/mthAD.h	/^    AD<T, N>& operator\/=(double other)$/;"	f	class:mth::AD
operator /=	mth/mthMatrix.h	/^    Matrix<T>& operator\/=(T const& s)$/;"	f	class:mth::Matrix
operator /=	mth/mthVector.h	/^    Vector<T,0>& operator\/=(T const& s)$/;"	f	class:mth::Vector
operator <	ma/maMatchedCollapse.cc	/^bool Rebuild::operator<(Rebuild const& other) const$/;"	f	class:ma::Rebuild
operator <	mds/apfPM.h	/^  bool operator<(PME const& other) const$/;"	f	struct:apf::PME
operator <	mth/mthAD.h	/^bool operator<(AD<T, N> const& R, AD<T, N> const& L)$/;"	f	namespace:mth
operator <	mth/mthAD.h	/^bool operator<(AD<T, N> const& R, double L)$/;"	f	namespace:mth
operator <	mth/mthAD.h	/^bool operator<(double L, AD<T, N> const& R)$/;"	f	namespace:mth
operator <	phasta/phBC.cc	/^bool BC::operator<(const BC& other) const$/;"	f	class:ph::BC
operator <	phasta/phBlock.cc	/^bool BlockKey::operator<(BlockKey const& other) const$/;"	f	class:ph::BlockKey
operator <	phasta/phBlock.cc	/^bool BlockKeyInterface::operator<(BlockKeyInterface const& other) const$/;"	f	class:ph::BlockKeyInterface
operator <	phasta/phLinks.cc	/^bool LinkKey::operator<(LinkKey const& other) const$/;"	f	class:ph::LinkKey
operator <	pumi/GenTag.cc	/^bool TagHandle::operator<(const TagHandle& other) const$/;"	f	class:TagHandle
operator <	test/capStoneAttachSolution.cc	/^  bool operator<(const SortingStruct &other) const$/;"	f	struct:SortingStruct
operator <	test/nektar_align.cc	/^  bool operator<(const VertId& other) const$/;"	f	struct:VertId
operator <<	apf/apfDynamicMatrix.cc	/^std::ostream& operator<<(std::ostream& s, apf::DynamicMatrix const& A)$/;"	f
operator <<	apf/apfDynamicVector.cc	/^std::ostream& operator<<(std::ostream& s, apf::DynamicVector const& x)$/;"	f
operator <<	apf/apfMatrix.h	/^std::ostream& operator<<(std::ostream& s, apf::Matrix<M,N> const& A)$/;"	f
operator <<	apf/apfVector.cc	/^std::ostream& operator<<(std::ostream& s, apf::Vector3 const& v)$/;"	f
operator <<	mth/mthMatrix.h	/^std::ostream& operator<<(std::ostream& s, mth::Matrix<T,M,N> const& a)$/;"	f
operator <<	mth/mthVector.h	/^std::ostream& operator<<(std::ostream& s, mth::Vector<T,N> const& a)$/;"	f
operator <<	phasta/phConstraint.cc	/^std::ostream& operator<<(std::ostream& s, ph::DebugConstraint const& dbg)$/;"	f
operator <=	mth/mthAD.h	/^bool operator<=(AD<T, N> const& R, AD<T, N> const& L)$/;"	f	namespace:mth
operator <=	mth/mthAD.h	/^bool operator<=(AD<T, N> const& R, double L)$/;"	f	namespace:mth
operator <=	mth/mthAD.h	/^bool operator<=(double L, AD<T, N> const& R)$/;"	f	namespace:mth
operator =	can/canArray.h	/^    Array<T,0>& operator=(Array<T,0> const& other)$/;"	f	class:can::Array
operator =	can/canArray.h	/^    Array<T,N>& operator=(Array<T,N> const& other)$/;"	f	class:can::Array
operator =	mth/mthAD.h	/^    AD<T, 0>& operator=(AD<B, 0> const& other)$/;"	f	class:mth::AD
operator =	mth/mthAD.h	/^    AD<T, 0>& operator=(double other)$/;"	f	class:mth::AD
operator =	mth/mthAD.h	/^    AD<T, N>& operator=(AD<B, N> const& other)$/;"	f	class:mth::AD
operator =	mth/mthAD.h	/^    AD<T, N>& operator=(AD<T, N> const& other)$/;"	f	class:mth::AD
operator =	mth/mthAD.h	/^    AD<T, N>& operator=(double other)$/;"	f	class:mth::AD
operator =	mth/mthTensor.h	/^    Tensor<T> operator=(Matrix<T> const& b)$/;"	f	class:mth::Tensor
operator =	mth/mthTensor.h	/^    Tensor<T>& operator=(Tensor<T> const& b)$/;"	f	class:mth::Tensor
operator =	pumi/GenIterator.h	/^    inline const GenIterator& operator=(const GenIterator<OtherIterator, Entity>& other)$/;"	f	class:GenIterator
operator ==	ma/maMatchedCollapse.cc	/^bool Rebuild::operator==(Rebuild const& other) const$/;"	f	class:ma::Rebuild
operator ==	phasta/phConstraint.cc	/^  bool operator==(PlaneConstraint const& other) const$/;"	f	struct:ph::PlaneConstraint
operator ==	phasta/phConstraint.cc	/^  bool operator==(PlaneConstraintElas const& other) const$/;"	f	struct:ph::PlaneConstraintElas
operator ==	pumi/GenIterator.h	/^  bool GenIterator<Iterator, Entity> :: operator == (GenIterator<Iterator, Entity> const & other) const$/;"	f	class:GenIterator
operator ==	pumi/pumi_list.h	/^    bool operator==(ListIterator<T> const& other) const$/;"	f	class:ListIterator
operator >	mth/mthAD.h	/^bool operator>(AD<T, N> const& R, AD<T, N> const& L)$/;"	f	namespace:mth
operator >	mth/mthAD.h	/^bool operator>(AD<T, N> const& R, double L)$/;"	f	namespace:mth
operator >	mth/mthAD.h	/^bool operator>(double L, AD<T, N> const& R)$/;"	f	namespace:mth
operator >=	mth/mthAD.h	/^bool operator>=(AD<T, N> const& R, AD<T, N> const& L)$/;"	f	namespace:mth
operator >=	mth/mthAD.h	/^bool operator>=(AD<T, N> const& R, double L)$/;"	f	namespace:mth
operator >=	mth/mthAD.h	/^bool operator>=(double L, AD<T, N> const& R)$/;"	f	namespace:mth
operator []	can/canArray.h	/^    T const& operator[](unsigned i) const {return elems[i];}$/;"	f	class:can::Array
operator []	can/canArray.h	/^    T& operator[](unsigned i) {return elems[i];}$/;"	f	class:can::Array
operator []	mds/apfBox.cc	/^int& Indices::operator[](int i)$/;"	f	class:apf::Indices
operator double	mth/mthAD.h	/^    operator double() const {return double(x_);}$/;"	f	class:mth::AD
oppEdges	crv/crvTables.h	/^static int const oppEdges[6] = {5,3,4,1,2,0};$/;"	m	namespace:crv
oppVert	ma/maShape.cc	/^    Entity *face, *oppVert;$/;"	m	class:ma::FaceVertFixer	file:
opposite	zoltan/apfZoltanMesh.h	/^    MeshTag* opposite;$/;"	m	class:apf::ZoltanMesh
ops	gmi/gmi.h	/^  struct gmi_model_ops const* ops;$/;"	m	struct:gmi_model
ops	gmi/gmi_analytic.c	/^static struct gmi_model_ops ops = {$/;"	v	typeref:struct:gmi_model_ops	file:
ops	gmi/gmi_null.c	/^static struct gmi_model_ops ops = {$/;"	v	typeref:struct:gmi_model_ops	file:
ops	gmi_cap/gmi_cap.cc	/^static struct gmi_model_ops ops;$/;"	v	typeref:struct:gmi_model_ops	file:
ops	gmi_sim/gmi_sim.cc	/^static struct gmi_model_ops ops;$/;"	v	typeref:struct:gmi_model_ops	file:
order	apf/apf.h	/^    int order;$/;"	m	class:apf::Integrator
order	apf/apfIPShape.cc	/^    int order;$/;"	m	class:apf::IPBase	file:
order	crv/crv.h	/^  int order;$/;"	m	class:crv::Quality
order	parma/diffMC/parma_monitor.cc	/^  const unsigned int order = 2;$/;"	m	namespace:__anon73	file:
order	pcu/pcu_msg.h	/^  struct pcu_order_struct* order;$/;"	m	struct:pcu_msg_struct	typeref:struct:pcu_msg_struct::pcu_order_struct
order	spr/sprRecoverField.cc	/^  int order;$/;"	m	struct:spr::Recovery	file:
order	test/fusion3.cc	/^  int order;$/;"	m	class:BSpline	file:
orderForPhasta	phasta/phAdjacent.cc	/^void orderForPhasta(int t, apf::MeshEntity** vin, apf::MeshEntity** vout)$/;"	f	namespace:ph
orderForPhastaInterface	phasta/phAdjacent.cc	/^void orderForPhastaInterface(int t, apf::MeshEntity** vin, apf::MeshEntity** vout, int offset)$/;"	f	namespace:ph
orient	ma/maEdgeSwap.cc	/^    void orient()$/;"	f	class:ma::EdgeSwap2D
origin	apf/apfGeometry.h	/^  Vector3 origin;$/;"	m	struct:apf::Line
original	ma/maMatchedCollapse.h	/^  Entity* original;$/;"	m	struct:ma::Rebuild
originalDirection_	phasta/phConstraint.cc	/^  apf::Vector3 originalDirection_;$/;"	m	struct:ph::PointConstraint	file:
originalDirection_	phasta/phConstraint.cc	/^  apf::Vector3 originalDirection_;$/;"	m	struct:ph::PointConstraintElas	file:
originalMain	phasta/phCook.cc	/^void originalMain(apf::Mesh2*& m, ph::Input& in,$/;"	f	namespace:__anon77
original_comm	pcu/pcu_pmpi.c	/^MPI_Comm original_comm;$/;"	v
orthogonalEigenDecompForSymmetricMatrix	ma/maSize.cc	/^static void orthogonalEigenDecompForSymmetricMatrix(Matrix const& A, Vector& v, Matrix& R)$/;"	f	namespace:ma
orthogonalizeR	ma/maSize.cc	/^static void orthogonalizeR(Matrix& R)$/;"	f	namespace:ma
other_vert	mds/mds_order.c	/^static mds_id other_vert(struct mds* m, mds_id e, mds_id v)$/;"	f	file:
others	ma/maSolutionTransfer.cc	/^    CavityTransfer others;$/;"	m	class:ma::HighOrderTransfer	file:
out	mds/apfBox.cc	/^Indices Grid::out(int i)$/;"	f	class:apf::Grid
outElement	apf/apfGradientByVolume.cc	/^    virtual void outElement()$/;"	f	class:apf::GradientIntegrator
outElement	apf/apfIntegrate.cc	/^void Integrator::outElement()$/;"	f	class:apf::Integrator
outElement	ma/maQuality.cc	/^    virtual void outElement()$/;"	f	class:ma::FixedMetricIntegrator
outElement	sam/samElementCount.cc	/^  virtual void outElement() {$/;"	f	class:sam::TotalMetricVolumeIso
outElement	spr/sprEstimateError.cc	/^    void outElement()$/;"	f	class:spr::ElementError
outElement	spr/sprEstimateError.cc	/^    void outElement()$/;"	f	class:spr::Error
outElement	spr/sprEstimateError.cc	/^    void outElement()$/;"	f	class:spr::Error2
outElement	spr/sprEstimateError.cc	/^    void outElement()$/;"	f	class:spr::SelfProduct
outElement	spr/sprEstimateTargetError.cc	/^    void outElement()$/;"	f	class:spr::target::ElementError
outElement	spr/sprEstimateTargetError.cc	/^    void outElement()$/;"	f	class:spr::target::GlobalErrorTerm
outElement	test/test_matrix_grad.cc	/^    virtual void outElement()$/;"	f	class:MatrixDerivIntegrator
outEntity	apf/apfField.cc	/^void FieldOp::outEntity()$/;"	f	class:apf::FieldOp
outEntity	apf/apfFieldOf.cc	/^    void outEntity()$/;"	f	class:apf::Project
outEntity	apf/apfHierarchic.cc	/^    void outEntity()$/;"	f	class:apf::Projector
outFile	test/collapse.cc	/^  const char* outFile = 0;$/;"	m	namespace:__anon6	file:
outFile	test/degenerateSurfs.cc	/^const char* outFile = 0;$/;"	v
outFile	test/fieldReduce.cc	/^const char* outFile = 0;$/;"	m	namespace:__anon15	file:
outFile	test/ptnParma.cc	/^const char* outFile = 0;$/;"	m	namespace:__anon10	file:
outFile	test/pumi.cc	/^const char* outFile = 0;$/;"	v
outFile	test/repartition.cc	/^const char* outFile = 0;$/;"	m	namespace:__anon22	file:
outFile	test/split.cc	/^const char* outFile = 0;$/;"	m	namespace:__anon13	file:
outFile	test/uniform.cc	/^const char* outFile = 0;$/;"	v
outFile	test/xgc_split.cc	/^const char* outFile = 0;$/;"	v
outFile	test/zsplit.cc	/^const char* outFile = 0;$/;"	m	namespace:__anon4	file:
outMesh	apf/apfConvert.cc	/^    Mesh2 *outMesh;$/;"	m	class:apf::Converter	file:
outMesh	phasta/migrate_interface.cc	/^  const char* outMesh = 0;$/;"	m	namespace:__anon78	file:
outMeshFile	test/generate.cc	/^std::string outMeshFile;$/;"	m	namespace:__anon19	file:
outMeshFileName	phasta/phInput.h	/^    std::string outMeshFileName;$/;"	m	class:ph::Input
outfile	phasta/cut_interface.cc	/^char const* outfile;$/;"	v
outmeshFilename	test/sim_part.cc	/^const char* outmeshFilename;$/;"	v
outmodelFilename	test/simDiscrete.cc	/^const char* outmodelFilename;$/;"	v
outputFormat	phasta/phInput.h	/^    std::string outputFormat;$/;"	m	class:ph::Input
overlapsSelf	ma/maMatchedCollapse.cc	/^bool MatchedCollapse::overlapsSelf()$/;"	f	class:ma::MatchedCollapse
overrideDiagonalsForUnsafeElements	ma/maTetrahedronize.cc	/^static void overrideDiagonalsForUnsafeElements(Adapt* a)$/;"	f	namespace:ma
overrideQuadDiagonal	ma/maTetrahedronize.cc	/^static void overrideQuadDiagonal(Adapt* a, Entity* quad, int diagonal)$/;"	f	namespace:ma
overwriteAPFCoord	test/ph_adapt.cc	/^static bool overwriteAPFCoord(apf::Mesh2* m) {$/;"	f	file:
ownBdryAvg	parma/extractParmaResults.py	/^ownBdryAvg = metric("ownedBoundaryVtxAvg")$/;"	v
ownBdryMax	parma/extractParmaResults.py	/^ownBdryMax = metric("ownedBoundaryVtxMax")$/;"	v
ownBdryMin	parma/extractParmaResults.py	/^ownBdryMin = metric("ownedBoundaryVtxMin")$/;"	v
ownBdryTot	parma/extractParmaResults.py	/^ownBdryTot = metric("ownedBoundaryVtxTotal")$/;"	v
owned	gmi_cap/gmi_cap.cc	/^  bool owned;$/;"	m	struct:cap_model	file:
owned	gmi_sim/gmi_sim.cc	/^  bool owned;$/;"	m	struct:sim_model	file:
ownedVtxWeight	parma/diffMC/parma_ghostMPASWeights.cc	/^  double ownedVtxWeight(apf::Mesh* m, apf::MeshTag* w) {$/;"	f	namespace:__anon61
ownedWeight	parma/diffMC/parma_ghostWeights.cc	/^  double ownedWeight(apf::Mesh* m, apf::MeshTag* w, int dim) {$/;"	f	namespace:__anon69
owned_import	gmi_sim/gmi_sim.cc	/^static gmi_model* owned_import(pGModel sm)$/;"	f	file:
owner	mds/apfPM.h	/^  int owner;$/;"	m	struct:apf::PME
owners_from_osh	omega_h/apfOmega_h.cc	/^static void owners_from_osh($/;"	f	namespace:apf
ownership	apf/apfCavityOp.cc	/^static int ownership(int a, int b)$/;"	f	namespace:apf
ownsModel	mds/apfMDS.cc	/^    bool ownsModel;$/;"	m	class:apf::MeshMDS	file:
ownsSizeField	ma/maInput.h	/^    bool ownsSizeField;$/;"	m	class:ma::Input
ownsSolutionTransfer	ma/maInput.h	/^    bool ownsSolutionTransfer;$/;"	m	class:ma::Input
owns_copies	mds/mds_apf.c	/^static int owns_copies(mds_id e, struct mds_copies* c)$/;"	f	file:
p	mds/mds_net.h	/^  int p;$/;"	m	struct:mds_copy
p	mds/mds_net.h	/^  unsigned* p;$/;"	m	struct:mds_links
pCopyIter	pumi/pumi.h	/^typedef apf::Copies::iterator pCopyIter;$/;"	t
pField	pumi/pumi.h	/^typedef apf::Field* pField;$/;"	t
pGeom	pumi/pumi.h	/^typedef gModel* pGeom;$/;"	t
pGeomEnt	pumi/pumi.h	/^typedef gEntity* pGeomEnt;$/;"	t
pGeomIter	pumi/pumi.h	/^typedef gModel::iterall pGeomIter;$/;"	t
pListToArray	apf_sim/apfSIM.cc	/^static int pListToArray(pPList list, MeshEntity** array)$/;"	f	namespace:apf
pListToDynamicArray	apf_sim/apfSIM.h	/^static void pListToDynamicArray(pPList list, DynamicArray<T>& array)$/;"	f	namespace:apf
pMesh	pumi/pumi.h	/^typedef apf::Mesh2* pMesh;$/;"	t
pMeshEnt	pumi/pumi.h	/^typedef apf::MeshEntity* pMeshEnt;$/;"	t
pMeshIter	pumi/pumi.h	/^typedef apf::MeshIterator* pMeshIter;$/;"	t
pMeshTag	pumi/pumi.h	/^typedef apf::MeshTag* pMeshTag;$/;"	t
pNumbering	pumi/pumi.h	/^typedef apf::Numbering* pNumbering;$/;"	t
pOwnership	pumi/pumi.h	/^typedef apf::Sharing* pOwnership;$/;"	t
pShape	pumi/pumi.h	/^typedef apf::FieldShape* pShape;$/;"	t
pTag	pumi/GenTag.h	/^typedef class TagHandle* pTag;$/;"	t	typeref:class:TagHandle
pTagHolder	pumi/GenTag.h	/^typedef class TagHolder* pTagHolder;$/;"	t	typeref:class:TagHolder
pTaggable	pumi/GenTag.h	/^typedef class Taggable* pTaggable;$/;"	t	typeref:class:Taggable
p_order	test/hierarchic.cc	/^    int p_order;$/;"	m	class:__anon20::L2Projector	file:
p_order	test/poisson.cc	/^    int p_order;$/;"	m	class:__anon17::Poisson	file:
packAlignment	apf/apfVerify.cc	/^static void packAlignment(Mesh* m, MeshEntity* e, MeshEntity* r, int to)$/;"	f	namespace:apf
packCommon	apf/apfMigrate.cc	/^static void packCommon($/;"	f	namespace:apf
packCopies	apf/apfMigrate.cc	/^static void packCopies($/;"	f	namespace:apf
packCopies	apf/apfVerify.cc	/^static void packCopies($/;"	f	namespace:apf
packDataClone	apf/apfMesh2.cc	/^void packDataClone(Mesh2* m, int to)$/;"	f	namespace:apf
packDownward	apf/apfMigrate.cc	/^static void packDownward(Mesh2* m, int to, MeshEntity* e)$/;"	f	namespace:apf
packEntity	apf/apfMigrate.cc	/^void packEntity($/;"	f	namespace:apf
packFieldClone	apf/apfMesh2.cc	/^static void packFieldClone(Field* f, int to)$/;"	f	namespace:apf
packFieldClones	apf/apfMesh2.cc	/^static void packFieldClones(Mesh2* m, int to)$/;"	f	namespace:apf
packFieldInfo	apf/apfVerify.cc	/^void packFieldInfo(Field* f, int to)$/;"	f	namespace:apf
packMeshShape	apf/apfMesh2.cc	/^static void packMeshShape(Mesh2* m, int to)$/;"	f	namespace:apf
packNonVertex	apf/apfMigrate.cc	/^static void packNonVertex($/;"	f	namespace:apf
packOtherGid	zoltan/apfInterElement.cc	/^static void packOtherGid(GlobalNumbering* gn, MeshEntity* s)$/;"	f	namespace:apf
packParts	apf/apfMigrate.cc	/^void packParts(int to, Parts& parts)$/;"	f	namespace:apf
packProposal	apf/apfMesh2.cc	/^static void packProposal(Mesh* m, MeshEntity* e, int to)$/;"	f	namespace:apf
packReference	apf/apfMigrate.cc	/^static void packReference($/;"	f	namespace:apf
packRemotes	apf/apfMigrate.cc	/^void packRemotes($/;"	f	namespace:apf
packSplits	ma/maMatch.cc	/^static void packSplits(int to, EntityArray& splits)$/;"	f	namespace:ma
packString	apf/apfMesh.cc	/^void packString(std::string s, int to)$/;"	f	namespace:apf
packTagClone	apf/apfMesh2.cc	/^static void packTagClone(Mesh2* m, MeshTag* t, int to)$/;"	f	namespace:apf
packTagClones	apf/apfMesh2.cc	/^static void packTagClones(Mesh2* m, int to)$/;"	f	namespace:apf
packTagInfo	apf/apfMesh.cc	/^void packTagInfo(Mesh* m, MeshTag* t, int to)$/;"	f	namespace:apf
packTags	apf/apfMigrate.cc	/^static void packTags($/;"	f	namespace:apf
packVertex	apf/apfMigrate.cc	/^static void packVertex($/;"	f	namespace:apf
pack_state	pcu/pcu_msg.c	/^  pack_state, \/\/after phase start, before sending$/;"	e	enum:__anon32	file:
paraExt	test/simTranslate.cc	/^static std::string paraExt = ".xmt_txt";$/;"	v	file:
paraExtshort	test/simTranslate.cc	/^static std::string paraExtshort = ".x_t";$/;"	v	file:
parallelReduce	apf/apfIntegrate.cc	/^void Integrator::parallelReduce()$/;"	f	class:apf::Integrator
parallelReduce	sam/samElementCount.cc	/^  virtual void parallelReduce() {$/;"	f	class:sam::TotalMetricVolumeIso
parallelReduce	spr/sprEstimateError.cc	/^    void parallelReduce()$/;"	f	class:spr::SInt
parallelReduce	spr/sprEstimateTargetError.cc	/^    void parallelReduce()$/;"	f	class:spr::target::ScalarIntegrator
parallelReduce	test/quality.cc	/^static void parallelReduce(apf::Mesh2* m)$/;"	f	namespace:__anon21
param	apf/apfIntegrate.h	/^  Vector3 param;$/;"	m	struct:apf::IntegrationPoint
param	mds/mds_apf.h	/^  double (*param)[2];$/;"	m	struct:mds_apf
parent	apf/apfElement.h	/^    VectorElement* parent;$/;"	m	class:apf::Element
parentMeasure	ma/maSize.cc	/^static double parentMeasure[apf::Mesh::TYPES] =$/;"	m	namespace:ma	file:
parentVtx	parma/diffMC/parma_dijkstra.cc	/^  apf::MeshEntity* parentVtx(apf::Mesh* m, parma::DijkstraContains* c,$/;"	f	namespace:__anon70
parma	parma/diffMC/parma_associative.h	/^namespace parma {$/;"	n
parma	parma/diffMC/parma_balancer.cc	/^namespace parma {$/;"	n	file:
parma	parma/diffMC/parma_balancer.h	/^namespace parma {$/;"	n
parma	parma/diffMC/parma_bdryVtx.cc	/^namespace parma {$/;"	n	file:
parma	parma/diffMC/parma_bdryVtx.h	/^namespace parma {$/;"	n
parma	parma/diffMC/parma_centroidSelector.cc	/^namespace parma {$/;"	n	file:
parma	parma/diffMC/parma_centroids.cc	/^namespace parma {  $/;"	n	file:
parma	parma/diffMC/parma_centroids.h	/^namespace parma {$/;"	n
parma	parma/diffMC/parma_components.cc	/^namespace parma {$/;"	n	file:
parma	parma/diffMC/parma_components.h	/^namespace parma {$/;"	n
parma	parma/diffMC/parma_dcpart.h	/^namespace parma {$/;"	n
parma	parma/diffMC/parma_dijkstra.cc	/^namespace parma {$/;"	n	file:
parma	parma/diffMC/parma_dijkstra.h	/^namespace parma {$/;"	n
parma	parma/diffMC/parma_distQ.h	/^namespace parma {$/;"	n
parma	parma/diffMC/parma_edgeEqVtxSelector.cc	/^namespace parma {$/;"	n	file:
parma	parma/diffMC/parma_elmBdrySides.cc	/^namespace parma {  $/;"	n	file:
parma	parma/diffMC/parma_elmLtVtxEdgeBalancer.cc	/^namespace parma {$/;"	n	file:
parma	parma/diffMC/parma_elmLtVtxEdgeSelector.cc	/^namespace parma {$/;"	n	file:
parma	parma/diffMC/parma_elmLtVtxEdgeTargets.cc	/^namespace parma {$/;"	n	file:
parma	parma/diffMC/parma_elmSelector.cc	/^namespace parma {$/;"	n	file:
parma	parma/diffMC/parma_elmSideSides.cc	/^namespace parma {  $/;"	n	file:
parma	parma/diffMC/parma_entWeights.cc	/^namespace parma {  $/;"	n	file:
parma	parma/diffMC/parma_entWeights.h	/^namespace parma {$/;"	n
parma	parma/diffMC/parma_ghostMPASWeights.cc	/^namespace parma {$/;"	n	file:
parma	parma/diffMC/parma_ghostOwner.cc	/^namespace parma {$/;"	n	file:
parma	parma/diffMC/parma_ghostOwner.h	/^namespace parma {$/;"	n
parma	parma/diffMC/parma_ghostWeights.cc	/^namespace parma {$/;"	n	file:
parma	parma/diffMC/parma_graphDist.cc	/^namespace parma {$/;"	n	file:
parma	parma/diffMC/parma_graphDist.h	/^namespace parma {$/;"	n
parma	parma/diffMC/parma_ltSelector.cc	/^namespace parma {$/;"	n	file:
parma	parma/diffMC/parma_monitor.cc	/^namespace parma {$/;"	n	file:
parma	parma/diffMC/parma_monitor.h	/^namespace parma {$/;"	n
parma	parma/diffMC/parma_preserveTargets.cc	/^namespace parma {$/;"	n	file:
parma	parma/diffMC/parma_selector.h	/^namespace parma {$/;"	n
parma	parma/diffMC/parma_shapeSelector.cc	/^namespace parma {$/;"	n	file:
parma	parma/diffMC/parma_shapeTargets.cc	/^namespace parma {$/;"	n	file:
parma	parma/diffMC/parma_sides.h	/^namespace parma {$/;"	n
parma	parma/diffMC/parma_step.cc	/^namespace parma {$/;"	n	file:
parma	parma/diffMC/parma_step.h	/^namespace parma {$/;"	n
parma	parma/diffMC/parma_stop.cc	/^namespace parma {$/;"	n	file:
parma	parma/diffMC/parma_stop.h	/^namespace parma {$/;"	n
parma	parma/diffMC/parma_targets.h	/^namespace parma {$/;"	n
parma	parma/diffMC/parma_vtxEdgeTargets.cc	/^namespace parma {$/;"	n	file:
parma	parma/diffMC/parma_vtxSelector.cc	/^namespace parma {$/;"	n	file:
parma	parma/diffMC/parma_vtxSelector.h	/^namespace parma {$/;"	n
parma	parma/diffMC/parma_vtxSides.cc	/^namespace parma {  $/;"	n	file:
parma	parma/diffMC/parma_weightSideTargets.cc	/^namespace parma {$/;"	n	file:
parma	parma/diffMC/parma_weightTargets.cc	/^namespace parma {$/;"	n	file:
parma	parma/diffMC/parma_weights.h	/^namespace parma {$/;"	n
parma	parma/rib/parma_mesh_rib.cc	/^namespace parma {$/;"	n	file:
parma	parma/rib/parma_rib.cc	/^namespace parma {$/;"	n	file:
parma	parma/rib/parma_rib.h	/^namespace parma {$/;"	n
parmaBalance	phasta/phPartition.cc	/^void parmaBalance(Input& in, apf::Mesh2* m, bool runGap) {$/;"	f	namespace:ph
parmaCommons	parma/diffMC/parma_commons.h	/^namespace parmaCommons {$/;"	n
parmaLogName	parma/extractParmaResults.py	/^parmaLogName = sys.argv[1]$/;"	v
parmaLoops	phasta/phInput.h	/^    int parmaLoops;$/;"	m	class:ph::Input
parmaMixed	phasta/phPartition.cc	/^void parmaMixed(Input& in, apf::Mesh2* m) {$/;"	f	namespace:ph
parmaTet	phasta/phPartition.cc	/^void parmaTet(Input& in, apf::Mesh2* m, bool runGap) {$/;"	f	namespace:ph
parmaVerbosity	phasta/phInput.h	/^    int parmaVerbosity;$/;"	m	class:ph::Input
parma_ordering	parma/diffMC/parma_graphDist.cc	/^namespace parma_ordering {$/;"	n	file:
parseElem	mds/mdsANSYS.cc	/^static bool parseElem(std::istream& f, int nodes[MAX_ELEM_NODES],$/;"	f	namespace:apf
parseElemInt	mds/mdsANSYS.cc	/^static void parseElemInt(std::string const& line, int at, int& out)$/;"	f	namespace:apf
parseElems	mds/mdsANSYS.cc	/^static Mesh2* parseElems(const char* elemfile, Nodes& nodes)$/;"	f	namespace:apf
parseNode	mds/mdsANSYS.cc	/^static bool parseNode(std::istream& f, int& id, apf::Vector3& p)$/;"	f	namespace:apf
parseNodes	mds/mdsANSYS.cc	/^static void parseNodes(const char* nodefile, Nodes& nodes)$/;"	f	namespace:apf
parse_header	phasta/phIO.c	/^static void parse_header(char* header, char** name, long* bytes,$/;"	f	file:
parse_params	phasta/phIO.c	/^static void parse_params(char* header, long* bytes,$/;"	f	file:
part	apf_sim/apfSIM.h	/^    pMesh part;$/;"	m	class:apf::MeshSIM
partId	parma/diffMC/maximalIndependentSet/mis.h	/^        int partId;$/;"	m	struct:misLuby::AdjPart
partInfo	parma/diffMC/maximalIndependentSet/mis.h	/^    } partInfo;$/;"	t	namespace:misLuby	typeref:struct:misLuby::PartInfo
part_iter	pumi/pumi_iter.h	/^typedef mPartEntityContainer::iter part_iter;$/;"	t
partelm	mds/mdsUgrid.cc	/^      int* partelm;     \/\/elm cnts$/;"	m	class:__anon101::ptnstats	file:
partelmW	mds/mdsUgrid.cc	/^      double* partelmW; \/\/weighted elm counts$/;"	m	class:__anon101::ptnstats	file:
partitionFactor	test/collapse.cc	/^  int partitionFactor = 1;$/;"	m	namespace:__anon6	file:
partitionFactor	test/ptnParma.cc	/^int partitionFactor = 1;$/;"	m	namespace:__anon10	file:
partitionFactor	test/split.cc	/^int partitionFactor = 1;$/;"	m	namespace:__anon13	file:
partitionFactor	test/zsplit.cc	/^int partitionFactor = 1;$/;"	m	namespace:__anon4	file:
partitionMethod	phasta/phInput.h	/^    std::string partitionMethod;$/;"	m	class:ph::Input
parts	mds/mds_apf.h	/^  void** parts[MDS_TYPES];$/;"	m	struct:mds_apf
parts_index_tag	pumi/pumi.h	/^    pMeshTag parts_index_tag;$/;"	m	class:Ghosting
parts_vec	pumi/pumi.h	/^    Parts* parts_vec;$/;"	m	class:Distribution
parts_vec	pumi/pumi.h	/^    std::vector<Parts*> parts_vec[4];$/;"	m	class:Ghosting
partvtx	mds/mdsUgrid.cc	/^      SetInt* partvtx;  \/\/vtx ids for each part$/;"	m	class:__anon101::ptnstats	file:
pass_info_to_phasta	phasta/phSnap.cc	/^void pass_info_to_phasta(apf::Mesh2* mesh, ph::Input& ctrl){$/;"	f
patch	spr/sprRecoverField.cc	/^  Patch patch;$/;"	m	class:spr::PatchOp	file:
pattern	pcu/pcu_coll.h	/^  pcu_pattern* pattern; \/\/communication pattern controller$/;"	m	struct:__anon40
pcs	phasta/phConstraint.cc	/^  PlaneConstraint* pcs[2];$/;"	m	struct:ph::LineConstraint	file:
pcs	phasta/phConstraint.cc	/^  PlaneConstraintElas* pcs[2];$/;"	m	struct:ph::LineConstraintElas	file:
pcu_aa_bottom	pcu/pcu_aa.c	/^static pcu_aa_node pcu_aa_bottom = $/;"	v	file:
pcu_aa_count	pcu/pcu_aa.c	/^int pcu_aa_count(pcu_aa_tree t)$/;"	f
pcu_aa_empty	pcu/pcu_aa.c	/^bool pcu_aa_empty(pcu_aa_tree t)$/;"	f
pcu_aa_find	pcu/pcu_aa.c	/^pcu_aa_node* pcu_aa_find(pcu_aa_node* x, pcu_aa_tree t, pcu_aa_less* less)$/;"	f
pcu_aa_insert	pcu/pcu_aa.c	/^pcu_aa_node* pcu_aa_insert(pcu_aa_node* x, pcu_aa_tree* t, pcu_aa_less* less)$/;"	f
pcu_aa_less	pcu/pcu_aa.h	/^typedef bool pcu_aa_less(pcu_aa_node* a, pcu_aa_node* b);$/;"	t
pcu_aa_node	pcu/pcu_aa.h	/^typedef struct pcu_aa_node_struct pcu_aa_node;$/;"	t	typeref:struct:pcu_aa_node_struct
pcu_aa_node_struct	pcu/pcu_aa.h	/^struct pcu_aa_node_struct$/;"	s
pcu_aa_remove	pcu/pcu_aa.c	/^pcu_aa_node* pcu_aa_remove(pcu_aa_node* x, pcu_aa_tree* t, pcu_aa_less* less)$/;"	f
pcu_aa_tree	pcu/pcu_aa.h	/^typedef struct pcu_aa_node_struct* pcu_aa_tree;$/;"	t	typeref:struct:pcu_aa_node_struct
pcu_add_doubles	pcu/pcu_coll.c	/^void pcu_add_doubles(void* local, void* incoming, size_t size)$/;"	f
pcu_add_ints	pcu/pcu_coll.c	/^void pcu_add_ints(void* local, void* incoming, size_t size)$/;"	f
pcu_add_longs	pcu/pcu_coll.c	/^void pcu_add_longs(void* local, void* incoming, size_t size)$/;"	f
pcu_add_sizets	pcu/pcu_coll.c	/^void pcu_add_sizets(void* local, void* incoming, size_t size)$/;"	f
pcu_allreduce	pcu/pcu_coll.c	/^void pcu_allreduce(pcu_coll* c, pcu_merge* m, void* data, size_t size)$/;"	f
pcu_barrier	pcu/pcu_coll.c	/^void pcu_barrier(pcu_coll* c)$/;"	f
pcu_barrier_done	pcu/pcu_coll.c	/^bool pcu_barrier_done(pcu_coll* c)$/;"	f
pcu_bcast	pcu/pcu_coll.c	/^void pcu_bcast(pcu_coll* c, void* data, size_t size)$/;"	f
pcu_begin_barrier	pcu/pcu_coll.c	/^void pcu_begin_barrier(pcu_coll* c)$/;"	f
pcu_begin_buffer	pcu/pcu_buffer.c	/^void pcu_begin_buffer(pcu_buffer* b)$/;"	f
pcu_begin_coll	pcu/pcu_coll.c	/^void pcu_begin_coll(pcu_coll* c, void* data, size_t size)$/;"	f
pcu_buffer	pcu/pcu_buffer.h	/^} pcu_buffer;$/;"	t	typeref:struct:__anon36
pcu_buffer_walked	pcu/pcu_buffer.c	/^bool pcu_buffer_walked(pcu_buffer* b)$/;"	f
pcu_coll	pcu/pcu_coll.h	/^} pcu_coll;$/;"	t	typeref:struct:__anon40
pcu_coll_comm	pcu/pcu_pmpi.c	/^MPI_Comm pcu_coll_comm;$/;"	v
pcu_coll_idle	pcu/pcu_coll.h	/^  pcu_coll_idle$/;"	e	enum:__anon38
pcu_coll_recv	pcu/pcu_coll.h	/^  pcu_coll_recv,$/;"	e	enum:__anon38
pcu_coll_send	pcu/pcu_coll.h	/^  pcu_coll_send,$/;"	e	enum:__anon38
pcu_endian_value	pcu/pcu_io.c	/^static const uint16_t pcu_endian_value = 1;$/;"	v	file:
pcu_fclose	pcu/pcu_io.c	/^void pcu_fclose(pcu_file* pf)$/;"	f
pcu_file	pcu/pcu_io.c	/^typedef struct pcu_file {$/;"	s	file:
pcu_file	pcu/pcu_io.c	/^} pcu_file;$/;"	t	typeref:struct:pcu_file	file:
pcu_fopen	pcu/pcu_io.c	/^pcu_file* pcu_fopen(const char* name, bool write, bool compress)$/;"	f
pcu_fread	pcu/pcu_io.c	/^void pcu_fread(void* p, size_t size, size_t nmemb, pcu_file * f)$/;"	f
pcu_free_buffer	pcu/pcu_buffer.c	/^void pcu_free_buffer(pcu_buffer* b)$/;"	f
pcu_free_message	pcu/pcu_mpi.c	/^void pcu_free_message(pcu_message* m)$/;"	f
pcu_free_msg	pcu/pcu_msg.c	/^void pcu_free_msg(pcu_msg* m)$/;"	f
pcu_fwrite	pcu/pcu_io.c	/^void pcu_fwrite(void const* p, size_t size, size_t nmemb, pcu_file * f)$/;"	f
pcu_get_mpi	pcu/pcu_mpi.c	/^pcu_mpi* pcu_get_mpi(void)$/;"	f
pcu_group_open	pcu/pcu_io.c	/^FILE* pcu_group_open(const char* path, bool write) {$/;"	f
pcu_host_order	pcu/pcu_byteorder.h	/^} pcu_host_order = { { 0, 1, 2, 3 } };$/;"	v	typeref:union:__anon42
pcu_make_aa	pcu/pcu_aa.c	/^void pcu_make_aa(pcu_aa_tree* t)$/;"	f
pcu_make_buffer	pcu/pcu_buffer.c	/^void pcu_make_buffer(pcu_buffer* b)$/;"	f
pcu_make_coll	pcu/pcu_coll.c	/^void pcu_make_coll(pcu_coll* c, pcu_pattern* p, pcu_merge* m)$/;"	f
pcu_make_message	pcu/pcu_mpi.c	/^void pcu_make_message(pcu_message* m)$/;"	f
pcu_make_msg	pcu/pcu_msg.c	/^void pcu_make_msg(pcu_msg* m)$/;"	f
pcu_max_doubles	pcu/pcu_coll.c	/^void pcu_max_doubles(void* local, void* incoming, size_t size)$/;"	f
pcu_max_ints	pcu/pcu_coll.c	/^void pcu_max_ints(void* local, void* incoming, size_t size)$/;"	f
pcu_max_sizets	pcu/pcu_coll.c	/^void pcu_max_sizets(void* local, void* incoming, size_t size)$/;"	f
pcu_merge	pcu/pcu_coll.h	/^typedef void pcu_merge(void* local, void* incoming, size_t size);$/;"	t
pcu_merge_assign	pcu/pcu_coll.c	/^void pcu_merge_assign(void* local, void* incoming, size_t size)$/;"	f
pcu_message	pcu/pcu_mpi.h	/^} pcu_message;$/;"	t	typeref:struct:__anon33
pcu_min_doubles	pcu/pcu_coll.c	/^void pcu_min_doubles(void* local, void* incoming, size_t size)$/;"	f
pcu_min_ints	pcu/pcu_coll.c	/^void pcu_min_ints(void* local, void* incoming, size_t size)$/;"	f
pcu_min_sizets	pcu/pcu_coll.c	/^void pcu_min_sizets(void* local, void* incoming, size_t size)$/;"	f
pcu_mpi	pcu/pcu_mpi.h	/^} pcu_mpi;$/;"	t	typeref:struct:__anon34
pcu_mpi_done	pcu/pcu_mpi.c	/^bool pcu_mpi_done(pcu_message* m)$/;"	f
pcu_mpi_rank	pcu/pcu_mpi.c	/^int pcu_mpi_rank(void)$/;"	f
pcu_mpi_receive	pcu/pcu_mpi.c	/^bool pcu_mpi_receive(pcu_message* m, MPI_Comm comm)$/;"	f
pcu_mpi_send	pcu/pcu_mpi.c	/^void pcu_mpi_send(pcu_message* m, MPI_Comm comm)$/;"	f
pcu_mpi_size	pcu/pcu_mpi.c	/^int pcu_mpi_size(void)$/;"	f
pcu_msg	pcu/pcu_msg.h	/^typedef struct pcu_msg_struct pcu_msg;$/;"	t	typeref:struct:pcu_msg_struct
pcu_msg_pack	pcu/pcu_msg.c	/^void* pcu_msg_pack(pcu_msg* m, int id, size_t size)$/;"	f
pcu_msg_packed	pcu/pcu_msg.c	/^size_t pcu_msg_packed(pcu_msg* m, int id)$/;"	f
pcu_msg_peer	pcu/pcu_msg.h	/^} pcu_msg_peer;$/;"	t	typeref:struct:__anon35
pcu_msg_receive	pcu/pcu_msg.c	/^bool pcu_msg_receive(pcu_msg* m)$/;"	f
pcu_msg_received_from	pcu/pcu_msg.c	/^int pcu_msg_received_from(pcu_msg* m)$/;"	f
pcu_msg_received_size	pcu/pcu_msg.c	/^size_t pcu_msg_received_size(pcu_msg* m)$/;"	f
pcu_msg_send	pcu/pcu_msg.c	/^void pcu_msg_send(pcu_msg* m)$/;"	f
pcu_msg_start	pcu/pcu_msg.c	/^void pcu_msg_start(pcu_msg* m)$/;"	f
pcu_msg_struct	pcu/pcu_msg.h	/^struct pcu_msg_struct$/;"	s
pcu_msg_unpack	pcu/pcu_msg.c	/^void* pcu_msg_unpack(pcu_msg* m, size_t size)$/;"	f
pcu_msg_unpacked	pcu/pcu_msg.c	/^bool pcu_msg_unpacked(pcu_msg* m)$/;"	f
pcu_open_parallel	pcu/pcu_io.c	/^FILE* pcu_open_parallel(const char* prefix, const char* ext)$/;"	f
pcu_order	pcu/pcu_order.h	/^typedef struct pcu_order_struct* pcu_order;$/;"	t	typeref:struct:pcu_order_struct
pcu_order_free	pcu/pcu_order.c	/^void pcu_order_free(pcu_order o)$/;"	f
pcu_order_new	pcu/pcu_order.c	/^pcu_order pcu_order_new(void)$/;"	f
pcu_order_receive	pcu/pcu_order.c	/^bool pcu_order_receive(pcu_order o, pcu_msg* m)$/;"	f
pcu_order_received_from	pcu/pcu_order.c	/^int pcu_order_received_from(pcu_order o)$/;"	f
pcu_order_received_size	pcu/pcu_order.c	/^size_t pcu_order_received_size(pcu_order o)$/;"	f
pcu_order_struct	pcu/pcu_order.c	/^struct pcu_order_struct {$/;"	s	file:
pcu_order_unpack	pcu/pcu_order.c	/^void* pcu_order_unpack(pcu_order o, size_t size)$/;"	f
pcu_order_unpacked	pcu/pcu_order.c	/^bool pcu_order_unpacked(pcu_order o)$/;"	f
pcu_pattern	pcu/pcu_coll.h	/^} pcu_pattern;$/;"	t	typeref:struct:__anon39
pcu_pmpi	pcu/pcu_pmpi.c	/^pcu_mpi pcu_pmpi =$/;"	v
pcu_pmpi_comm	pcu/pcu_pmpi.c	/^MPI_Comm pcu_pmpi_comm(void)$/;"	f
pcu_pmpi_done	pcu/pcu_pmpi.c	/^bool pcu_pmpi_done(pcu_message* m)$/;"	f
pcu_pmpi_finalize	pcu/pcu_pmpi.c	/^void pcu_pmpi_finalize(void)$/;"	f
pcu_pmpi_init	pcu/pcu_pmpi.c	/^void pcu_pmpi_init(MPI_Comm comm)$/;"	f
pcu_pmpi_rank	pcu/pcu_pmpi.c	/^int pcu_pmpi_rank(void)$/;"	f
pcu_pmpi_receive	pcu/pcu_pmpi.c	/^bool pcu_pmpi_receive(pcu_message* m, MPI_Comm comm)$/;"	f
pcu_pmpi_receive2	pcu/pcu_pmpi.c	/^bool pcu_pmpi_receive2(pcu_message* m, int tag, MPI_Comm comm)$/;"	f
pcu_pmpi_send	pcu/pcu_pmpi.c	/^void pcu_pmpi_send(pcu_message* m, MPI_Comm comm)$/;"	f
pcu_pmpi_send2	pcu/pcu_pmpi.c	/^void pcu_pmpi_send2(pcu_message* m, int tag, MPI_Comm comm)$/;"	f
pcu_pmpi_size	pcu/pcu_pmpi.c	/^int pcu_pmpi_size(void)$/;"	f
pcu_pmpi_switch	pcu/pcu_pmpi.c	/^void pcu_pmpi_switch(MPI_Comm new_comm)$/;"	f
pcu_progress_coll	pcu/pcu_coll.c	/^bool pcu_progress_coll(pcu_coll* c)$/;"	f
pcu_push_buffer	pcu/pcu_buffer.c	/^void* pcu_push_buffer(pcu_buffer* b, size_t size)$/;"	f
pcu_read	pcu/pcu_io.c	/^void pcu_read(pcu_file* f, char* p, size_t n)$/;"	f
pcu_read_doubles	pcu/pcu_io.c	/^void pcu_read_doubles(pcu_file* f, double* p, size_t n)$/;"	f
pcu_read_string	pcu/pcu_io.c	/^void pcu_read_string (pcu_file* f, char ** p)$/;"	f
pcu_read_unsigneds	pcu/pcu_io.c	/^void pcu_read_unsigneds(pcu_file* f, unsigned* p, size_t n)$/;"	f
pcu_reduce	pcu/pcu_coll.c	/^void pcu_reduce(pcu_coll* c, pcu_merge* m, void* data, size_t size)$/;"	f
pcu_resize_buffer	pcu/pcu_buffer.c	/^void pcu_resize_buffer(pcu_buffer* b, size_t size)$/;"	f
pcu_scan	pcu/pcu_coll.c	/^void pcu_scan(pcu_coll* c, pcu_merge* m, void* data, size_t size)$/;"	f
pcu_set_buffer	pcu/pcu_buffer.c	/^void pcu_set_buffer(pcu_buffer* b, void* p, size_t size)$/;"	f
pcu_set_mpi	pcu/pcu_mpi.c	/^void pcu_set_mpi(pcu_mpi* m)$/;"	f
pcu_swap_16	pcu/pcu_io.c	/^static void pcu_swap_16(uint16_t* p)$/;"	f	file:
pcu_swap_32	pcu/pcu_io.c	/^static void pcu_swap_32(uint32_t* p)$/;"	f	file:
pcu_swap_64	pcu/pcu_io.c	/^static void pcu_swap_64(uint32_t* p)$/;"	f	file:
pcu_swap_doubles	pcu/pcu_io.c	/^void pcu_swap_doubles(double* p, size_t n)$/;"	f
pcu_swap_unsigneds	pcu/pcu_io.c	/^void pcu_swap_unsigneds(unsigned* p, size_t n)$/;"	f
pcu_user_comm	pcu/pcu_pmpi.c	/^MPI_Comm pcu_user_comm;$/;"	v
pcu_walk_buffer	pcu/pcu_buffer.c	/^void* pcu_walk_buffer(pcu_buffer* b, size_t size)$/;"	f
pcu_write	pcu/pcu_io.c	/^void pcu_write(pcu_file* f, const char* p, size_t n)$/;"	f
pcu_write_doubles	pcu/pcu_io.c	/^void pcu_write_doubles(pcu_file* f, double* p, size_t n)$/;"	f
pcu_write_string	pcu/pcu_io.c	/^void pcu_write_string (pcu_file * f, const char * p)$/;"	f
pcu_write_unsigneds	pcu/pcu_io.c	/^void pcu_write_unsigneds(pcu_file* f, unsigned* p, size_t n)$/;"	f
peer	apf/apfMesh.h	/^  int peer;$/;"	m	struct:apf::Copy
peer	pcu/pcu_coll.h	/^  int (*peer)(int bit); \/\/return the peer to communicate with$/;"	m	struct:__anon39
peer	pcu/pcu_mpi.h	/^  int peer;$/;"	m	struct:__anon33
peer	phasta/phLinks.h	/^  int peer;$/;"	m	struct:ph::LinkKey
peer_less	pcu/pcu_msg.c	/^static bool peer_less(pcu_aa_node* a, pcu_aa_node* b)$/;"	f	file:
peers	pcu/pcu_msg.h	/^  pcu_aa_tree peers; \/\/binary tree of send buffers$/;"	m	struct:pcu_msg_struct
periodic	gmi/gmi.h	/^  int (*periodic)(struct gmi_model* m, struct gmi_ent* e, int dim);$/;"	m	struct:gmi_model_ops
periodic	gmi/gmi_analytic.c	/^  struct agm_tag* periodic;$/;"	m	struct:gmi_analytic	typeref:struct:gmi_analytic::agm_tag	file:
periodic	gmi/gmi_analytic.c	/^static int periodic(struct gmi_model* m, struct gmi_ent* e, int dim)$/;"	f	file:
periodic	gmi_cap/gmi_cap.cc	/^static int periodic(struct gmi_model* m, struct gmi_ent* e, int dim)$/;"	f	file:
periodic	gmi_sim/gmi_sim.cc	/^static int periodic(struct gmi_model* m, struct gmi_ent* e, int dim)$/;"	f	file:
periodic	phasta/phInput.h	/^    int periodic;$/;"	m	class:ph::Input
periodic_of	gmi/gmi_analytic.c	/^static periodic_t* periodic_of(struct gmi_analytic* m, struct agm_ent e)$/;"	f	file:
periodic_t	gmi/gmi_analytic.c	/^typedef uint8_t periodic_t[2];$/;"	t	file:
pf	apf_sim/apfSIMDataOf.h	/^  pPolyField pf;$/;"	m	class:apf::SIMDataOf
pf	parma/diffMC/parma_dcpart.h	/^    PartFixer* pf;$/;"	m	class:dcPartFixer
ph	phasta/ph.cc	/^namespace ph {$/;"	n	file:
ph	phasta/ph.h	/^namespace ph {$/;"	n
ph	phasta/phAdapt.cc	/^namespace ph {$/;"	n	file:
ph	phasta/phAdapt.h	/^namespace ph {$/;"	n
ph	phasta/phAdjacent.cc	/^namespace ph {$/;"	n	file:
ph	phasta/phAdjacent.h	/^namespace ph {$/;"	n
ph	phasta/phAttrib.h	/^namespace ph {$/;"	n
ph	phasta/phAxisymmetry.cc	/^namespace ph {$/;"	n	file:
ph	phasta/phAxisymmetry.h	/^namespace ph {$/;"	n
ph	phasta/phBC.cc	/^namespace ph {$/;"	n	file:
ph	phasta/phBC.h	/^namespace ph {$/;"	n
ph	phasta/phBlock.cc	/^namespace ph {$/;"	n	file:
ph	phasta/phBlock.h	/^namespace ph {$/;"	n
ph	phasta/phBubble.cc	/^namespace ph {$/;"	n	file:
ph	phasta/phBubble.h	/^namespace ph {$/;"	n
ph	phasta/phConstraint.cc	/^namespace ph {$/;"	n	file:
ph	phasta/phCook.cc	/^namespace ph {$/;"	n	file:
ph	phasta/phFilterMatching.cc	/^namespace ph {$/;"	n	file:
ph	phasta/phFilterMatching.h	/^namespace ph {$/;"	n
ph	phasta/phGeomBC.cc	/^namespace ph {$/;"	n	file:
ph	phasta/phGrowthCurves.cc	/^namespace ph {$/;"	n	file:
ph	phasta/phGrowthCurves.h	/^namespace ph {$/;"	n
ph	phasta/phGrowthCurves_empty.cc	/^namespace ph {$/;"	n	file:
ph	phasta/phInput.cc	/^namespace ph {$/;"	n	file:
ph	phasta/phInput.h	/^namespace ph {$/;"	n
ph	phasta/phInterfaceCutter.cc	/^namespace ph {$/;"	n	file:
ph	phasta/phInterfaceCutter.h	/^namespace ph {$/;"	n
ph	phasta/phLinks.cc	/^namespace ph {$/;"	n	file:
ph	phasta/phLinks.h	/^namespace ph {$/;"	n
ph	phasta/phMeshQuality.cc	/^namespace ph {$/;"	n	file:
ph	phasta/phModelGeometry.cc	/^namespace ph {$/;"	n	file:
ph	phasta/phModelGeometry.h	/^namespace ph {$/;"	n
ph	phasta/phOutput.cc	/^namespace ph {$/;"	n	file:
ph	phasta/phOutput.h	/^namespace ph {$/;"	n
ph	phasta/phPartition.cc	/^namespace ph {$/;"	n	file:
ph	phasta/phPartition.h	/^namespace ph {$/;"	n
ph	phasta/phRestart.cc	/^namespace ph {$/;"	n	file:
ph	phasta/phRestart.h	/^namespace ph {$/;"	n
ph	phasta/phastaChef.h	/^namespace ph {$/;"	n
ph	phasta/splitMeshOnGFace.h	/^namespace ph {$/;"	n
ph_read_field	phasta/phIO.c	/^int ph_read_field(FILE* f, const char* field, int swap,$/;"	f
ph_should_swap	phasta/phIO.c	/^int ph_should_swap(FILE* f) {$/;"	f
ph_write_doubles	phasta/phIO.c	/^void ph_write_doubles(FILE* f, const char* name, double* data,$/;"	f
ph_write_field	phasta/phIO.c	/^void ph_write_field(FILE* f, const char* field, double* data,$/;"	f
ph_write_header	phasta/phIO.c	/^void ph_write_header(FILE* f, const char* name, size_t bytes,$/;"	f
ph_write_ints	phasta/phIO.c	/^void ph_write_ints(FILE* f, const char* name, int* data,$/;"	f
ph_write_preamble	phasta/phIO.c	/^void ph_write_preamble(FILE* f)$/;"	f
phastaIO	phasta/phInput.h	/^    int phastaIO;$/;"	m	class:ph::Input
phastaioTime	phasta/phiotimer.h	/^typedef double phastaioTime;$/;"	t
phastaioTime	phasta/phiotimer.h	/^typedef size_t phastaioTime;$/;"	t
phastaioTime	phasta/phiotimer.h	/^typedef struct timespec phastaioTime;$/;"	t	typeref:struct:timespec
phastaio_addCloseTime	phasta/phiotimer.cc	/^void phastaio_addCloseTime(size_t t) {$/;"	f
phastaio_addOpenTime	phasta/phiotimer.cc	/^void phastaio_addOpenTime(size_t t) {$/;"	f
phastaio_addReadBytes	phasta/phiotimer.cc	/^void phastaio_addReadBytes(size_t b) {$/;"	f
phastaio_addReadTime	phasta/phiotimer.cc	/^void phastaio_addReadTime(size_t t) {$/;"	f
phastaio_addWriteBytes	phasta/phiotimer.cc	/^void phastaio_addWriteBytes(size_t b) {$/;"	f
phastaio_addWriteTime	phasta/phiotimer.cc	/^void phastaio_addWriteTime(size_t t) {$/;"	f
phastaio_file	phasta/phiotimer.h	/^enum phastaio_file {$/;"	g
phastaio_getCloseTime	phasta/phiotimer.cc	/^static size_t phastaio_getCloseTime() {$/;"	f	file:
phastaio_getCloses	phasta/phiotimer.cc	/^static size_t phastaio_getCloses() {$/;"	f	file:
phastaio_getCyclesPerMicroSec	phasta/phiotimer.cc	/^static size_t phastaio_getCyclesPerMicroSec() {$/;"	f	file:
phastaio_getOpenTime	phasta/phiotimer.cc	/^static size_t phastaio_getOpenTime() {$/;"	f	file:
phastaio_getOpens	phasta/phiotimer.cc	/^static size_t phastaio_getOpens() {$/;"	f	file:
phastaio_getReadBytes	phasta/phiotimer.cc	/^static size_t phastaio_getReadBytes() {$/;"	f	file:
phastaio_getReadTime	phasta/phiotimer.cc	/^static size_t phastaio_getReadTime() {$/;"	f	file:
phastaio_getReads	phasta/phiotimer.cc	/^static size_t phastaio_getReads() {$/;"	f	file:
phastaio_getWriteBytes	phasta/phiotimer.cc	/^static size_t phastaio_getWriteBytes() {$/;"	f	file:
phastaio_getWriteTime	phasta/phiotimer.cc	/^static size_t phastaio_getWriteTime() {$/;"	f	file:
phastaio_getWrites	phasta/phiotimer.cc	/^static size_t phastaio_getWrites() {$/;"	f	file:
phastaio_global_stats	phasta/phiotimer.cc	/^static struct phastaio_stats phastaio_global_stats;$/;"	v	typeref:struct:phastaio_stats	file:
phastaio_initStats	phasta/phiotimer.cc	/^void phastaio_initStats() {$/;"	f
phastaio_printStats	phasta/phiotimer.cc	/^void phastaio_printStats() {$/;"	f
phastaio_setfile	phasta/phiotimer.cc	/^void phastaio_setfile(int f) {$/;"	f
phastaio_stats	phasta/phiotimer.cc	/^struct phastaio_stats {$/;"	s	file:
phastaio_time	phasta/phiotimer.cc	/^void phastaio_time(phastaioTime* t) {$/;"	f
phastaio_time_diff	phasta/phiotimer.cc	/^size_t phastaio_time_diff(phastaioTime* start, phastaioTime* end) {$/;"	f
phiotimer	phasta/phiotimer.f	/^      module phiotimer$/;"	m
pi	apf/apfVector.cc	/^double const pi = 3.14159265358979323846;$/;"	m	namespace:apf	file:
pi	test/poisson.cc	/^static double const pi = 3.14159265358979323846;$/;"	m	namespace:__anon17	file:
plan	ma/maLayerCoarsen.cc	/^  apf::Migration* plan;$/;"	m	struct:ma::CurveLocalizer	file:
plan	parma/group/parma_group.cc	/^  apf::Migration* plan;$/;"	m	struct:RetreatCode	file:
planExpansion	parma/group/parma_group.cc	/^static apf::Migration* planExpansion(apf::Mesh* m, int factor)$/;"	f	file:
planLayerCollapseMigration	ma/maLayerCoarsen.cc	/^static apf::Migration* planLayerCollapseMigration(Adapt* a, int d, int round)$/;"	f	namespace:ma
plane	phasta/phConstraint.cc	/^  apf::Plane plane;$/;"	m	struct:ph::PlaneConstraint	file:
plane	phasta/phConstraint.cc	/^  apf::Plane plane;$/;"	m	struct:ph::PlaneConstraintElas	file:
plist_to_set	gmi_sim/gmi_sim.cc	/^static gmi_set* plist_to_set(pPList l)$/;"	f	file:
plot	parma/extractParmaResults.py	/^def plot(dat, xlabel, ylabel, name, title):$/;"	f
plot2	parma/extractParmaResults.py	/^def plot2(dat, axis, xlabel, ylabel, name, title):$/;"	f
plt	parma/extractParmaResults.py	/^import matplotlib.pyplot as plt$/;"	i
pmodel	mds/apfMDS.cc	/^    PM pmodel;$/;"	m	class:apf::MeshMDS	file:
point	apf/apfVtk.cc	/^    int point;$/;"	m	class:apf::WriteIPField	file:
point	mds/mdsGmsh.cc	/^  apf::Vector3 point;$/;"	m	struct:__anon96::Node	file:
point	mds/mds_apf.h	/^  double (*point)[3];$/;"	m	struct:mds_apf
point	parma/rib/parma_rib.h	/^  mth::Vector3<double> point;$/;"	m	struct:parma::Body
point	phasta/phConstraint.cc	/^  apf::Vector3 point;$/;"	m	struct:ph::PointConstraint	file:
point	phasta/phConstraint.cc	/^  apf::Vector3 point;$/;"	m	struct:ph::PointConstraintElas	file:
points	apf/apfIPShape.cc	/^        can::Array<Vector3> points;$/;"	m	class:apf::VoronoiShape::Element	file:
points	spr/sprRecoverField.cc	/^  apf::NewArray<apf::Vector3> points;$/;"	m	struct:spr::Samples	file:
points	test/shapefun2.cc	/^static apf::Vector3 const* const points[apf::Mesh::TYPES] =$/;"	m	class:test::apf	file:
points3D	test/bezierElevation.cc	/^static apf::Vector3 points3D[4] =$/;"	v	file:
points3D	test/bezierMisc.cc	/^static apf::Vector3 points3D[4] =$/;"	v	file:
points3D	test/bezierSubdivision.cc	/^static apf::Vector3 points3D[4] =$/;"	v	file:
points_per_element	spr/sprRecoverField.cc	/^  int points_per_element;$/;"	m	struct:spr::Recovery	file:
polynomialOrder	phasta/phBlock.h	/^  int polynomialOrder;$/;"	m	struct:ph::BlockKey
polynomial_terms	spr/sprRecoverField.cc	/^  int polynomial_terms;$/;"	m	struct:spr::Recovery	file:
pop	dsp/dspGraphDistance.cc	/^static apf::MeshEntity* pop(std::vector<apf::MeshEntity*> const& vs,$/;"	f	namespace:dsp
pop	mds/apfMDS.cc	/^  apf::MeshEntity* pop()$/;"	f	struct:apf::Queue
pop	parma/diffMC/parma_centroidSelector.cc	/^      apf::MeshEntity* pop() {$/;"	f	class:__anon49::DistanceQueue
pop	parma/diffMC/parma_distQ.h	/^    apf::MeshEntity* pop()$/;"	f	class:parma::DistanceQueue
pop	parma/diffMC/parma_graphDist.cc	/^  inline apf::MeshEntity* pop(queue& q) {$/;"	f	namespace:parma_ordering
pop_queue	mds/mds_order.c	/^static mds_id pop_queue(struct queue* q)$/;"	f	file:
populateWriteFields	apf/apfVtk.cc	/^std::vector<std::string> populateWriteFields(Mesh* m)$/;"	f	namespace:apf
postAdaptBalanceMethod	phasta/phInput.h	/^    std::string postAdaptBalanceMethod;$/;"	m	class:ph::Input
postBalance	ma/maBalance.cc	/^void postBalance(Adapt* a)$/;"	f	namespace:ma
postConvert	phasta/ph_convert.cc	/^static void postConvert(apf::Mesh2* m)$/;"	f	file:
postConvert	test/generate.cc	/^void postConvert(apf::Mesh2* m)$/;"	f	namespace:__anon19
pow	mth/mthAD.h	/^AD<T, N> pow(AD<T, N> const& A, AD<T, N> const& e)$/;"	f	namespace:mth
pow	mth/mthAD.h	/^AD<T, N> pow(AD<T, N> const& A, const double e)$/;"	f	namespace:mth
pow	mth/mthAD.h	/^AD<T, N> pow(AD<T, N> const& A, const int e)$/;"	f	namespace:mth
pow	mth/mthAD.h	/^AD<T, N> pow(const double base, AD<T, N> const& A)$/;"	f	namespace:mth
pow	mth/mthAD.h	/^AD<T, N> pow(const int base, AD<T, N> const& A)$/;"	f	namespace:mth
pow	mth/mthAD.h	/^double pow(double A, double e)$/;"	f	namespace:mth
pp	parma/diffMC/parma_vtxPtnWriter.cc	/^    int pp;$/;"	m	class:__anon72::Ptn	file:
prCD	phasta/phInput.h	/^    int prCD;$/;"	m	class:ph::Input
preAdaptBalanceMethod	phasta/phInput.h	/^    std::string preAdaptBalanceMethod;$/;"	m	class:ph::Input
preBalance	ma/maBalance.cc	/^void preBalance(Adapt* a)$/;"	f	namespace:ma
preDeletion	apf/apfCavityOp.cc	/^void CavityOp::preDeletion(MeshEntity* e)$/;"	f	class:apf::CavityOp
prePhastaBalanceMethod	phasta/phInput.h	/^    std::string prePhastaBalanceMethod;$/;"	m	class:ph::Input
prepare	pcu/pcu_order.c	/^static void prepare(pcu_order o, pcu_msg* t)$/;"	f	file:
prepareForMIS	apf/apfMIS.cc	/^  void prepareForMIS(Mesh* m, MeshTag* coloring, int vtx_dim, int uncolored,$/;"	f	namespace:apf
prepareIslandCleanup	ma/maTetrahedronize.cc	/^static long prepareIslandCleanup(Adapt* a)$/;"	f	namespace:ma
prepareLayerToTets	ma/maTetrahedronize.cc	/^static void prepareLayerToTets(Adapt* a)$/;"	f	namespace:ma
preparePolynomialFit	spr/sprRecoverField.cc	/^static bool preparePolynomialFit($/;"	f	namespace:spr
prepareSpr	spr/sprRecoverField.cc	/^static bool prepareSpr(Patch* p)$/;"	f	namespace:spr
preprocess	dsp/dspSmoothers.cc	/^void Smoother::preprocess(apf::Mesh* m, Boundary& fixed, Boundary& moving)$/;"	f	class:dsp::Smoother
preprocess	phasta/phCook.cc	/^  void preprocess(apf::Mesh2* m, Input& in, Output& out) {$/;"	f	namespace:ph
preprocess	phasta/phCook.cc	/^  void preprocess(apf::Mesh2* m, Input& in, Output& out, BCs& bcs) {$/;"	f	namespace:ph
preprocess	phasta/phCook.cc	/^  void preprocess(apf::Mesh2*& m, ph::Input& in) {$/;"	f	namespace:chef
preprocess	phasta/phCook.cc	/^  void preprocess(apf::Mesh2*& m, ph::Input& in, GRStream* grs) {$/;"	f	namespace:chef
prev	pumi/GenIterator.h	/^    Iterator prev; $/;"	m	class:GenIterator
preventMatchedCavityMods	ma/maMatch.cc	/^void preventMatchedCavityMods(Adapt* a)$/;"	f	namespace:ma
preventQuadEdgeSplits	ma/maLayerRefine.cc	/^static void preventQuadEdgeSplits(Adapt* a)$/;"	f	namespace:ma
previous	pumi/pumi_list.h	/^    ListMember* previous;$/;"	m	class:ListMember
pri_face_map	stk/apfMeshSTK.cc	/^static unsigned const pri_face_map[5] = {3,0,1,2,4};$/;"	m	namespace:apf	file:
primaryDim	parma/diffMC/parma_ltSelector.cc	/^      int primaryDim;$/;"	m	class:__anon58::LtSelector	file:
primaryMax	parma/diffMC/parma_ltSelector.cc	/^      double primaryMax;$/;"	m	class:__anon58::LtSelector	file:
print	lion/lionPrint.c	28;"	d	file:
print	ma/maAdapt.cc	/^void print(const char* format, ...)$/;"	f	namespace:ma
print	mds/mdsUgrid.cc	/^    void print() {$/;"	f	struct:__anon101::header
print	parma/diffMC/parma_associative.h	/^      std::string print(const char* key) {$/;"	f	class:parma::Associative
print	pumi/pumi_ghost.cc	/^void Ghosting::print()$/;"	f	class:Ghosting
print	pumi/pumi_mesh.cc	/^void Distribution::print()$/;"	f	class:Distribution
printDiagnostics	test/quality.cc	/^void printDiagnostics()$/;"	f	namespace:__anon21
printElapsedTime	parma/diffMC/parma_commons.cc	/^void parmaCommons::printElapsedTime(const char* fn, double elapsed) {$/;"	f	class:parmaCommons
printEntityImbalance	ma/maBalance.cc	/^void printEntityImbalance(Mesh* m)$/;"	f	namespace:ma
printIOtime	phasta/phInput.h	/^    int printIOtime;$/;"	m	class:ph::Input
printInfo	test/capStoneGeomTest.cc	/^void printInfo(gmi_model* model, int dim)$/;"	f
printMinMaxAvgDbl	phasta/phiotimer.cc	/^static void printMinMaxAvgDbl(const char* key, double v) {$/;"	f	file:
printMinMaxAvgSzt	phasta/phiotimer.cc	/^static void printMinMaxAvgSzt(const char* key, size_t v) {$/;"	f	file:
printModelStats	test/runSimxAnisoAdapt.cc	/^void printModelStats(pGModel model)$/;"	f
printPtnStats	mds/mdsUgrid.cc	/^  void printPtnStats(apf::Mesh2* m, const char* ufile, const char* ptnFile,$/;"	f	namespace:__anon101
printQuality	ma/maShape.cc	/^void printQuality(Adapt* a)$/;"	f	namespace:ma
printSimError	test/simTranslate.cc	/^void printSimError(pSimError err)$/;"	f
printStats	apf/apfMesh.cc	/^void printStats(Mesh* m)$/;"	f	namespace:apf
printTable	parma/diffMC/zeroOneKnapsack.c	/^void printTable(Knapsack knapsack) {$/;"	f
printTime	phasta/phstream.cc	/^  inline void printTime(const char* key, double t) {$/;"	f	namespace:__anon81
printTiming	parma/diffMC/parma_balancer.cc	/^  void printTiming(const char* type, int steps, double tol, double time) {$/;"	f	namespace:__anon53
printTypes	apf/apfMesh.cc	/^void printTypes(Mesh* m)$/;"	f	namespace:apf
printUgridPtnStats	mds/mdsUgrid.cc	/^  void printUgridPtnStats(gmi_model* g, const char* ufile, const char* vtxptn,$/;"	f	namespace:apf
printUsage	parma/diffMC/maximalIndependentSet/test/testMIS.cc	/^void printUsage(char* exe) {$/;"	f
print_copies	pumi/pumi_mesh.cc	/^void print_copies(pMesh m, pMeshEnt e)$/;"	f
print_stats	test/describe.cc	/^static void print_stats(const char* name, double value)$/;"	f	file:
print_usage	test/scale.cc	/^static void print_usage(char** argv) {$/;"	f	namespace:__anon3
prism	ma/maTetrahedronize.cc	/^  Entity* prism;$/;"	m	struct:ma::UnsafePrismOverride	file:
prism	test/shapefun2.cc	/^static apf::Vector3 const prism[6] = {$/;"	m	class:test::apf	file:
prismAndPyramidToTets	ma/maTemplates.cc	/^void prismAndPyramidToTets(Refine* r, Entity* p, Entity** wv, Entity* v)$/;"	f	namespace:ma
prismToPyramidAndTet	ma/maLayerTemplates.cc	/^static void prismToPyramidAndTet(Refine* r, Entity* p, Entity** v)$/;"	f	namespace:ma
prismToTetsBadCase	ma/maTemplates.cc	/^Entity* prismToTetsBadCase($/;"	f	namespace:ma
prismToTetsGoodCase	ma/maTemplates.cc	/^void prismToTetsGoodCase($/;"	f	namespace:ma
prism_code_match	ma/maLayerTables.cc	/^CodeMatch const prism_code_match[(1<<9)] =$/;"	m	namespace:ma	file:
prism_diag_choices	ma/maTables.cc	/^int const prism_diag_choices[4] =$/;"	m	namespace:ma	file:
prism_diag_match	ma/maTables.cc	/^int const prism_diag_match[(1<<3)] =$/;"	m	namespace:ma	file:
prism_edge_code_count	ma/maTables.h	/^  prism_edge_code_count = 5,$/;"	e	enum:ma::__anon27
prism_edge_codes	ma/maTables.cc	/^int const prism_edge_codes[prism_edge_code_count] =$/;"	m	namespace:ma	file:
prism_edge_verts	apf/apfMesh.cc	/^int const prism_edge_verts[9][2] =$/;"	m	namespace:apf	file:
prism_quad_verts	apf/apfMesh.cc	/^int const prism_quad_verts[3][4] =$/;"	m	namespace:apf	file:
prism_rotation	ma/maTables.cc	/^int const prism_rotation[6][6] =$/;"	m	namespace:ma	file:
prism_templates	ma/maLayerTemplates.cc	/^SplitFunction prism_templates[prism_edge_code_count] = $/;"	m	namespace:ma	file:
prism_tri_verts	apf/apfMesh.cc	/^int const prism_tri_verts[2][3] =$/;"	m	namespace:apf	file:
problemFace	ma/maSnapper.h	/^    Entity* problemFace;$/;"	m	class:ma::FirstProblemPlane
problemRegion	ma/maSnapper.h	/^    Entity* problemRegion;$/;"	m	class:ma::FirstProblemPlane
problemRegions	ma/maSnapper.h	/^    apf::Up problemRegions;$/;"	m	class:ma::FirstProblemPlane
process	apf/apfIntegrate.cc	/^void Integrator::process(Mesh* m, int d)$/;"	f	class:apf::Integrator
process	apf/apfIntegrate.cc	/^void Integrator::process(MeshElement* e)$/;"	f	class:apf::Integrator
process	ma/maSize.cc	/^    void process(apf::MeshElement* me)$/;"	f	class:ma::SizeFieldIntegrator
processMesh	test/quality.cc	/^static void processMesh(apf::Mesh2* m)$/;"	f	namespace:__anon21
processNewBdryVert	ma/maRegionCollapse.cc	/^static void processNewBdryVert(Mesh* m, Entity* v)$/;"	f	namespace:ma
processNewElements	ma/maRefine.cc	/^void processNewElements(Refine* r)$/;"	f	namespace:ma
process_element	phasta/threshold.cc	/^static double process_element(apf::Vector3 x[4], double sol[4][9])$/;"	f	file:
progressHandler	test/simTranslate.cc	/^void progressHandler(const char *what, int level, int startVal, $/;"	f
project	apf/apfFieldOf.cc	/^void project(FieldOf<T>* to, FieldOf<T>* from)$/;"	f	namespace:apf
project	apf/apfFieldOf.h	/^    void project(Field* from)$/;"	f	class:apf::FieldOf
project	apf/apfPackedField.cc	/^void PackedField::project(Field*)$/;"	f	class:apf::PackedField
project	apf/apfVector.h	/^Vector<N> project(Vector<N> const& a, Vector<N> const& b)$/;"	f	namespace:apf
project	mth/mth_def.h	/^Vector<T,N> project(Vector<T,N> const& a, Vector<T,N> const& b)$/;"	f	namespace:mth
projectField	apf/apf.cc	/^void projectField(Field* to, Field* from)$/;"	f	namespace:apf
projectHierarchicField	apf/apfHierarchic.cc	/^void projectHierarchicField(Field* to, Field* from)$/;"	f	namespace:apf
przw	test/ugridptnstats.cc	/^const double przw = 7.5;$/;"	v
ptn	mds/mdsUgrid.cc	/^      int* ptn;         \/\/vertex id to part id array$/;"	m	class:__anon101::ptnstats	file:
ptn	zoltan/apfZoltanCallbacks.cc	/^void ZoltanData::ptn()$/;"	f	class:apf::ZoltanData
ptnstats	mds/mdsUgrid.cc	/^      ptnstats() : numparts(0), ptn(NULL), partvtx(NULL),$/;"	f	class:__anon101::ptnstats
ptnstats	mds/mdsUgrid.cc	/^  class ptnstats {$/;"	c	namespace:__anon101	file:
ptr	pumi/GenIterator.h	/^    void* ptr; $/;"	m	class:GenIterator
ptrFuncProcessingFilter	pumi/GenIterator.h	/^    void (*ptrFuncProcessingFilter) (Iterator&, Iterator&, void*, int, int); $/;"	m	class:GenIterator
pumi	pumi/pumi.h	/^class pumi$/;"	c
pumi	pumi/pumi_mesh.cc	/^pumi::pumi(): mesh(NULL), model(NULL) $/;"	f	class:pumi
pumi_field_accumulate	pumi/pumi_field.cc	/^void pumi_field_accumulate(pField f, pOwnership o)$/;"	f
pumi_field_add	pumi/pumi_field.cc	/^void pumi_field_add(pField f1, pField f2, pField f3)$/;"	f
pumi_field_copy	pumi/pumi_field.cc	/^void pumi_field_copy(pField f1, pField f2)$/;"	f
pumi_field_create	pumi/pumi_field.cc	/^pField pumi_field_create(pMesh m, const char* name, int num_dof_per_ent, int type, pShape s)$/;"	f
pumi_field_delete	pumi/pumi_field.cc	/^void pumi_field_delete(pField f)$/;"	f
pumi_field_freeze	pumi/pumi_field.cc	/^void pumi_field_freeze(pField f)$/;"	f
pumi_field_getName	pumi/pumi_field.cc	/^std::string pumi_field_getName(pField f)$/;"	f
pumi_field_getNumbering	pumi/pumi_field.cc	/^pNumbering pumi_field_getNumbering (pField f)$/;"	f
pumi_field_getShape	pumi/pumi_field.cc	/^pShape pumi_field_getShape (pField f)$/;"	f
pumi_field_getSize	pumi/pumi_field.cc	/^int pumi_field_getSize(pField f)$/;"	f
pumi_field_getType	pumi/pumi_field.cc	/^int pumi_field_getType(pField f)$/;"	f
pumi_field_multiply	pumi/pumi_field.cc	/^void pumi_field_multiply(pField f1, double d, pField f2)$/;"	f
pumi_field_print	pumi/pumi_field.cc	/^void pumi_field_print(pField f)$/;"	f
pumi_field_synchronize	pumi/pumi_field.cc	/^void pumi_field_synchronize(pField f, pOwnership o)$/;"	f
pumi_field_unfreeze	pumi/pumi_field.cc	/^void pumi_field_unfreeze(pField f)$/;"	f
pumi_field_verify	pumi/pumi_field.cc	/^void pumi_field_verify(pMesh m, pField f, pOwnership shr)$/;"	f
pumi_finalize	pumi/pumi_sys.cc	/^void pumi_finalize(bool)$/;"	f
pumi_gent_deleteTag	pumi/pumi_gtag.cc	/^void pumi_gent_deleteTag (pGeomEnt ent, pTag tag)$/;"	f
pumi_gent_get2ndAdj	pumi/pumi_gentity.cc	/^void pumi_gent_get2ndAdj (pGeomEnt ge, $/;"	f
pumi_gent_getAdj	pumi/pumi_gentity.cc	/^void pumi_gent_getAdj (pGeomEnt ge, int target_dim, std::vector<pGeomEnt>& result_vec)$/;"	f
pumi_gent_getDblArrTag	pumi/pumi_gtag.cc	/^void pumi_gent_getDblArrTag (pGeomEnt ent, pTag tag, double** data, int* data_size)$/;"	f
pumi_gent_getDblTag	pumi/pumi_gtag.cc	/^void pumi_gent_getDblTag (pGeomEnt ent, pTag tag, double* data)$/;"	f
pumi_gent_getDim	pumi/pumi_gentity.cc	/^int pumi_gent_getDim(pGeomEnt ge)$/;"	f
pumi_gent_getEntArrTag	pumi/pumi_gtag.cc	/^void pumi_gent_getEntArrTag (pGeomEnt ent, pTag tag, pGeomEnt** data, int* data_size)$/;"	f
pumi_gent_getEntTag	pumi/pumi_gtag.cc	/^void pumi_gent_getEntTag (pGeomEnt ent, pTag tag, pGeomEnt *data)$/;"	f
pumi_gent_getID	pumi/pumi_gentity.cc	/^int pumi_gent_getID(pGeomEnt ge)$/;"	f
pumi_gent_getIntArrTag	pumi/pumi_gtag.cc	/^void pumi_gent_getIntArrTag (pGeomEnt ent, pTag tag, int** data, int* data_size)$/;"	f
pumi_gent_getIntTag	pumi/pumi_gtag.cc	/^void pumi_gent_getIntTag (pGeomEnt ent, pTag tag, int* data)$/;"	f
pumi_gent_getLongArrTag	pumi/pumi_gtag.cc	/^void pumi_gent_getLongArrTag (pGeomEnt ent, pTag tag, long** data, int* data_size)$/;"	f
pumi_gent_getLongTag	pumi/pumi_gtag.cc	/^void pumi_gent_getLongTag (pGeomEnt ent, pTag tag, long* data)$/;"	f
pumi_gent_getNumAdj	pumi/pumi_gentity.cc	/^int pumi_gent_getNumAdj (pGeomEnt ge, int target_dim)$/;"	f
pumi_gent_getPtrArrTag	pumi/pumi_gtag.cc	/^void pumi_gent_getPtrArrTag (pGeomEnt ent, pTag tag, void** data)$/;"	f
pumi_gent_getPtrTag	pumi/pumi_gtag.cc	/^void pumi_gent_getPtrTag (pGeomEnt ent, pTag tag, void** data)$/;"	f
pumi_gent_getRevClas	pumi/pumi_gentity.cc	/^void pumi_gent_getRevClas (pGeomEnt ge, std::vector<pMeshEnt>& ents)$/;"	f
pumi_gent_getStringTag	pumi/pumi_gtag.cc	/^void pumi_gent_getStringTag(pGeomEnt ent, pTag tag, const char*& s)$/;"	f
pumi_gent_getTag	pumi/pumi_gtag.cc	/^void pumi_gent_getTag (pGeomEnt ent, std::vector<pTag>& tags)$/;"	f
pumi_gent_hasTag	pumi/pumi_gtag.cc	/^bool pumi_gent_hasTag (pGeomEnt ent, pTag tag)$/;"	f
pumi_gent_setDblArrTag	pumi/pumi_gtag.cc	/^void pumi_gent_setDblArrTag (pGeomEnt ent, pTag tag, const double* data)$/;"	f
pumi_gent_setDblTag	pumi/pumi_gtag.cc	/^void pumi_gent_setDblTag (pGeomEnt ent, pTag tag, const double data)$/;"	f
pumi_gent_setEntArrTag	pumi/pumi_gtag.cc	/^void pumi_gent_setEntArrTag (pGeomEnt ent, pTag tag, const pGeomEnt* data)$/;"	f
pumi_gent_setEntTag	pumi/pumi_gtag.cc	/^void pumi_gent_setEntTag (pGeomEnt ent, pTag tag, const pGeomEnt data)$/;"	f
pumi_gent_setIntArrTag	pumi/pumi_gtag.cc	/^void pumi_gent_setIntArrTag (pGeomEnt ent, pTag tag, const int* data)$/;"	f
pumi_gent_setIntTag	pumi/pumi_gtag.cc	/^void pumi_gent_setIntTag (pGeomEnt ent, pTag tag, const int data)$/;"	f
pumi_gent_setLongArrTag	pumi/pumi_gtag.cc	/^void pumi_gent_setLongArrTag (pGeomEnt ent, pTag tag, const long* data)$/;"	f
pumi_gent_setLongTag	pumi/pumi_gtag.cc	/^void pumi_gent_setLongTag (pGeomEnt ent, pTag tag, const long data)$/;"	f
pumi_gent_setPtrArrTag	pumi/pumi_gtag.cc	/^void pumi_gent_setPtrArrTag (pGeomEnt ent, pTag tag, void* const* data)$/;"	f
pumi_gent_setPtrTag	pumi/pumi_gtag.cc	/^void pumi_gent_setPtrTag (pGeomEnt ent, pTag tag, void* data)$/;"	f
pumi_gent_setStringTag	pumi/pumi_gtag.cc	/^void pumi_gent_setStringTag(pGeomEnt ent, pTag tag, const char* s)$/;"	f
pumi_geom_createTag	pumi/pumi_gtag.cc	/^pTag pumi_geom_createTag (pGeom m, const char* tag_name, int tag_type, int tag_size)$/;"	f
pumi_geom_delete	pumi/pumi_geom.cc	/^void pumi_geom_delete(pGeom g)$/;"	f
pumi_geom_deleteTag	pumi/pumi_gtag.cc	/^void pumi_geom_deleteTag (pGeom g, pTag tag, bool force_delete)$/;"	f
pumi_geom_findEnt	pumi/pumi_geom.cc	/^pGeomEnt pumi_geom_findEnt(pGeom g, int d, int id)$/;"	f
pumi_geom_findTag	pumi/pumi_gtag.cc	/^pTag pumi_geom_findTag (pGeom m, const char* name)$/;"	f
pumi_geom_freeze	pumi/pumi_geom.cc	/^void pumi_geom_freeze(pGeom g)$/;"	f
pumi_geom_getNumEnt	pumi/pumi_geom.cc	/^int pumi_geom_getNumEnt(pGeom g, int d)$/;"	f
pumi_geom_getTag	pumi/pumi_gtag.cc	/^void pumi_geom_getTag (pGeom m, std::vector<pTag>& tags)$/;"	f
pumi_geom_hasTag	pumi/pumi_gtag.cc	/^bool pumi_geom_hasTag (pGeom m, const pTag tag)$/;"	f
pumi_geom_load	pumi/pumi_geom.cc	/^pGeom pumi_geom_load(const char* filename, const char* model_type, void (*geom_load_fp)(const char*))$/;"	f
pumi_geom_print	pumi/pumi_geom.cc	/^void pumi_geom_print (pGeom g, bool print_ent)$/;"	f
pumi_getMem	pumi/pumi_sys.cc	/^double pumi_getMem()$/;"	f
pumi_getTime	pumi/pumi_sys.cc	/^double pumi_getTime()$/;"	f
pumi_ghost_create	pumi/pumi_ghost.cc	/^void pumi_ghost_create(pMesh m, Ghosting* plan)$/;"	f
pumi_ghost_createLayer	pumi/pumi_ghost.cc	/^void pumi_ghost_createLayer (pMesh m, int brg_dim, int ghost_dim, int num_layer, int include_copy)$/;"	f
pumi_ghost_delete	pumi/pumi_ghost.cc	/^void pumi_ghost_delete (pMesh m)$/;"	f
pumi_ghost_getInfo	pumi/pumi_ghost.cc	/^void pumi_ghost_getInfo (pMesh, std::vector<int>&)$/;"	f
pumi_git_sha	pumi/pumi_version.h	/^const char* pumi_git_sha() {$/;"	f
pumi_giter_delete	pumi/pumi_geom.cc	/^void pumi_giter_delete(gIter iter)$/;"	f
pumi_giter_getNext	pumi/pumi_geom.cc	/^int pumi_giter_getNext(gIter iter, pGeomEnt& ent)$/;"	f
pumi_giter_init	pumi/pumi_geom.cc	/^int pumi_giter_init (pGeom model, int type, gIter& iter)$/;"	f
pumi_giter_isEnd	pumi/pumi_geom.cc	/^bool pumi_giter_isEnd(gIter iter)$/;"	f
pumi_giter_reset	pumi/pumi_geom.cc	/^void pumi_giter_reset(gIter iter)$/;"	f
pumi_medge_getOtherVtx	pumi/pumi_mentity.cc	/^pMeshEnt pumi_medge_getOtherVtx(pMeshEnt edge, pMeshEnt vtx)$/;"	f
pumi_ment_cleanRmt	pumi/pumi_mentity.cc	/^void pumi_ment_cleanRmt (pMeshEnt)$/;"	f
pumi_ment_deleteRmt	pumi/pumi_mentity.cc	/^void pumi_ment_deleteRmt (pMeshEnt, int)$/;"	f
pumi_ment_deleteTag	pumi/pumi_mtag.cc	/^void pumi_ment_deleteTag (pMeshEnt e, pMeshTag t)$/;"	f
pumi_ment_get2ndAdj	pumi/pumi_mentity.cc	/^void pumi_ment_get2ndAdj (pMeshEnt e, int bridge_dim, int target_dim, std::vector<pMeshEnt>& vecAdjEnt)$/;"	f
pumi_ment_get2ndAdjacent	pumi/pumi_mentity.cc	/^int pumi_ment_get2ndAdjacent(pMeshEnt e, int bridge_dim, int target_dim, Adjacent& adjacent)$/;"	f
pumi_ment_getAdj	pumi/pumi_mentity.cc	/^void pumi_ment_getAdj(pMeshEnt e, int target_dim, std::vector<pMeshEnt>& vecAdjEnt)$/;"	f
pumi_ment_getAdjacent	pumi/pumi_mentity.cc	/^int pumi_ment_getAdjacent(pMeshEnt e, int target_dim, Adjacent& adjacent)$/;"	f
pumi_ment_getAllGhost	pumi/pumi_mentity.cc	/^void pumi_ment_getAllGhost(pMeshEnt e, Copies& ghosts)$/;"	f
pumi_ment_getAllRmt	pumi/pumi_mentity.cc	/^void pumi_ment_getAllRmt(pMeshEnt e, Copies& remotes)$/;"	f
pumi_ment_getClosureResidence	pumi/pumi_mentity.cc	/^void pumi_ment_getClosureResidence(pMeshEnt e, Parts& residence)$/;"	f
pumi_ment_getDblTag	pumi/pumi_mtag.cc	/^void pumi_ment_getDblTag(pMeshEnt e, pMeshTag t, double* data)$/;"	f
pumi_ment_getDim	pumi/pumi_mentity.cc	/^int pumi_ment_getDim(pMeshEnt e)$/;"	f
pumi_ment_getGeomClas	pumi/pumi_mentity.cc	/^pGeomEnt pumi_ment_getGeomClas(pMeshEnt e)$/;"	f
pumi_ment_getGhost	pumi/pumi_mentity.cc	/^pMeshEnt pumi_ment_getGhost(pMeshEnt& e, int pid)$/;"	f
pumi_ment_getGlobalID	pumi/pumi_mentity.cc	/^int pumi_ment_getGlobalID(pMeshEnt e)$/;"	f
pumi_ment_getID	pumi/pumi_mentity.cc	/^int pumi_ment_getID(pMeshEnt e)$/;"	f
pumi_ment_getIntTag	pumi/pumi_mtag.cc	/^void pumi_ment_getIntTag(pMeshEnt e, pMeshTag t, int* data)$/;"	f
pumi_ment_getLongTag	pumi/pumi_mtag.cc	/^void pumi_ment_getLongTag(pMeshEnt e, pMeshTag t, long* data)$/;"	f
pumi_ment_getNumAdj	pumi/pumi_mentity.cc	/^int pumi_ment_getNumAdj(pMeshEnt e, int target_dim)$/;"	f
pumi_ment_getNumGhost	pumi/pumi_mentity.cc	/^int pumi_ment_getNumGhost (pMeshEnt e)$/;"	f
pumi_ment_getNumRmt	pumi/pumi_mentity.cc	/^int pumi_ment_getNumRmt (pMeshEnt e)$/;"	f
pumi_ment_getOwnEnt	pumi/pumi_mentity.cc	/^pMeshEnt pumi_ment_getOwnEnt(pMeshEnt e, pOwnership o)$/;"	f
pumi_ment_getOwnPID	pumi/pumi_mentity.cc	/^int pumi_ment_getOwnPID(pMeshEnt e, pOwnership o)$/;"	f
pumi_ment_getResidence	pumi/pumi_mentity.cc	/^void pumi_ment_getResidence(pMeshEnt e, Parts& residence)$/;"	f
pumi_ment_getRmt	pumi/pumi_mentity.cc	/^pMeshEnt pumi_ment_getRmt(pMeshEnt& e, int pid)$/;"	f
pumi_ment_getTopo	pumi/pumi_mentity.cc	/^int pumi_ment_getTopo(pMeshEnt e) $/;"	f
pumi_ment_hasTag	pumi/pumi_mtag.cc	/^bool pumi_ment_hasTag (pMeshEnt e, pMeshTag t)$/;"	f
pumi_ment_isGhost	pumi/pumi_mentity.cc	/^bool pumi_ment_isGhost(pMeshEnt e)$/;"	f
pumi_ment_isGhosted	pumi/pumi_mentity.cc	/^bool pumi_ment_isGhosted (pMeshEnt e)$/;"	f
pumi_ment_isOn	pumi/pumi_mentity.cc	/^bool pumi_ment_isOn(pMeshEnt e, int partID)$/;"	f
pumi_ment_isOnBdry	pumi/pumi_mentity.cc	/^bool pumi_ment_isOnBdry (pMeshEnt e)$/;"	f
pumi_ment_isOwned	pumi/pumi_mentity.cc	/^bool pumi_ment_isOwned(pMeshEnt e, pOwnership o)$/;"	f
pumi_ment_setDblTag	pumi/pumi_mtag.cc	/^void pumi_ment_setDblTag(pMeshEnt e, pMeshTag t, double const* data)$/;"	f
pumi_ment_setIntTag	pumi/pumi_mtag.cc	/^void pumi_ment_setIntTag(pMeshEnt e, pMeshTag t, int const* data)$/;"	f
pumi_ment_setLongTag	pumi/pumi_mtag.cc	/^void pumi_ment_setLongTag(pMeshEnt e, pMeshTag t, long const* data)$/;"	f
pumi_ment_setPtnTopology	pumi/pumi_mentity.cc	/^void pumi_ment_setPtnTopology (pMeshEnt)$/;"	f
pumi_ment_setRmt	pumi/pumi_mentity.cc	/^void pumi_ment_setRmt(pMeshEnt, int, pMeshEnt)$/;"	f
pumi_mesh_create	pumi/pumi_mesh.cc	/^pMesh pumi_mesh_create(pGeom g, int mesh_dim, bool periodic)$/;"	f
pumi_mesh_createAdjacency	pumi/pumi_mesh.cc	/^void pumi_mesh_createAdjacency(pMesh m, int from_dim, int to_dim)$/;"	f
pumi_mesh_createDblTag	pumi/pumi_mtag.cc	/^pMeshTag pumi_mesh_createDblTag(pMesh m, const char* name, int size)$/;"	f
pumi_mesh_createElem	pumi/pumi_mesh.cc	/^pMeshEnt pumi_mesh_createElem(pMesh m, pGeomEnt ge, int ent_topology, pMeshEnt* vertices) $/;"	f
pumi_mesh_createEnt	pumi/pumi_mesh.cc	/^pMeshEnt pumi_mesh_createEnt(pMesh m, pGeomEnt ge, int ent_topology, pMeshEnt* down)$/;"	f
pumi_mesh_createFullAdjacency	pumi/pumi_mesh.cc	/^void pumi_mesh_createFullAdjacency(pMesh m)$/;"	f
pumi_mesh_createGlobalID	pumi/pumi_mesh.cc	/^void pumi_mesh_createGlobalID(pMesh m, pOwnership o)$/;"	f
pumi_mesh_createIntTag	pumi/pumi_mtag.cc	/^pMeshTag pumi_mesh_createIntTag(pMesh m, const char* name, int size)$/;"	f
pumi_mesh_createLongTag	pumi/pumi_mtag.cc	/^pMeshTag pumi_mesh_createLongTag(pMesh m, const char* name, int size)$/;"	f
pumi_mesh_createVtx	pumi/pumi_mesh.cc	/^pMeshEnt pumi_mesh_createVtx(pMesh m, pGeomEnt ge, double* xyz)$/;"	f
pumi_mesh_delete	pumi/pumi_mesh.cc	/^void pumi_mesh_delete(pMesh m)$/;"	f
pumi_mesh_deleteAdjacency	pumi/pumi_mesh.cc	/^void pumi_mesh_deleteAdjacency(pMesh m, int from_dim, int to_dim)$/;"	f
pumi_mesh_deleteGlobalID	pumi/pumi_mesh.cc	/^void pumi_mesh_deleteGlobalID(pMesh m)$/;"	f
pumi_mesh_deleteTag	pumi/pumi_mtag.cc	/^void pumi_mesh_deleteTag(pMesh m, pMeshTag t, bool force_delete)$/;"	f
pumi_mesh_distribute	pumi/pumi_mesh.cc	/^void pumi_mesh_distribute(pMesh m, Distribution* plan)$/;"	f
pumi_mesh_findEnt	pumi/pumi_mesh.cc	/^pMeshEnt pumi_mesh_findEnt(pMesh m, int d, int id)$/;"	f
pumi_mesh_findField	pumi/pumi_field.cc	/^pField pumi_mesh_findField(pMesh m, const char* name)$/;"	f
pumi_mesh_findTag	pumi/pumi_mtag.cc	/^pMeshTag pumi_mesh_findTag(pMesh m, const char* name)$/;"	f
pumi_mesh_freeze	pumi/pumi_mesh.cc	/^void pumi_mesh_freeze(pMesh m)$/;"	f
pumi_mesh_getDim	pumi/pumi_mesh.cc	/^int pumi_mesh_getDim(pMesh m)$/;"	f
pumi_mesh_getField	pumi/pumi_field.cc	/^pField pumi_mesh_getField(pMesh m, int i)$/;"	f
pumi_mesh_getGeom	pumi/pumi_mesh.cc	/^pGeom pumi_mesh_getGeom(pMesh)$/;"	f
pumi_mesh_getNumEnt	pumi/pumi_mesh.cc	/^int pumi_mesh_getNumEnt(pMesh m, int dim)$/;"	f
pumi_mesh_getNumField	pumi/pumi_field.cc	/^int pumi_mesh_getNumField(pMesh m)$/;"	f
pumi_mesh_getNumGlobalEnt	pumi/pumi_mesh.cc	/^int pumi_mesh_getNumGlobalEnt(pMesh m, int dim)$/;"	f
pumi_mesh_getNumOwnEnt	pumi/pumi_mesh.cc	/^int pumi_mesh_getNumOwnEnt(pMesh m, int dim)$/;"	f
pumi_mesh_getShape	pumi/pumi_field.cc	/^pShape pumi_mesh_getShape (pMesh m)$/;"	f
pumi_mesh_getTag	pumi/pumi_mtag.cc	/^void pumi_mesh_getTag(pMesh m, std::vector<pMeshTag> tag_vec)$/;"	f
pumi_mesh_hasAdjacency	pumi/pumi_mesh.cc	/^bool pumi_mesh_hasAdjacency(pMesh m, int from_dim, int to_dim)$/;"	f
pumi_mesh_hasTag	pumi/pumi_mtag.cc	/^bool pumi_mesh_hasTag (pMesh m, const pMeshTag t)$/;"	f
pumi_mesh_load	pumi/pumi_mesh.cc	/^pMesh pumi_mesh_load(pGeom g, const char* filename, int num_in_part, const char* mesh_type)$/;"	f
pumi_mesh_loadAll	pumi/pumi_mesh.cc	/^pMesh pumi_mesh_loadAll(pGeom g, const char* filename, bool stitch_link)$/;"	f
pumi_mesh_loadSerial	pumi/pumi_mesh.cc	/^pMesh pumi_mesh_loadSerial(pGeom g, const char* filename, const char* mesh_type)$/;"	f
pumi_mesh_migrate	pumi/pumi_mesh.cc	/^void pumi_mesh_migrate(pMesh m, Migration* plan)$/;"	f
pumi_mesh_print	pumi/pumi_mesh.cc	/^void pumi_mesh_print (pMesh m, bool print_ent)$/;"	f
pumi_mesh_setCount	pumi/pumi_mesh.cc	/^void pumi_mesh_setCount(pMesh m, pOwnership o)$/;"	f
pumi_mesh_setShape	pumi/pumi_field.cc	/^void pumi_mesh_setShape (pMesh m, pShape s, bool project)$/;"	f
pumi_mesh_verify	pumi/pumi_mesh.cc	/^void pumi_mesh_verify(pMesh m, bool abort_on_error)$/;"	f
pumi_mesh_write	pumi/pumi_mesh.cc	/^void pumi_mesh_write (pMesh m, const char* filename, const char* mesh_type)$/;"	f
pumi_node_getCoord	pumi/pumi_field.cc	/^void pumi_node_getCoord(pMeshEnt e, int i, double* xyz)$/;"	f
pumi_node_getCoordVector	pumi/pumi_field.cc	/^void pumi_node_getCoordVector(pMeshEnt e, int i, Vector3& xyz)$/;"	f
pumi_node_getField	pumi/pumi_field.cc	/^void pumi_node_getField (pField f, pMeshEnt e, int i, double* dof_data)$/;"	f
pumi_node_getNumber	pumi/pumi_numbering.cc	/^int pumi_node_getNumber(pNumbering nb, pMeshEnt e, int n, int c)$/;"	f
pumi_node_isNumbered	pumi/pumi_numbering.cc	/^bool pumi_node_isNumbered(pNumbering nb, pMeshEnt e, int n, int c)$/;"	f
pumi_node_setCoord	pumi/pumi_field.cc	/^void pumi_node_setCoord(pMeshEnt e,int i, double* xyz)$/;"	f
pumi_node_setCoordVector	pumi/pumi_field.cc	/^void pumi_node_setCoordVector(pMeshEnt e, int i, Vector3 const& xyz)$/;"	f
pumi_node_setField	pumi/pumi_field.cc	/^void pumi_node_setField (pField f, pMeshEnt e, int i, double* dof_data)$/;"	f
pumi_node_setNumber	pumi/pumi_numbering.cc	/^void pumi_node_setNumber(pNumbering nb, pMeshEnt e, int n, int c, int number)$/;"	f
pumi_numbering_create	pumi/pumi_numbering.cc	/^pNumbering pumi_numbering_create$/;"	f
pumi_numbering_createGlobal	pumi/pumi_numbering.cc	/^pNumbering pumi_numbering_createGlobal(pMesh m, const char* name, pShape s, pOwnership o)$/;"	f
pumi_numbering_createLocal	pumi/pumi_numbering.cc	/^pNumbering pumi_numbering_createLocal (pMesh m, const char* name, pShape shape)$/;"	f
pumi_numbering_createOwn	pumi/pumi_numbering.cc	/^pNumbering pumi_numbering_createOwn (pMesh m, const char* name, pShape shape, pOwnership o)$/;"	f
pumi_numbering_createOwnDim	pumi/pumi_numbering.cc	/^pNumbering pumi_numbering_createOwnDim (pMesh m, const char* name, int dim, pOwnership o)$/;"	f
pumi_numbering_createProcGrp	pumi/pumi_numbering.cc	/^pNumbering pumi_numbering_createProcGrp ($/;"	f
pumi_numbering_delete	pumi/pumi_numbering.cc	/^void pumi_numbering_delete(pNumbering n)$/;"	f
pumi_numbering_getNumNode	pumi/pumi_numbering.cc	/^int pumi_numbering_getNumNode(pNumbering n)$/;"	f
pumi_numbering_print	pumi/pumi_numbering.cc	/^void pumi_numbering_print(pNumbering n, int pid)$/;"	f
pumi_ownership_verify	pumi/pumi_mesh.cc	/^void pumi_ownership_verify(pMesh m, pOwnership o)$/;"	f
pumi_printSys	pumi/pumi_sys.cc	/^void pumi_printSys()$/;"	f
pumi_printTimeMem	pumi/pumi_sys.cc	/^void pumi_printTimeMem(const char* msg, double time, double memory)$/;"	f
pumi_rank	pumi/pumi_sys.cc	/^int pumi_rank()$/;"	f
pumi_shape_getConstant	pumi/pumi_field.cc	/^pShape pumi_shape_getConstant (int type) { return apf::getConstant(type); }$/;"	f
pumi_shape_getHierarchic	pumi/pumi_field.cc	/^pShape pumi_shape_getHierarchic (int order) { return apf::getHierarchic(order); }$/;"	f
pumi_shape_getIP	pumi/pumi_field.cc	/^pShape pumi_shape_getIP (int dimension, int order) { return apf::getIPShape(dimension, order); }$/;"	f
pumi_shape_getIPFit	pumi/pumi_field.cc	/^pShape pumi_shape_getIPFit(int dimension, int order) { return apf::getIPFitShape(dimension, order); }$/;"	f
pumi_shape_getLagrange	pumi/pumi_field.cc	/^pShape pumi_shape_getLagrange (int order) { return apf::getLagrange(order); }$/;"	f
pumi_shape_getNumNode	pumi/pumi_field.cc	/^int pumi_shape_getNumNode (pShape s, int topo)$/;"	f
pumi_shape_getSerendipity	pumi/pumi_field.cc	/^pShape pumi_shape_getSerendipity () { return apf::getSerendipity(); }$/;"	f
pumi_shape_getVoronoi	pumi/pumi_field.cc	/^pShape pumi_shape_getVoronoi (int dimension, int order) { return apf::getVoronoiShape(dimension, order); }$/;"	f
pumi_shape_hasNode	pumi/pumi_field.cc	/^bool pumi_shape_hasNode (pShape s, int topo)$/;"	f
pumi_size	pumi/pumi_sys.cc	/^int pumi_size()$/;"	f
pumi_start	pumi/pumi_sys.cc	/^void pumi_start()$/;"	f
pumi_sync	pumi/pumi_sys.cc	/^void pumi_sync(void)$/;"	f
pumi_tag_getByte	pumi/pumi_gtag.cc	/^int pumi_tag_getByte (const pTag tag)$/;"	f
pumi_tag_getName	pumi/pumi_gtag.cc	/^void pumi_tag_getName (const pTag tag, const char** name)$/;"	f
pumi_tag_getSize	pumi/pumi_gtag.cc	/^int pumi_tag_getSize (const pTag tag)$/;"	f
pumi_tag_getType	pumi/pumi_gtag.cc	/^int pumi_tag_getType (const pTag tag)$/;"	f
pumi_vector3_cross	pumi/pumi_field.cc	/^Vector3 pumi_vector3_cross(Vector3 const& a, Vector3 const& b)$/;"	f
pumi_version	pumi/pumi_version.h	/^const char* pumi_version() {$/;"	f
push	dsp/dspGraphDistance.cc	/^static void push(std::vector<apf::MeshEntity*>& vs,$/;"	f	namespace:dsp
push	mds/apfMDS.cc	/^  void push(apf::MeshEntity* e)$/;"	f	struct:apf::Queue
push	parma/diffMC/parma_centroidSelector.cc	/^      void push(apf::MeshEntity* e, int to) {$/;"	f	class:__anon49::DistanceQueue
push	parma/diffMC/parma_distQ.h	/^    void push(apf::MeshEntity* e, int dist)$/;"	f	class:parma::DistanceQueue
push	parma/diffMC/parma_monitor.cc	/^  void CircBuffer::push(double v) {$/;"	f	class:parma::CircBuffer
pushVector	mds/apfMDS.cc	/^  void pushVector(std::vector<apf::MeshEntity*> const& l)$/;"	f	struct:apf::Queue
push_back	pumi/pumi_list.h	/^    void push_back(ListMember* m)$/;"	f	class:List
push_queue	mds/mds_order.c	/^static void push_queue(struct queue* q, mds_id e)$/;"	f	file:
putPME	mds/apfPM.cc	/^void putPME(PM& ps, PME* p)$/;"	f	namespace:apf
pyr_face_map	stk/apfMeshSTK.cc	/^static unsigned const pyr_face_map[5] = {4,0,1,2,3};$/;"	m	namespace:apf	file:
pyramid	ma/maTetrahedronize.cc	/^  Entity* pyramid;$/;"	m	struct:ma::UnsafePyramidOverride	file:
pyramid	test/shapefun2.cc	/^static apf::Vector3 const pyramid[5] = {$/;"	m	class:test::apf	file:
pyramidToTets	ma/maTemplates.cc	/^void pyramidToTets(Refine* r, Entity* parent, Entity** v)$/;"	f	namespace:ma
pyramid_code_match	ma/maLayerTables.cc	/^CodeMatch const pyramid_code_match[(1<<8)] = $/;"	m	namespace:ma	file:
pyramid_edge_code_count	ma/maTables.h	/^  pyramid_edge_code_count = 17$/;"	e	enum:ma::__anon27
pyramid_edge_codes	ma/maTables.cc	/^int const pyramid_edge_codes[pyramid_edge_code_count] =$/;"	m	namespace:ma	file:
pyramid_edge_verts	apf/apfMesh.cc	/^int const pyramid_edge_verts[8][2] =$/;"	m	namespace:apf	file:
pyramid_rotation	ma/maTables.cc	/^int const pyramid_rotation[4][5] =$/;"	m	namespace:ma	file:
pyramid_templates	ma/maLayerTemplates.cc	/^SplitFunction pyramid_templates[pyramid_edge_code_count] = $/;"	m	namespace:ma	file:
pyramid_tri_verts	apf/apfMesh.cc	/^int const pyramid_tri_verts[4][3] =$/;"	m	namespace:apf	file:
pyrw	test/ugridptnstats.cc	/^const double pyrw = 6.8;$/;"	v
q	mds/apfMDS.cc	/^  std::deque<apf::MeshEntity*> q;$/;"	m	struct:apf::Queue	file:
q	parma/diffMC/parma_centroidSelector.cc	/^      DistanceQ q;$/;"	m	class:__anon49::DistanceQueue	file:
q	parma/diffMC/parma_distQ.h	/^    DistanceQ q;$/;"	m	class:parma::DistanceQueue
q	parma/diffMC/parma_monitor.h	/^      double* q;$/;"	m	class:parma::CircBuffer
q0	mds/mds.c	/^static int const q0[] = {MDS_VERTEX,MDS_VERTEX,MDS_VERTEX,MDS_VERTEX};$/;"	v	file:
q01	apf_cap/apfCAP.cc	/^static int const q01[] = {};$/;"	m	namespace:apf	file:
q01	mds/mds.c	/^static int const q01[] =     {0,1,1,2,2,3,3,0};$/;"	v	file:
q1	mds/mds.c	/^static int const q1[] = {MDS_EDGE,MDS_EDGE,MDS_EDGE,MDS_EDGE};$/;"	v	file:
q10	apf_cap/apfCAP.cc	/^static int const q10[] = {};$/;"	m	namespace:apf	file:
q10	mds/mds.c	/^static int const q10[] = {3,0,0,1,1,2,2,3};$/;"	v	file:
qMeasure	ma/maQuality.cc	/^static double qMeasure(Mesh* mesh, Entity* e, const Matrix& Q)$/;"	f	namespace:ma
q_degree	test/hierarchic.cc	/^    int q_degree;$/;"	m	class:__anon20::L2Projector	file:
q_degree	test/poisson.cc	/^    int q_degree;$/;"	m	class:__anon17::Poisson	file:
qr	spr/sprRecoverField.cc	/^  QRDecomp qr;$/;"	m	struct:spr::Patch	file:
qr_step	mth/mthQR.cc	/^static bool qr_step($/;"	f	namespace:mth
quad	ma/maEdgeSwap.cc	/^    Entity* quad[4];$/;"	m	class:ma::EdgeSwap2D	file:
quad	ma/maTetrahedronize.cc	/^  Entity* quad;$/;"	m	struct:ma::UnsafePyramidOverride	file:
quad	test/shapefun2.cc	/^static apf::Vector3 const quad[4] = {$/;"	m	class:test::apf	file:
quadToTris	ma/maTemplates.cc	/^void quadToTris(Refine* r, Entity* parent, Entity** v)$/;"	f	namespace:ma
quadToTrisChoice	ma/maTemplates.cc	/^int quadToTrisChoice(Refine* r, Entity* p, Entity** v, int rotation)$/;"	f	namespace:ma
quadToTrisGeometric	ma/maTemplates.cc	/^int quadToTrisGeometric(Refine* r, Entity* parent, Entity** v)$/;"	f	namespace:ma
quadToTrisMixed	ma/maTemplates.cc	/^void quadToTrisMixed(Refine* r, Entity* p, Entity** v, int diagonal)$/;"	f	namespace:ma
quadToTrisRestricted	ma/maTemplates.cc	/^int quadToTrisRestricted(Refine* r, Entity* parent, Entity** v, int good)$/;"	f	namespace:ma
quad_code_match	ma/maLayerTables.cc	/^CodeMatch const quad_code_match[(1<<4)] =$/;"	m	namespace:ma	file:
quad_edge_code_count	ma/maTables.h	/^  quad_edge_code_count = 3,$/;"	e	enum:ma::__anon27
quad_edge_codes	ma/maTables.cc	/^int const quad_edge_codes[quad_edge_code_count] =$/;"	m	namespace:ma	file:
quad_edge_verts	apf/apfMesh.cc	/^int const quad_edge_verts[4][2] =$/;"	m	namespace:apf	file:
quad_templates	ma/maLayerTemplates.cc	/^SplitFunction quad_templates[quad_edge_code_count] = $/;"	m	namespace:ma	file:
quadnomial	crv/crvMath.cc	/^int quadnomial(int n, int i, int j, int k)$/;"	f	namespace:crv
quadratic	test/hierarchic.cc	/^static double quadratic(int d, apf::Vector3 const& p) {$/;"	f	namespace:__anon20
quads	ma/maTetrahedronize.cc	/^  Entity* quads[3];$/;"	m	struct:ma::UnsafePrismOverride	file:
quadw	test/ugridptnstats.cc	/^const double quadw = 1.0;$/;"	v
qual	crv/crvShape.cc	/^  Quality* qual;$/;"	m	class:crv::EdgeReshaper	file:
qual	crv/crvShapeHandler.cc	/^    Quality* qual;$/;"	m	class:crv::BezierHandler	file:
qualityCache	ma/maAdapt.h	/^    Tag* qualityCache; \/\/ to avoid repeated quality computations$/;"	m	class:ma::Adapt
qualityToBeat	ma/maCoarsen.cc	/^    double qualityToBeat;$/;"	m	class:ma::AllEdgeCollapser	file:
qualityToBeat	ma/maEdgeSwap.cc	/^    double qualityToBeat;$/;"	m	class:ma::SwapCavity	file:
qualityTol	test/quality.cc	/^double qualityTol = 0.0;$/;"	m	namespace:__anon21	file:
queue	mds/mds_order.c	/^struct queue {$/;"	s	file:
queue	parma/diffMC/parma_graphDist.cc	/^  typedef std::list<apf::MeshEntity*> queue;$/;"	t	namespace:parma_ordering	file:
queue_empty	mds/mds_order.c	/^static int queue_empty(struct queue* q)$/;"	f	file:
quotient	apf/apfPartition.h	/^  int quotient;$/;"	m	struct:apf::Contract
quotient	apf/apfPartition.h	/^  int quotient;$/;"	m	struct:apf::Expand
r	gmi_sim/gmi_sim.cc	/^    GRIter r;$/;"	m	union:sim_iter::__anon103	file:
r	parma/extractParmaResults.py	/^r = getNewRunLog(runs)$/;"	v
r	spr/sprEstimateError.cc	/^    double r;$/;"	m	class:spr::SInt	file:
rField	ma/maSize.cc	/^  apf::Field* rField;$/;"	m	struct:ma::AnisoSizeField	file:
rRead	phasta/phInput.h	/^    int rRead;$/;"	m	class:ph::Input
rStart	phasta/phInput.h	/^    int rStart;$/;"	m	class:ph::Input
rSz	phasta/phstream.cc	/^    size_t gSz, rSz;$/;"	m	struct:GRStream	file:
rSz	phasta/phstream.cc	/^    size_t rSz;$/;"	m	struct:RStream	file:
radius	apf/apfGeometry.h	/^  double radius;$/;"	m	struct:apf::Plane
radius	phasta/phBubble.cc	/^  double radius;$/;"	m	struct:ph::Bubble	file:
raiseBezierEdge	crv/crvElevation.cc	/^static void raiseBezierEdge(int P, int r, apf::NewArray<T>& nodes,$/;"	f	namespace:crv
raiseBezierTet	crv/crvElevation.cc	/^static void raiseBezierTet(int P, int r, apf::NewArray<T>& nodes,$/;"	f	namespace:crv
raiseBezierTriangle	crv/crvElevation.cc	/^static void raiseBezierTriangle(int P, int r, apf::NewArray<T>& nodes,$/;"	f	namespace:crv
ramdisk	phasta/phInput.h	/^    int ramdisk;$/;"	m	class:ph::Input
randNum	parma/diffMC/maximalIndependentSet/mis.h	/^        unsigned randNum;$/;"	m	struct:misLuby::AdjPart
randNum	parma/diffMC/maximalIndependentSet/mis.h	/^        unsigned randNum;$/;"	m	struct:misLuby::PartInfo
range	gmi/gmi.h	/^  void (*range)(struct gmi_model* m, struct gmi_ent* e, int dim,$/;"	m	struct:gmi_model_ops
range	gmi/gmi_analytic.c	/^static void range(struct gmi_model* m, struct gmi_ent* e, int dim, double r[2])$/;"	f	file:
range	gmi_cap/gmi_cap.cc	/^static void range(struct gmi_model* m, struct gmi_ent* e, int dim,$/;"	f	file:
range	gmi_sim/gmi_sim.cc	/^static void range(struct gmi_model* m, struct gmi_ent* e, int dim,$/;"	f	file:
ranges	gmi/gmi_analytic.c	/^  struct agm_tag* ranges;$/;"	m	struct:gmi_analytic	typeref:struct:gmi_analytic::agm_tag	file:
ranges_of	gmi/gmi_analytic.c	/^static ranges_t* ranges_of(struct gmi_analytic* m, struct agm_ent e)$/;"	f	file:
ranges_t	gmi/gmi_analytic.c	/^typedef double ranges_t[2][2];$/;"	t	file:
rank	pcu/pcu_mpi.h	/^  int (*rank)(void);$/;"	m	struct:__anon34
rbParamData	phasta/phInput.h	/^    std::vector<double> rbParamData;$/;"	m	class:ph::Input
re	parma/extractParmaResults.py	/^import re$/;"	i
reach_down	mds/mds.c	/^static struct down reach_down(struct mds* m, mds_id e, int d)$/;"	f	file:
read	stk/apfSTK.cc	/^    virtual void read($/;"	f	class:apf::NodalBridge
read	stk/apfSTK.cc	/^    virtual void read($/;"	f	class:apf::QPBridge
readAndAttachField	phasta/phRestart.cc	/^int readAndAttachField($/;"	f	namespace:ph
readAndAttachFields	phasta/phCook.cc	/^  void readAndAttachFields(ph::Input& ctrl, apf::Mesh2*& m) {$/;"	f	namespace:chef
readAndAttachFields	phasta/phRestart.cc	/^void readAndAttachFields(Input& in, apf::Mesh* m) {$/;"	f	namespace:ph
readBC	phasta/phBC.cc	/^static void readBC(std::string const& line, BCs& bcs)$/;"	f	namespace:ph
readBCs	phasta/phBC.cc	/^void readBCs(gmi_model* m, const char* attFile, bool axisymmetry, BCs& bcs)$/;"	f	namespace:ph
readBCsFromSPJ	phasta/phBC.cc	/^static void readBCsFromSPJ(const char* filename, BCs& bcs)$/;"	f	namespace:ph
readBubbles	phasta/phBubble.cc	/^void readBubbles(Bubbles& bubbles, std::string bubbleFileName)$/;"	f	namespace:ph
readBytes	phasta/phiotimer.cc	/^  size_t readBytes[NUM_PHASTAIO_MODES];$/;"	m	struct:phastaio_stats	file:
readCoords	test/icesheet.cc	/^void readCoords(FILE* f, unsigned numvtx, double* coordinates) {$/;"	f
readDoubles	mds/mdsUgrid.cc	/^  void readDoubles(FILE* f, double* vals, size_t cnt, bool swap) {$/;"	f	namespace:__anon101
readElement	mds/mdsGmsh.cc	/^void readElement(Reader* r)$/;"	f	namespace:__anon96
readElements	mds/mdsGmsh.cc	/^void readElements(Reader* r)$/;"	f	namespace:__anon96
readElements	test/icesheet.cc	/^void readElements(FILE* f, unsigned numelms, int numVtxPerElm,$/;"	f
readElms	mds/mdsUgrid.cc	/^  void readElms(Reader* r, header* h) {$/;"	f	namespace:__anon101
readElms	mds/mdsUgrid.cc	/^  void readElms(Reader* r, unsigned nelms, int apfType) {$/;"	f	namespace:__anon101
readElms	mds/mdsUgrid.cc	/^  void readElms(Reader* r, unsigned nelms, int apfType,$/;"	f	namespace:__anon101
readFaces	mds/mdsUgrid.cc	/^  void readFaces(Reader* r, unsigned nfaces, int apfType) {$/;"	f	namespace:__anon101
readFacesAndTags	mds/mdsUgrid.cc	/^  void readFacesAndTags(Reader* r, header* h) {$/;"	f	namespace:__anon101
readGmsh	mds/mdsGmsh.cc	/^void readGmsh(apf::Mesh2* m, const char* filename)$/;"	f	namespace:__anon96
readHeader	mds/mdsUgrid.cc	/^  void readHeader(Reader* r, header* h) {$/;"	f	namespace:__anon101
readHeader	test/icesheet.cc	/^void readHeader(FILE* f, unsigned& nodes, unsigned& elms, unsigned& numVtxPerElm) {$/;"	f
readInputFile	phasta/phInput.cc	/^static void readInputFile($/;"	f	namespace:ph
readIntArray	test/icesheet.cc	/^int* readIntArray(const char* fname, unsigned len) {$/;"	f
readLayerCoordinates	test/capStoneAttachSolution.cc	/^readLayerCoordinates(int layer, const std::vector<row> &t, int s)$/;"	f	file:
readMesh	test/icesheet.cc	/^void readMesh(const char* meshfilename, MeshInfo& mesh) {$/;"	f
readNode	mds/mdsGmsh.cc	/^void readNode(Reader* r)$/;"	f	namespace:__anon96
readNodes	mds/mdsGmsh.cc	/^void readNodes(Reader* r)$/;"	f	namespace:__anon96
readNodes	mds/mdsUgrid.cc	/^  void readNodes(Reader* r, header* h) {$/;"	f	namespace:__anon101
readQuadratic	mds/mdsGmsh.cc	/^void readQuadratic(Reader* r, apf::Mesh2* m, const char* filename)$/;"	f	namespace:__anon96
readQuadraticElement	mds/mdsGmsh.cc	/^void readQuadraticElement(Reader* r)$/;"	f	namespace:__anon96
readScalarArray	test/icesheet.cc	/^double* readScalarArray(const char* fname, unsigned len) {$/;"	f
readStkField	stk/apfSTK.cc	/^void readStkField($/;"	f	namespace:apf
readTable	test/capStoneAttachSolution.cc	/^std::vector<row> readTable(const char* name)$/;"	f
readTags	mds/mdsUgrid.cc	/^  void readTags(Reader* r, unsigned nfaces, int apfType) {$/;"	f	namespace:__anon101
readTime	phasta/phiotimer.cc	/^  size_t readTime[NUM_PHASTAIO_MODES];$/;"	m	struct:phastaio_stats	file:
readUgrid	mds/mdsUgrid.cc	/^  void readUgrid(apf::Mesh2* m, const char* filename)$/;"	f	namespace:__anon101
readUnsigneds	mds/mdsUgrid.cc	/^  void readUnsigneds(FILE* f, unsigned* v, size_t cnt, bool swap) {$/;"	f	namespace:__anon101
read_class	mds/mds_smb.c	/^static void read_class(struct pcu_file* f, struct mds_apf* m)$/;"	f	file:
read_conn	mds/mds_smb.c	/^static void read_conn(struct pcu_file* f, struct mds_apf* m)$/;"	f	file:
read_dbl_tag	mds/mds_smb.c	/^static void read_dbl_tag(struct pcu_file* f, struct mds_apf* m,$/;"	f	file:
read_header	mds/mds_smb.c	/^static void read_header(struct pcu_file* f, unsigned* version, unsigned* dim,$/;"	f	file:
read_int_tag	mds/mds_smb.c	/^static void read_int_tag(struct pcu_file* f, struct mds_apf* m,$/;"	f	file:
read_links	mds/mds_smb.c	/^static void read_links(struct pcu_file* f, struct mds_links* l)$/;"	f	file:
read_magic_number	phasta/phIO.c	/^static int read_magic_number(FILE* f)$/;"	f	file:
read_matches_new	mds/mds_smb.c	/^static void read_matches_new(struct pcu_file* f, struct mds_apf* m,$/;"	f	file:
read_matches_old	mds/mds_smb.c	/^static void read_matches_old(struct pcu_file* f, struct mds_apf* m,$/;"	f	file:
read_remotes	mds/mds_smb.c	/^static void read_remotes(struct pcu_file* f, struct mds_apf* m,$/;"	f	file:
read_smb	mds/mds_smb.c	/^static struct mds_apf* read_smb(struct gmi_model* model, const char* filename,$/;"	f	file:
read_tag_header	mds/mds_smb.c	/^static struct mds_tag* read_tag_header(struct pcu_file* f, struct mds_apf* m)$/;"	f	file:
read_tags	mds/mds_smb.c	/^static void read_tags(struct pcu_file* f, struct mds_apf* m)$/;"	f	file:
read_type_matches	mds/mds_smb.c	/^static void read_type_matches(struct pcu_file* f, struct mds_apf* m, int t,$/;"	f	file:
reader	ma/maSize.cc	/^  FieldReader reader;$/;"	m	struct:ma::IsoUserField	file:
reads	phasta/phiotimer.cc	/^  size_t reads[NUM_PHASTAIO_MODES];$/;"	m	struct:phastaio_stats	file:
ready	pcu/pcu_order.c	/^  bool ready;$/;"	m	struct:pcu_order_struct	file:
rebuild	mds/mds_order.c	/^static struct mds_apf* rebuild($/;"	f	file:
rebuildCallback	ma/maCollapse.h	/^    RebuildCallback* rebuildCallback;$/;"	m	class:ma::Collapse
rebuildElement	ma/maAdapt.cc	/^Entity* rebuildElement($/;"	f	namespace:ma
rebuildElement	ma/maMesh.cc	/^Entity* rebuildElement($/;"	f	namespace:ma
rebuildElements	ma/maCollapse.cc	/^void Collapse::rebuildElements()$/;"	f	class:ma::Collapse
rebuildElements	ma/maLayerCollapse.cc	/^void LayerCollapse::rebuildElements()$/;"	f	class:ma::LayerCollapse
rebuildLayerElement	ma/maLayerCollapse.cc	/^static Entity* rebuildLayerElement($/;"	f	namespace:ma
rebuild_coords	mds/mds_order.c	/^static void rebuild_coords($/;"	f	file:
rebuild_ents	mds/mds_order.c	/^static void rebuild_ents($/;"	f	file:
rebuild_net	mds/mds_order.c	/^static void rebuild_net(struct mds_net* net,$/;"	f	file:
rebuild_parts	mds/mds_order.c	/^static void rebuild_parts($/;"	f	file:
rebuild_tags	mds/mds_order.c	/^static void rebuild_tags($/;"	f	file:
rebuild_verts	mds/mds_order.c	/^static void rebuild_verts($/;"	f	file:
rebuilds	ma/maMatchedCollapse.h	/^  Rebuilds rebuilds;$/;"	m	struct:ma::MatchedCollapse
rebuilt	ma/maMatchedCollapse.cc	/^void Rebuilds::rebuilt(Entity* e, Entity* original)$/;"	f	class:ma::Rebuilds
receive	pcu/pcu_mpi.h	/^  bool (*receive)(pcu_message* m, MPI_Comm comm);$/;"	m	struct:__anon34
receiveAlignment	apf/apfVerify.cc	/^static void receiveAlignment(Mesh* m)$/;"	f	namespace:apf
receiveAllCopies	apf/apfVerify.cc	/^static void receiveAllCopies(Mesh* m)$/;"	f	namespace:apf
receiveCoords	apf/apfVerify.cc	/^static bool receiveCoords(Mesh* m)$/;"	f	namespace:apf
receiveEntities	apf/apfMigrate.cc	/^static void receiveEntities($/;"	f	namespace:apf
receiveFieldData	pumi/pumi_field.cc	/^static void receiveFieldData(std::vector<pField>& fields, std::set<pField>& mismatch_fields)$/;"	f	file:
receiveGhostCopies	apf/apfVerify.cc	/^static void receiveGhostCopies(Mesh* m)$/;"	f	namespace:apf
receiveMatches	apf/apfVerify.cc	/^static void receiveMatches(Mesh* m)$/;"	f	namespace:apf
receiveRemotes	apf/apfMigrate.cc	/^static void receiveRemotes(Mesh2* m)$/;"	f	namespace:apf
receiveTagData	apf/apfVerify.cc	/^static void receiveTagData(Mesh* m, DynamicArray<MeshTag*>& tags)$/;"	f	namespace:apf
receive_global	pcu/pcu_msg.c	/^static bool receive_global(pcu_msg* m)$/;"	f	file:
received	pcu/pcu_msg.h	/^  pcu_message received; \/\/current received buffer$/;"	m	struct:pcu_msg_struct
reclassifyEdge	ma/maRegionCollapse.h	/^    Entity* reclassifyEdge;$/;"	m	class:ma::RegionCollapse
reconfigureChef	phasta/adaptLvlSet_loop.cc	/^  void reconfigureChef(ph::Input& ctrl) {$/;"	f	namespace:__anon83
reconfigureChef	phasta/chefStream.cc	/^  void reconfigureChef(ph::Input& ctrl) {$/;"	f	namespace:__anon84
recoverField	spr/sprRecoverField.cc	/^apf::Field* recoverField(apf::Field* f)$/;"	f	namespace:spr
recoverGradientByVolume	apf/apfGradientByVolume.cc	/^Field* recoverGradientByVolume(Field* f)$/;"	f	namespace:apf
recoverGradientByVolume	apf/apfGradientByVolume.cc	/^void recoverGradientByVolume(Field* f, Field* gradf)$/;"	f	namespace:apf
recovered_order	spr/sprEstimateError.cc	/^  int recovered_order;$/;"	m	struct:spr::Estimation	file:
recovered_order	spr/sprEstimateTargetError.cc	/^  int recovered_order;$/;"	m	struct:spr::target::Estimation	file:
recovery	spr/sprRecoverField.cc	/^  Recovery* recovery;$/;"	m	struct:spr::Patch	file:
recursiveUR	phasta/phInput.h	/^    int recursiveUR;$/;"	m	class:ph::Input
recursivelyBisect	parma/rib/parma_rib.cc	/^void recursivelyBisect(Bodies* all, int depth, Bodies out[])$/;"	f	namespace:parma
recv	ma/maCrawler.cc	/^  bool recv(Entity* v, int)$/;"	f	struct:ma::LayerNumberer
recv	ma/maLayerCoarsen.cc	/^  bool recv(Entity* v, int)$/;"	f	struct:ma::CurveLocalizer
recv	ma/maLayerRefine.cc	/^  bool recv(Entity* e, int)$/;"	f	struct:ma::SplitTagger
recv	ma/maLayerRefine.cc	/^  bool recv(Entity* t, int)$/;"	f	struct:ma::Disambiguator
recv	ma/maLayerSnap.cc	/^  bool recv(Entity* v, int)$/;"	f	struct:ma::BaseTopLinker
recv	ma/maLayerSnap.cc	/^  bool recv(Entity* v, int)$/;"	f	struct:ma::LayerSnapper
recv	ma/maLayerSnap.cc	/^  bool recv(Entity* v, int)$/;"	f	struct:ma::SnapTagger
recv	ma/maLayerSnap.cc	/^  bool recv(Entity* v, int)$/;"	f	struct:ma::UnsnapChecker
recv	ma/maLayerSnap.cc	/^  bool recv(Entity* v, int)$/;"	f	struct:ma::Unsnapper
recv	ma/maTetrahedronize.cc	/^  bool recv(Entity* e, int)$/;"	f	struct:ma::QuadFlagger
recv	ma/maTetrahedronize.cc	/^  bool recv(Entity* e, int)$/;"	f	struct:ma::QuadMarker
recvAdjNetsFromNeighbors	parma/diffMC/maximalIndependentSet/misLuby.cc	/^  void recvAdjNetsFromNeighbors(vector<adjPart>& msg) {$/;"	f	namespace:__anon50
recvIntsFromNeighbors	parma/diffMC/maximalIndependentSet/misLuby.cc	/^  void recvIntsFromNeighbors(vector<int>& msg, int tag) {$/;"	f	namespace:__anon50
recvNetsFromNeighbors	parma/diffMC/maximalIndependentSet/misLuby.cc	/^  void recvNetsFromNeighbors(vector<adjPart>& msg) {$/;"	f	namespace:__anon50
recv_down_copies	mds/mds_apf.c	/^static int recv_down_copies(struct mds_net* net, struct mds* m)$/;"	f	file:
recv_links	mds/mds_net.c	/^static void recv_links(struct mds_links* ln)$/;"	f	file:
recv_state	pcu/pcu_msg.c	/^  recv_state \/\/sends are done, still receiving$/;"	e	enum:__anon32	file:
reduce	mth/mthQR.cc	/^static bool reduce(Matrix<T,M,M> const& a, unsigned& red_m)$/;"	f	namespace:mth
reduce	pcu/pcu_coll.c	/^static pcu_pattern reduce =$/;"	v	file:
reduceFieldData	apf/apfFieldData.cc	/^void reduceFieldData(FieldDataOf<double>* data, Sharing* shr, bool delete_shr, const ReductionOp<double>& reduce_op \/* =ReductionSum<double>() *\/)$/;"	f	namespace:apf
reduceMatchingToSenders	apf/apfMigrate.cc	/^void reduceMatchingToSenders($/;"	f	namespace:apf
reduceToHessenberg	mth/mthQR.cc	/^void reduceToHessenberg(Matrix<T,M,M> const& a, Matrix<T,M,M>& q,$/;"	f	namespace:mth
reduce_action	pcu/pcu_coll.c	/^static int reduce_action(int bit)$/;"	f	file:
reduce_begin_bit	pcu/pcu_coll.c	/^static int reduce_begin_bit(void)$/;"	f	file:
reduce_end_bit	pcu/pcu_coll.c	/^static bool reduce_end_bit(int bit)$/;"	f	file:
reduce_peer	pcu/pcu_coll.c	/^static int reduce_peer(int bit)$/;"	f	file:
reduce_shift	pcu/pcu_coll.c	/^static int reduce_shift(int bit)$/;"	f	file:
reel_fail	pcu/reel/reel.c	/^void reel_fail(const char* format, ...)$/;"	f
reel_protect	pcu/reel/reel.c	/^void reel_protect(void)$/;"	f
reel_trace	pcu/reel/reel.c	/^void reel_trace(void)$/;"	f
refine	crv/crvAdapt.cc	/^static void refine(ma::Adapt* a)$/;"	f	namespace:crv
refine	crv/crvShapeHandler.cc	/^    ma::Refine* refine;$/;"	m	class:crv::BezierTransfer	file:
refine	ma/maAdapt.h	/^    Refine* refine;$/;"	m	class:ma::Adapt
refine	ma/maRefine.cc	/^bool refine(Adapt* a)$/;"	f	namespace:ma
refiner	ma/maSplits.h	/^    Refine* refiner;$/;"	m	class:ma::Splits
refinesLeft	ma/maAdapt.h	/^    int refinesLeft;$/;"	m	class:ma::Adapt
reflect_columns	mth/mthQR.cc	/^static void reflect_columns($/;"	f	namespace:mth
reflect_rows	mth/mthQR.cc	/^static void reflect_rows($/;"	f	namespace:mth
refs	mds/apfPM.h	/^  int refs;$/;"	m	struct:apf::PME
region	ma/maRegionCollapse.h	/^    Entity* region;$/;"	m	class:ma::RegionCollapse
region_faces	gmi_sim/gmi_sim.cc	/^static gmi_set* region_faces(pGRegion region)$/;"	f	file:
registerSelf	apf/apfShape.cc	/^void FieldShape::registerSelf(const char* name_)$/;"	f	class:apf::FieldShape
registry	apf/apfShape.cc	/^static std::map<std::string, FieldShape*> registry;$/;"	m	namespace:apf	file:
reject	apf/apfVector.h	/^Vector<N> reject(Vector<N> const& a, Vector<N> const& b)$/;"	f	namespace:apf
reject	mth/mth_def.h	/^Vector<T,N> reject(Vector<T,N> const& a, Vector<T,N> const& b)$/;"	f	namespace:mth
rejectInput	ma/maInput.cc	/^void rejectInput(const char* str)$/;"	f	namespace:ma
relate_back_up	mds/mds.c	/^static void relate_back_up(struct mds* m, mds_id* from, mds_id to)$/;"	f	file:
relate_both	mds/mds.c	/^static void relate_both(struct mds* m, mds_id* down, mds_id up)$/;"	f	file:
relate_down	mds/mds.c	/^static void relate_down(struct mds* m, mds_id from, mds_id* to)$/;"	f	file:
relate_up	mds/mds.c	/^static void relate_up(struct mds* m, mds_id e, mds_id node)$/;"	f	file:
relativeDirection	ma/maRegionCollapse.cc	/^static int relativeDirection(Vector n1, Vector n2, double flatAngle)$/;"	f	namespace:ma
remainder	apf/apfPartition.h	/^  int remainder;$/;"	m	struct:apf::Contract
remainder	apf/apfPartition.h	/^  int remainder;$/;"	m	struct:apf::Expand
remapMatches	apf/apfPartition.cc	/^static void remapMatches(apf::Mesh2* m, Remap& remap)$/;"	f	namespace:apf
remapPM	mds/apfPM.cc	/^void remapPM(PM& pm,$/;"	f	namespace:apf
remapPartition	apf/apfPartition.cc	/^void remapPartition(apf::Mesh2* m, Remap& remap)$/;"	f	namespace:apf
remapRemotes	apf/apfPartition.cc	/^static void remapRemotes(apf::Mesh2* m, Remap& remap)$/;"	f	namespace:apf
remapResidence	apf/apfPartition.cc	/^static void remapResidence(apf::Mesh2* m, Remap& remap)$/;"	f	namespace:apf
remotes	mds/mds_apf.h	/^  struct mds_net remotes;$/;"	m	struct:mds_apf	typeref:struct:mds_apf::mds_net
remove	apf_cap/apfCAP.cc	/^    void remove(MeshEntity* e)$/;"	f	class:apf::TagCAP
remove	apf_sim/apfSIM.cc	/^    void remove(MeshEntity* e)$/;"	f	class:apf::TagSIM
remove	pumi/pumi_list.h	/^    void remove(ListMember* m)$/;"	f	class:List
remove3DPortion	ma/maExtrude.cc	/^void remove3DPortion(Mesh* m, ModelSet const& bottoms) {$/;"	f	namespace:ma::__anon28
removeEntity	apf/apfArrayData.cc	/^    virtual void removeEntity(MeshEntity*)$/;"	f	class:apf::ArrayDataOf
removeEntity	apf/apfCoordData.cc	/^void CoordData::removeEntity(MeshEntity*)$/;"	f	class:apf::CoordData
removeEntity	apf/apfTagData.cc	/^void TagData::removeEntity(MeshEntity* e)$/;"	f	class:apf::TagData
removeEntity	apf/apfTagData.h	/^    virtual void removeEntity(MeshEntity* e) {tagData.removeEntity(e);}$/;"	f	class:apf::TagDataOf
removeEntity	apf/apfUserData.cc	/^void UserData::removeEntity(MeshEntity*)$/;"	f	class:apf::UserData
removeEntity	apf_sim/apfSIMDataOf.h	/^  virtual void removeEntity(MeshEntity *)$/;"	f	class:apf::SIMDataOf
removeEntry	pumi/GenTag.cc	/^static void removeEntry(Entry*& container, int e, int& size)$/;"	f	file:
removeField	apf/apfMesh.cc	/^void Mesh::removeField(Field* f)$/;"	f	class:apf::Mesh
removeGlobalNumbering	apf/apfMesh.cc	/^void Mesh::removeGlobalNumbering(GlobalNumbering* n)$/;"	f	class:apf::Mesh
removeNodes	parma/diffMC/maximalIndependentSet/misLuby.cc	/^  void removeNodes(partInfo& p, vector<int>& nodes) {$/;"	f	namespace:__anon50
removeNumbering	apf/apfMesh.cc	/^void Mesh::removeNumbering(Numbering* n)$/;"	f	class:apf::Mesh
removeTag	apf_cap/apfCAP.cc	/^void MeshCAP::removeTag(MeshEntity* e, MeshTag* tag)$/;"	f	class:apf::MeshCAP
removeTag	apf_sim/apfSIM.cc	/^void MeshSIM::removeTag(MeshEntity* e, MeshTag* tag)$/;"	f	class:apf::MeshSIM
removeTag	mds/apfMDS.cc	/^    void removeTag(MeshEntity* e, MeshTag* t)$/;"	f	class:apf::MeshMDS
removeTagFromDimension	apf/apfMesh.cc	/^void removeTagFromDimension(Mesh* m, MeshTag* tag, int d)$/;"	f	namespace:apf
removeUnusedVerts	test/capStoneAttachSolution.cc	/^void removeUnusedVerts(apf::Mesh2* m, int offset)$/;"	f
remove_ext	mds/mds_smb.c	/^static void remove_ext(char* s, const char* ext)$/;"	f	file:
remove_prefix	mds/mds_smb.c	/^static void remove_prefix(char* s, const char* prefix)$/;"	f	file:
remove_successor	pcu/pcu_aa.c	/^static void remove_successor(pcu_aa_tree* t, struct remove_vars* v)$/;"	f	file:
remove_vars	pcu/pcu_aa.c	/^struct remove_vars$/;"	s	file:
remover	crv/crvShapeFixer.h	/^    ma::ShortEdgeRemover remover;$/;"	m	class:crv::CrvLargeAngleTriFixer
remover	crv/crvShapeFixer.h	/^    ma::ShortEdgeRemover remover;$/;"	m	class:crv::CrvShortEdgeFixer
remover	ma/maShape.cc	/^    ShortEdgeRemover remover;$/;"	m	class:ma::ShortEdgeFixer	file:
rename	apf/apfField.cc	/^void FieldBase::rename(const char* newName)$/;"	f	class:apf::FieldBase
rename	apf/apfFieldData.cc	/^void FieldData::rename(const char*)$/;"	f	class:apf::FieldData
rename	apf/apfTagData.cc	/^void TagData::rename(const char* newName)$/;"	f	class:apf::TagData
rename	apf/apfTagData.h	/^    virtual void rename(const char* newName)$/;"	f	class:apf::TagDataOf
rename	apf_cap/apfCAP.cc	/^    void rename(const char* n)$/;"	f	class:apf::TagCAP
rename	apf_sim/apfSIMDataOf.h	/^  virtual void rename(const char* name)$/;"	f	class:apf::SIMDataOf
renameField	apf/apf.cc	/^void renameField(Field* f, const char* name)$/;"	f	namespace:apf
renameTag	apf_cap/apfCAP.cc	/^void MeshCAP::renameTag(MeshTag* tag, const char* name)$/;"	f	class:apf::MeshCAP
renameTag	apf_sim/apfSIM.cc	/^void MeshSIM::renameTag(MeshTag*, const char*)$/;"	f	class:apf::MeshSIM
renameTag	mds/apfMDS.cc	/^    void renameTag(MeshTag* t, const char* newName)$/;"	f	class:apf::MeshMDS
reorder	apf/apfAdjReorder.cc	/^  MeshTag* reorder(Mesh* mesh, const char* name)$/;"	f	namespace:apf
reorder	parma/diffMC/parma_components.cc	/^  void DCC::reorder(unsigned* order) {$/;"	f	class:parma::DCC
reorder	parma/diffMC/parma_graphDist.cc	/^  apf::MeshTag* reorder(apf::Mesh* m, parma::dcComponents& c, apf::MeshTag* dist) {$/;"	f	namespace:parma_ordering
reorderConnected	apf/apfAdjReorder.cc	/^  void reorderConnected($/;"	f	namespace:apf
reorderData	apf/apfFieldData.cc	/^void reorderData(T const dataIn[], T dataOut[], int const order[], int nc, int nn)$/;"	f	namespace:apf
reorderMdsMesh	mds/apfMDS.cc	/^void reorderMdsMesh(Mesh2* mesh, MeshTag* t)$/;"	f	namespace:apf
reparam	gmi/gmi.h	/^  void (*reparam)(struct gmi_model* m, struct gmi_ent* from,$/;"	m	struct:gmi_model_ops
reparam	gmi/gmi_analytic.c	/^  struct agm_tag* reparam;$/;"	m	struct:gmi_analytic	typeref:struct:gmi_analytic::agm_tag	file:
reparam	gmi/gmi_analytic.c	/^static void reparam(struct gmi_model* m, struct gmi_ent* from,$/;"	f	file:
reparam	gmi_cap/gmi_cap.cc	/^static void reparam(struct gmi_model* m, struct gmi_ent* from,$/;"	f	file:
reparam	gmi_sim/gmi_sim.cc	/^static void reparam(struct gmi_model* m, struct gmi_ent* from,$/;"	f	file:
reparam_across	gmi/gmi_analytic.c	/^static void reparam_across(struct gmi_analytic* m, struct agm_use u,$/;"	f	file:
reparam_data	gmi/gmi_analytic.c	/^  struct agm_tag* reparam_data;$/;"	m	struct:gmi_analytic	typeref:struct:gmi_analytic::agm_tag	file:
reparam_data_of	gmi/gmi_analytic.c	/^static void** reparam_data_of(struct gmi_analytic* m, struct agm_use u)$/;"	f	file:
reparam_of	gmi/gmi_analytic.c	/^static gmi_reparam_fun* reparam_of(struct gmi_analytic* m, struct agm_use u)$/;"	f	file:
reparam_one	test/bezierElevation.cc	/^void reparam_one(double const from[2], double to[2], void*)$/;"	f
reparam_one	test/bezierMesh.cc	/^void reparam_one(double const from[2], double to[2], void*)$/;"	f
reparam_one	test/bezierRefine.cc	/^void reparam_one(double const from[2], double to[2], void*)$/;"	f
reparam_one	test/bezierSubdivision.cc	/^void reparam_one(double const from[2], double to[2], void*)$/;"	f
reparam_one	test/bezierValidity.cc	/^void reparam_one(double const from[2], double to[2], void*)$/;"	f
reparam_one	test/fusion3.cc	/^void reparam_one(double const from[2], double to[2], void*)$/;"	f
reparam_path	gmi/gmi_analytic.c	/^static void reparam_path(struct gmi_analytic* m, struct agm_use* path,$/;"	f	file:
reparam_zero	test/bezierElevation.cc	/^void reparam_zero(double const from[2], double to[2], void*)$/;"	f
reparam_zero	test/bezierMesh.cc	/^void reparam_zero(double const from[2], double to[2], void*)$/;"	f
reparam_zero	test/bezierRefine.cc	/^void reparam_zero(double const from[2], double to[2], void*)$/;"	f
reparam_zero	test/bezierSubdivision.cc	/^void reparam_zero(double const from[2], double to[2], void*)$/;"	f
reparam_zero	test/bezierValidity.cc	/^void reparam_zero(double const from[2], double to[2], void*)$/;"	f
reparam_zero	test/fusion3.cc	/^void reparam_zero(double const from[2], double to[2], void*)$/;"	f
repeatMdsMesh	mds/apfMDS.cc	/^Mesh2* repeatMdsMesh(Mesh2* m, gmi_model* g, Migration* plan,$/;"	f	namespace:apf
replaceAdjacencies	phasta/phInterfaceCutter.cc	/^static void replaceAdjacencies(apf::Mesh2* m,$/;"	f	namespace:ph
repositionEdge	crv/crvShape.cc	/^  bool repositionEdge(ma::Entity* edge)$/;"	f	class:crv::EdgeReshaper	file:
repositionInteriorWithBlended	crv/crvReposition.cc	/^void repositionInteriorWithBlended(ma::Mesh* m, ma::Entity* e)$/;"	f	namespace:crv
repositionInvalidEdges	crv/crvShape.cc	/^static void repositionInvalidEdges(Adapt* a)$/;"	f	namespace:crv
repositionVertex	ma/maReposition.cc	/^bool repositionVertex(Mesh* m, Entity* v,$/;"	f	namespace:ma
request	pcu/pcu_mpi.h	/^  MPI_Request request;$/;"	m	struct:__anon33
requestLocality	apf/apfCavityOp.cc	/^bool CavityOp::requestLocality(MeshEntity** entities, int count)$/;"	f	class:apf::CavityOp
requestLocality	crv/crvShape.cc	/^  virtual bool requestLocality(apf::CavityOp* o)$/;"	f	class:crv::EdgeReshaper
requestLocality	crv/crvShape.cc	/^  virtual bool requestLocality(apf::CavityOp* o)$/;"	f	class:crv::EdgeSwapper
requestLocality	crv/crvShapeFixer.cc	/^bool CrvEdgeEdgeFixer::requestLocality(apf::CavityOp* o)$/;"	f	class:crv::CrvEdgeEdgeFixer
requestLocality	crv/crvShapeFixer.cc	/^bool CrvFaceVertFixer::requestLocality(apf::CavityOp* o)$/;"	f	class:crv::CrvFaceVertFixer
requestLocality	crv/crvShapeFixer.cc	/^bool CrvLargeAngleTetFixer::requestLocality(apf::CavityOp* o)$/;"	f	class:crv::CrvLargeAngleTetFixer
requestLocality	crv/crvShapeFixer.cc	/^bool CrvLargeAngleTriFixer::requestLocality(apf::CavityOp* o)$/;"	f	class:crv::CrvLargeAngleTriFixer
requestLocality	crv/crvShapeFixer.cc	/^bool CrvShortEdgeFixer::requestLocality(apf::CavityOp* o)$/;"	f	class:crv::CrvShortEdgeFixer
requestLocality	ma/maCoarsen.cc	/^    virtual bool requestLocality(apf::CavityOp* o)$/;"	f	class:ma::AllEdgeCollapser
requestLocality	ma/maCoarsen.cc	/^    virtual bool requestLocality(apf::CavityOp* o)$/;"	f	class:ma::MatchedEdgeCollapser
requestLocality	ma/maCollapse.cc	/^bool Collapse::requestLocality(apf::CavityOp* o)$/;"	f	class:ma::Collapse
requestLocality	ma/maMatchedCollapse.cc	/^bool MatchedCollapse::requestLocality(apf::CavityOp* o)$/;"	f	class:ma::MatchedCollapse
requestLocality	ma/maMatchedSnapper.cc	/^bool MatchedSnapper::requestLocality(apf::CavityOp* o)$/;"	f	class:ma::MatchedSnapper
requestLocality	ma/maRegionCollapse.cc	/^bool RegionCollapse::requestLocality(apf::CavityOp* o)$/;"	f	class:ma::RegionCollapse
requestLocality	ma/maShape.cc	/^    virtual bool requestLocality(apf::CavityOp* o)$/;"	f	class:ma::EdgeEdgeFixer
requestLocality	ma/maShape.cc	/^    virtual bool requestLocality(apf::CavityOp* o)$/;"	f	class:ma::FaceVertFixer
requestLocality	ma/maShape.cc	/^    virtual bool requestLocality(apf::CavityOp* o)$/;"	f	class:ma::FixBySwap
requestLocality	ma/maShape.cc	/^    virtual bool requestLocality(apf::CavityOp* o)$/;"	f	class:ma::LargeAngleTetAligner
requestLocality	ma/maShape.cc	/^    virtual bool requestLocality(apf::CavityOp* o)$/;"	f	class:ma::LargeAngleTetFixer
requestLocality	ma/maShape.cc	/^    virtual bool requestLocality(apf::CavityOp* o)$/;"	f	class:ma::LargeAngleTriFixer
requestLocality	ma/maShape.cc	/^    virtual bool requestLocality(apf::CavityOp* o)$/;"	f	class:ma::QualityImprover2D
requestLocality	ma/maShape.cc	/^    virtual bool requestLocality(apf::CavityOp* o)$/;"	f	class:ma::ShortEdgeFixer
requestLocality	ma/maShortEdgeRemover.cc	/^bool ShortEdgeRemover::requestLocality(apf::CavityOp* o)$/;"	f	class:ma::ShortEdgeRemover
requestLocality	ma/maSnap.cc	/^    bool requestLocality(apf::CavityOp* o)$/;"	f	class:ma::SnapAll
requestLocality	ma/maSnap.cc	/^    bool requestLocality(apf::CavityOp* o)$/;"	f	class:ma::SnapMatched
requestLocality	ma/maSnap_mohara.cc	/^    bool requestLocality(apf::CavityOp* o)$/;"	f	class:ma::SnapAll
requestLocality	ma/maSnap_mohara.cc	/^    bool requestLocality(apf::CavityOp* o)$/;"	f	class:ma::SnapMatched
requestLocality	ma/maSnapper.cc	/^bool Snapper::requestLocality(apf::CavityOp* o)$/;"	f	class:ma::Snapper
requests	apf/apfCavityOp.h	/^    Requests requests;$/;"	m	class:apf::CavityOp
requireUnfrozen	apf/apfMesh2.h	/^    void requireUnfrozen()$/;"	f	class:apf::Mesh2
requiresRotation	phasta/phAxisymmetry.cc	/^static bool requiresRotation(gmi_model* gm, BCs& bcs, gmi_ent* e, gmi_ent* oe,$/;"	f	namespace:ph
reset	ma/maAdapt.cc	/^void NewEntities::reset()$/;"	f	class:ma::NewEntities
reset	ma/maMatchedCollapse.cc	/^void Rebuilds::reset()$/;"	f	class:ma::Rebuilds
reset	parma/diffMC/parma_dcpart.cc	/^void dcPart::reset() {$/;"	f	class:dcPart
reset	pumi/GenIterator.h	/^    inline void reset ()$/;"	f	class:GenIterator
reset	spr/sprEstimateError.cc	/^    void reset() {r=0;}$/;"	f	class:spr::SInt
resetCollection	ma/maRefine.cc	/^void resetCollection(Refine* r)$/;"	f	namespace:ma
resetCount	test/test_integrator.cc	/^    void resetCount() { numEnt = 0; }$/;"	f	class:CountIntegrator
resetDist	parma/diffMC/parma_dijkstra.cc	/^  void resetDist(apf::Mesh* m, parma::DijkstraContains* c, apf::MeshTag* d) {$/;"	f	namespace:__anon70
resetLayer	ma/maLayer.cc	/^void resetLayer(Adapt* a)$/;"	f	namespace:ma
residesOn	apf/apfMesh.cc	/^static bool residesOn(Mesh* m, MeshEntity* e, int part)$/;"	f	namespace:apf
resize	can/canArray.h	/^    void resize(unsigned n) { (void) n; }$/;"	f	class:can::Array
resize	can/canArray.h	/^    void resize(unsigned n)$/;"	f	class:can::Array
resize	gmi/agm.c	/^static void resize(int** a, int cap)$/;"	f	file:
resize	mds/mds.c	/^static void resize(struct mds* m, mds_id old_cap[MDS_TYPES])$/;"	f	file:
resize	mth/mthAD.h	/^    inline void resize(unsigned int i) {(void)i;}$/;"	f	class:mth::AD
resize	mth/mthAD.h	/^    void resize(unsigned int n)$/;"	f	class:mth::AD
resize	mth/mthMatrix.h	/^    void resize(unsigned m, unsigned n)$/;"	f	class:mth::Matrix
resize	mth/mthTensor.h	/^    void resize(unsigned d)$/;"	f	class:mth::Tensor
resize	mth/mthTensor.h	/^    void resize(unsigned m, unsigned n)$/;"	f	class:mth::Tensor
resize_adjacencies	mds/mds.c	/^static void resize_adjacencies(struct mds* m, mds_id old_cap[MDS_TYPES])$/;"	f	file:
resize_adjacency	mds/mds.c	/^static void resize_adjacency(struct mds* m, int from, int to,$/;"	f	file:
resize_copy	can/canArray.h	/^    void resize_copy(unsigned n)$/;"	f	class:can::Array
resize_down	mds/mds.c	/^static void resize_down(struct mds* m, int from, int to,$/;"	f	file:
resize_free	mds/mds.c	/^static void resize_free(struct mds* m)$/;"	f	file:
resize_up	mds/mds.c	/^static void resize_up(struct mds* m, int from, int to,$/;"	f	file:
restart	phasta/phstream.cc	/^    char *geom, *restart;$/;"	m	struct:GRStream	file:
restart	phasta/phstream.cc	/^    char* restart;$/;"	m	struct:RStream	file:
restartFileName	phasta/phInput.h	/^    std::string restartFileName;$/;"	m	class:ph::Input
restoreMatches	phasta/phFilterMatching.cc	/^void restoreMatches(apf::Mesh2* m, int dim, SavedMatches& sm)$/;"	f	namespace:ph
restore_field_meta	apf/apfFile.cc	/^static void restore_field_meta(pcu_file* file, apf::Mesh* mesh) {$/;"	f	namespace:apf
restore_int	apf/apfFile.cc	/^static int restore_int(pcu_file* file) {$/;"	f	namespace:apf
restore_meta	apf/apfFile.cc	/^void restore_meta(pcu_file* file, apf::Mesh* mesh) {$/;"	f	namespace:apf
restore_numbering_meta	apf/apfFile.cc	/^static void restore_numbering_meta(pcu_file* file, apf::Mesh* mesh) {$/;"	f	namespace:apf
restore_string	apf/apfFile.cc	/^static std::string restore_string(pcu_file* file) {$/;"	f	namespace:apf
result	spr/sprEstimateTargetError.cc	/^    double result;$/;"	m	class:spr::target::ScalarIntegrator	file:
retreat	parma/group/parma_group.cc	/^static void retreat(apf::Mesh2* m, Remap& remap)$/;"	f	file:
retreatToGroup	parma/group/parma_group.cc	/^static void retreatToGroup($/;"	f	file:
retrieve	ma/maAdapt.cc	/^void NewEntities::retrieve(EntityArray& a)$/;"	f	class:ma::NewEntities
rgnAvg	parma/extractParmaResults.py	/^rgnAvg = metric("rgnAvg")$/;"	v
rgnMax	parma/extractParmaResults.py	/^rgnMax = metric("rgnMax")$/;"	v
rgnMin	parma/extractParmaResults.py	/^rgnMin = metric("rgnMin")$/;"	v
rgnTot	parma/extractParmaResults.py	/^rgnTot = metric("rgnTotal")$/;"	v
rgnsPerPart	parma/extractParmaResults.py	/^rgnsPerPart = runs[0].metrics[rgnAvg.name][0]$/;"	v
right	pcu/pcu_aa.h	/^  pcu_aa_tree right;$/;"	m	struct:pcu_aa_node_struct
rigidBodyIDs	phasta/phOutput.h	/^  int* rigidBodyIDs;$/;"	m	struct:ph::EnsaArrays
rigidBodyMTs	phasta/phOutput.h	/^  int* rigidBodyMTs;$/;"	m	struct:ph::EnsaArrays
rigidBodyMotion	phasta/phastaChef.h	/^    rigidBodyMotion(int t = 0, double r = 0.0, double s = 0.0)$/;"	f	struct:ph::rigidBodyMotion
rigidBodyMotion	phasta/phastaChef.h	/^  struct rigidBodyMotion {$/;"	s	namespace:ph
rigidBodyTag	phasta/phOutput.h	/^  int* rigidBodyTag;$/;"	m	struct:ph::EnsaArrays
riter	apf_sim/apfSIM.h	/^    RIter riter;$/;"	m	class:apf::MeshSIM
rotang	phasta/phastaChef.h	/^    double rotang;$/;"	m	struct:ph::rigidBodyMotion
rotate	apf/apfMatrix.cc	/^Matrix3x3 rotate(Vector3 const& u, double a)$/;"	f	namespace:apf
rotateEdge	ma/maMesh.cc	/^void rotateEdge(Entity** i, int, Entity** o)$/;"	f	namespace:ma
rotateEdge	ma/sliverCodeMatch.cc	/^void rotateEdge(int const a[2], int r, int b[2])$/;"	f
rotateEdgePair	ma/sliverCodeMatch.cc	/^void rotateEdgePair(int const a[2][2], int r, int b[2][2])$/;"	f
rotateEntity	ma/maMesh.cc	/^void rotateEntity(apf::Mesh* m, Entity* e, int n, Entity** v)$/;"	f	namespace:ma
rotateEntity	ma/maMesh.cc	/^void rotateEntity(int type, Entity** iv, int n, Entity** ov)$/;"	f	namespace:ma
rotateEntity	phasta/phAdjacent.cc	/^static void rotateEntity(apf::Mesh* m, apf::MeshEntity* e,$/;"	f	namespace:ph
rotateFace	ma/maMesh.cc	/^void rotateFace(int nv, Entity** iv, int n, Entity** ov)$/;"	f	namespace:ma
rotateForFaceSplit	ma/maFaceSplit.cc	/^static void rotateForFaceSplit(Adapt* a, Entity* tet, Entity* tri, Downward v)$/;"	f	namespace:ma
rotateOct	ma/maMesh.cc	/^void rotateOct(Entity** iv, int n, Entity** ov)$/;"	f	namespace:ma
rotatePrism	ma/maMesh.cc	/^void rotatePrism(Entity** iv, int n, Entity** ov)$/;"	f	namespace:ma
rotatePyramid	ma/maMesh.cc	/^void rotatePyramid(Entity** iv, int n, Entity** ov)$/;"	f	namespace:ma
rotateQuad	ma/maMesh.cc	/^void rotateQuad(Entity** i, int n, Entity** o)$/;"	f	namespace:ma
rotateTet	ma/maMesh.cc	/^void rotateTet(Entity** iv, int n, Entity** ov)$/;"	f	namespace:ma
rotateTri	ma/maMesh.cc	/^void rotateTri(Entity** i, int n, Entity** o)$/;"	f	namespace:ma
rotate_set	mds/mds_apf.c	/^static void rotate_set(struct mds_set* in, int r, struct mds_set* out)$/;"	f	file:
rotation	ma/maTables.h	/^  int rotation; \/\/the 'n' argument to the rotateEntity functions$/;"	m	struct:ma::CodeMatch
rotaxis	phasta/phastaChef.h	/^    double rotaxis[3];$/;"	m	struct:ph::rigidBodyMotion
rotpt	phasta/phastaChef.h	/^    double rotpt[3];$/;"	m	struct:ph::rigidBodyMotion
round	ma/maLayerCoarsen.cc	/^  int round;$/;"	m	struct:ma::CurveLocalizer	file:
row	test/capStoneAttachSolution.cc	/^typedef std::vector<double> row;$/;"	t	file:
rows	mth/mthMatrix.h	/^    unsigned rows() const {return M;}$/;"	f	class:mth::Matrix
rows	mth/mthMatrix.h	/^    unsigned rows() const {return elems.size()\/columns;}$/;"	f	class:mth::Matrix
rs	phasta/phInput.h	/^    RStream* rs;$/;"	m	class:ph::Input
rstream	phasta/phstream.h	/^typedef struct RStream* rstream;$/;"	t	typeref:struct:RStream
run	apf/apfConvert.cc	/^    void run(MeshEntity** nodes, MeshEntity** elems, bool copy_data=true)$/;"	f	class:apf::Converter
run	apf/apfFieldData.cc	/^    void run() {apply(to->getField());}$/;"	f	class:apf::AddOp
run	apf/apfFieldData.cc	/^    void run() {apply(to->getField());}$/;"	f	class:apf::CopyOp
run	apf/apfFieldData.cc	/^    void run() {apply(to->getField());}$/;"	f	class:apf::MultiplyOp
run	apf/apfFieldOf.cc	/^    void run()$/;"	f	class:apf::Project
run	apf/apfFieldOf.cc	/^    void run(double a_, FieldOf<T>* x_, FieldOf<T>* y_)$/;"	f	class:apf::Axpy
run	apf/apfHierarchic.cc	/^    void run()$/;"	f	class:apf::Projector
run	apf/apfMesh.cc	/^MeshEntity* ElementVertOp::run(int type, MeshEntity** verts)$/;"	f	class:apf::ElementVertOp
run	apf/apfNumbering.cc	/^    void run(FieldBase* f)$/;"	f	class:apf::Counter
run	apf/apfNumbering.cc	/^    void run(NumberingOf<T>* n)$/;"	f	class:apf::Globalizer
run	apf/apfVtk.cc	/^    void run(std::ostream& file,$/;"	f	class:apf::WriteIPField
run	apf/apfVtk.h	/^    bool run(FieldBase* f_)$/;"	f	class:apf::HasAll
run	crv/crvCurveMesh.cc	/^bool BezierCurver::run()$/;"	f	class:crv::BezierCurver
run	crv/crvCurveMesh.cc	/^bool GregoryCurver::run()$/;"	f	class:crv::GregoryCurver
run	crv/crvCurveMesh.cc	/^bool InterpolatingCurver::run()$/;"	f	class:crv::InterpolatingCurver
run	crv/crvShapeFixer.cc	/^bool CrvEdgeEdgeFixer::run()$/;"	f	class:crv::CrvEdgeEdgeFixer
run	crv/crvShapeFixer.cc	/^bool CrvFaceVertFixer::run()$/;"	f	class:crv::CrvFaceVertFixer
run	ma/maDoubleSplitCollapse.cc	/^bool DoubleSplitCollapse::run(Entity** edges)$/;"	f	class:ma::DoubleSplitCollapse
run	ma/maEdgeSwap.cc	/^    virtual bool run(Entity* e)$/;"	f	class:ma::EdgeSwap2D
run	ma/maEdgeSwap.cc	/^    virtual bool run(Entity* e)$/;"	f	class:ma::EdgeSwap3D
run	ma/maFaceSplitCollapse.cc	/^  bool FaceSplitCollapse::run(Entity* face, Entity* tet)$/;"	f	class:ma::FaceSplitCollapse
run	ma/maShape.cc	/^    virtual bool run()$/;"	f	class:ma::EdgeEdgeFixer
run	ma/maShape.cc	/^    virtual bool run()$/;"	f	class:ma::FaceVertFixer
run	ma/maShape.cc	/^    virtual bool run()$/;"	f	class:ma::FixBySwap
run	ma/maShortEdgeRemover.cc	/^bool ShortEdgeRemover::run()$/;"	f	class:ma::ShortEdgeRemover
run	ma/maSnapper.cc	/^bool Snapper::run()$/;"	f	class:ma::Snapper
run	ma/maVertRemover.cc	/^bool VertRemover::run()$/;"	f	class:ma::VertRemover
run	parma/diffMC/parma_centroidSelector.cc	/^      apf::Migration* run(Targets* tgts) {$/;"	f	class:parma::CentroidSelector
run	parma/diffMC/parma_edgeEqVtxSelector.cc	/^      apf::Migration* run(parma::Targets* tgts) {$/;"	f	class:__anon52::EdgeEqVtx
run	parma/diffMC/parma_elmLtVtxEdgeSelector.cc	/^      apf::Migration* run(parma::Targets* tgts) {$/;"	f	class:__anon64::ElmLtVtxEdgeSelector
run	parma/diffMC/parma_ltSelector.cc	/^      apf::Migration* run(parma::Targets* tgts) {$/;"	f	class:__anon58::LtSelector
run	parma/diffMC/parma_shapeSelector.cc	/^      apf::Migration* run(parma::Targets* tgts) {$/;"	f	class:__anon57::ShapeSelector
run	parma/diffMC/parma_vtxSelector.cc	/^  apf::Migration* VtxSelector::run(Targets* tgts) {$/;"	f	class:parma::VtxSelector
run	parma/group/parma_group.cc	/^  void run(int group)$/;"	f	struct:RetreatCode
run	phasta/condense.cc	/^    void run(int) {$/;"	f	struct:__anon85::GroupCode
run	phasta/phAdapt.cc	/^  void run(int) {$/;"	f	struct:ph::AdaptCallback
run	test/collapse.cc	/^    void run(int) {$/;"	f	struct:__anon6::GroupCode
run	test/fusion.cc	/^  void run(int group)$/;"	f	struct:GroupCode
run	test/fusion2.cc	/^  void run(int group)$/;"	f	struct:GroupCode
run	test/hierarchic.cc	/^void L2Projector::run() {$/;"	f	class:__anon20::L2Projector
run	test/poisson.cc	/^    void run() {$/;"	f	class:__anon17::Poisson
run	test/serialize.cc	/^  void run(int)$/;"	f	struct:GroupCode
run	zoltan/apfZoltanCallbacks.cc	/^void ZoltanData::run()$/;"	f	class:apf::ZoltanData
run	zoltan/apfZoltanMesh.cc	/^Migration* ZoltanMesh::run(MeshTag* w, double tol, int mult)$/;"	f	class:apf::ZoltanMesh
runBFS	parma/diffMC/parma_ghostMPASWeights.cc	/^  double runBFS(apf::Mesh* m, int layers, std::vector<apf::MeshEntity*> current,$/;"	f	namespace:__anon61
runBFS	parma/diffMC/parma_ghostWeights.cc	/^  double* runBFS(apf::Mesh* m, int layers, std::vector<apf::MeshEntity*> current,$/;"	f	namespace:__anon69
runBalancer	ma/maBalance.cc	/^static void runBalancer(Adapt* a, apf::Balancer* b)$/;"	f	namespace:ma
runBalancer	phasta/phPartition.cc	/^void runBalancer(apf::Mesh2* m, Input& in, apf::Balancer* b)$/;"	f	namespace:ph
runCombinedTests	test/base64.cc	/^void runCombinedTests()$/;"	f
runCount	parma/extractParmaResults.py	/^  runCount = runCount + 1$/;"	v
runCount	parma/extractParmaResults.py	/^runCount = 0$/;"	v
runDecodeTests	test/base64.cc	/^void runDecodeTests ()$/;"	f
runDown	apf/apfMesh.cc	/^void ElementVertOp::runDown($/;"	f	class:apf::ElementVertOp
runEdgeDown	apf/apfMesh.cc	/^static void runEdgeDown($/;"	f	namespace:apf
runEncodeTests	test/base64.cc	/^void runEncodeTests ()$/;"	f
runFromErrorThreshold	phasta/phAdapt.cc	/^static void runFromErrorThreshold(Input& in, apf::Mesh2* m)$/;"	f	namespace:ph
runFromGivenSize	phasta/phAdapt.cc	/^static void runFromGivenSize(Input& in, apf::Mesh2* m)$/;"	f	namespace:ph
runHexDown	apf/apfMesh.cc	/^static void runHexDown($/;"	f	namespace:apf
runInGroups	parma/group/parma_group.cc	/^static void runInGroups($/;"	f	file:
runOnce	apf/apfVtk.cc	/^    void runOnce(FieldBase* f)$/;"	f	class:apf::WriteIPField
runParma	ma/maBalance.cc	/^void runParma(Adapt* a)$/;"	f	namespace:ma
runParma	test/ghost.cc	/^  void runParma(apf::Mesh* m, apf::MeshTag* weights) {$/;"	f	namespace:__anon11
runParma	test/ghostEdge.cc	/^  void runParma(apf::Mesh* m) {$/;"	f	namespace:__anon12
runParma	test/ghostMPAS.cc	/^  void runParma(apf::Mesh* m) {$/;"	f	namespace:__anon9
runParma	test/ptnParma.cc	/^void runParma(apf::Mesh2* m) {$/;"	f	namespace:__anon10
runPolynomialFit	spr/sprRecoverField.cc	/^static void runPolynomialFit(QRDecomp const& qr,$/;"	f	namespace:spr
runPrismDown	apf/apfMesh.cc	/^static void runPrismDown($/;"	f	namespace:apf
runPyramidDown	apf/apfMesh.cc	/^static void runPyramidDown($/;"	f	namespace:apf
runQuadDown	apf/apfMesh.cc	/^static void runQuadDown($/;"	f	namespace:apf
runSimxAdapt	test/runSimxAnisoAdapt.cc	/^double runSimxAdapt(pMSAdapt adapter)$/;"	f
runSimxMeshImprover	test/runSimxAnisoAdapt.cc	/^double runSimxMeshImprover(pMesh mesh, double minQuality)$/;"	f
runSpr	spr/sprRecoverField.cc	/^static void runSpr(Patch* p)$/;"	f	namespace:spr
runStep	parma/diffMC/parma_centroidDiffuser.cc	/^      bool runStep(apf::MeshTag* wtag, double tolerance) {$/;"	f	class:__anon62::CentroidBalancer
runStep	parma/diffMC/parma_elmBalancer.cc	/^      bool runStep(apf::MeshTag* wtag, double tolerance) {$/;"	f	class:__anon60::ElmBalancer
runStep	parma/diffMC/parma_elmLtVtxEdgeBalancer.cc	/^      bool runStep(apf::MeshTag* wtag, double tolerance) {$/;"	f	class:__anon66::ElmLtVtxEdge
runStep	parma/diffMC/parma_ghost.cc	/^      bool runStep(apf::MeshTag* wtag, double tolerance) {$/;"	f	class:__anon68::GhostElmBalancer
runStep	parma/diffMC/parma_ghost.cc	/^      bool runStep(apf::MeshTag* wtag, double tolerance) {$/;"	f	class:__anon68::GhostVtxLtElmBalancer
runStep	parma/diffMC/parma_ghost.cc	/^    bool runStep(apf::MeshTag*, double) { return true; }$/;"	f	class:GhostElmGtVtxBalancer
runStep	parma/diffMC/parma_ghostElement.cc	/^      bool runStep(apf::MeshTag* wtag, double tolerance) {$/;"	f	class:__anon45::GhostEdgeBalancer
runStep	parma/diffMC/parma_ghostMPAS.cc	/^      bool runStep(apf::MeshTag* wtag, double tolerance) {$/;"	f	class:__anon67::MPASGhostBalancer
runStep	parma/diffMC/parma_shapeOptimizer.cc	/^      bool runStep(apf::MeshTag* wtag, double tolerance) {$/;"	f	class:__anon47::ShapeOptimizer
runStep	parma/diffMC/parma_vtxBalancer.cc	/^      bool runStep(apf::MeshTag* wtag, double tolerance) {$/;"	f	class:__anon55::VtxBalancer
runStep	parma/diffMC/parma_vtxEdgeElmBalancer.cc	/^      bool runStep(apf::MeshTag* wtag, double tolerance) {$/;"	f	class:__anon46::VtxEdgeBalancer
runStep	parma/diffMC/parma_vtxEdgeElmBalancer.cc	/^      bool runStep(apf::MeshTag*, double) { return true; }$/;"	f	class:__anon46::VtxEdgeElmBalancer
runStep	parma/diffMC/parma_vtxElmBalancer.cc	/^      bool runStep(apf::MeshTag* wtag, double tolerance) {$/;"	f	class:__anon71::ElmLtVtx
runStep	parma/diffMC/parma_vtxElmBalancer.cc	/^    bool runStep(apf::MeshTag*, double) { return true; }$/;"	f	class:VtxElmBalancer
runTetDown	apf/apfMesh.cc	/^static void runTetDown($/;"	f	namespace:apf
runTriDown	apf/apfMesh.cc	/^static void runTriDown($/;"	f	namespace:apf
runUniformRefinement	ma/ma.cc	/^void runUniformRefinement(Mesh* m, int n, SolutionTransfer* s)$/;"	f	namespace:ma
runZoltan	ma/maBalance.cc	/^void runZoltan(Adapt* a, int method=apf::GRAPH)$/;"	f	namespace:ma
runs	parma/extractParmaResults.py	/^runs = []$/;"	v
s	parma/diffMC/parma_shapeSelector.cc	/^    uint s; \/\/size of d array$/;"	m	struct:__anon57::UintArr	file:
s	parma/diffMC/parma_stop.h	/^      Average* s;$/;"	m	class:parma::BalOrStall
s	parma/diffMC/parma_vtxSelector.cc	/^    uint s; \/\/size of d array$/;"	m	struct:__anon59::UintArr	file:
s	test/scale.cc	/^  double s;$/;"	m	struct:__anon3::Scale	file:
sA	parma/diffMC/parma_balancer.h	/^      Average* sA;$/;"	m	class:parma::Balancer
sS	parma/diffMC/parma_balancer.h	/^      Slope* sS;$/;"	m	class:parma::Balancer
sTol	parma/diffMC/parma_stop.h	/^      double sTol;$/;"	m	class:parma::BalOrStall
safe_mkdir	apf/apfVtk.cc	/^static void safe_mkdir(const char* path)$/;"	f	namespace:apf
safe_mkdir	crv/crvVtk.cc	/^static void safe_mkdir(const char* path)$/;"	f	namespace:crv
safe_mkdir	mds/mds_smb.c	/^static void safe_mkdir(const char* path, mode_t mode)$/;"	f	file:
safe_mkdir	pcu/pcu.c	/^static void safe_mkdir(const char* path, mode_t mode)$/;"	f	file:
safe_mkdir	test/measureAnisoStats.cc	/^void safe_mkdir(const char* path)$/;"	f
safe_mkdir	test/measureIsoStats.cc	/^void safe_mkdir(const char* path)$/;"	f
safe_mkdir	test/visualizeAnisoSizes.cc	/^void safe_mkdir(const char* path)$/;"	f
sam	sam/sam.cc	/^namespace sam {$/;"	n	file:
sam	sam/sam.h	/^namespace sam {$/;"	n
sam	sam/samElementCount.cc	/^namespace sam {$/;"	n	file:
sam	sam/samElementCount.h	/^namespace sam {$/;"	n
samSz	sam/samSz.cc	/^namespace samSz {$/;"	n	file:
samSz	sam/samSz.h	/^namespace samSz {$/;"	n
same	ma/maMesh.cc	/^static bool same(int n, Entity** a, Entity** b)$/;"	f	namespace:ma
sameContent	apf/apfMesh.cc	/^static bool sameContent(int n, MeshEntity** a, MeshEntity** b)$/;"	f	namespace:apf
samples	spr/sprRecoverField.cc	/^  Samples samples;$/;"	m	struct:spr::Patch	file:
saveMatches	phasta/phFilterMatching.cc	/^void saveMatches(apf::Mesh* m, int dim, SavedMatches& sm)$/;"	f	namespace:ph
save_field_meta	apf/apfFile.cc	/^static void save_field_meta(pcu_file* file, apf::Field* field) {$/;"	f	namespace:apf
save_int	apf/apfFile.cc	/^static void save_int(pcu_file* file, int x) {$/;"	f	namespace:apf
save_meta	apf/apfFile.cc	/^void save_meta(pcu_file* file, apf::Mesh* mesh) {$/;"	f	namespace:apf
save_numbering_meta	apf/apfFile.cc	/^static void save_numbering_meta(pcu_file* file, apf::Numbering* numbering) {$/;"	f	namespace:apf
save_string	apf/apfFile.cc	/^static void save_string(pcu_file* file, const char* s) {$/;"	f	namespace:apf
savedFaceMatches	phasta/phFilterMatching.cc	/^static SavedMatches* savedFaceMatches = 0;$/;"	m	namespace:ph	file:
savedVertexMatches	phasta/phFilterMatching.cc	/^static SavedMatches* savedVertexMatches = 0;$/;"	m	namespace:ph	file:
scale	phasta/phastaChef.h	/^    double scale;$/;"	m	struct:ph::rigidBodyMotion
scaleIsoSizeField	sam/samElementCount.cc	/^void scaleIsoSizeField(apf::Field* iso_field, double targetElementCount) {$/;"	f	namespace:sam
scale_dim	test/scale.cc	/^static void scale_dim($/;"	f	namespace:__anon3
scale_mesh	test/scale.cc	/^static void scale_mesh(apf::Mesh2* m, Scale const& s) {$/;"	f	namespace:__anon3
scan_down	pcu/pcu_coll.c	/^static pcu_pattern scan_down =$/;"	v	file:
scan_down_action	pcu/pcu_coll.c	/^static int scan_down_action(int bit)$/;"	f	file:
scan_down_begin_bit	pcu/pcu_coll.c	/^static int scan_down_begin_bit(void)$/;"	f	file:
scan_down_could_send	pcu/pcu_coll.c	/^static bool scan_down_could_send(int rank, int bit)$/;"	f	file:
scan_down_end_bit	pcu/pcu_coll.c	/^static bool scan_down_end_bit(int bit)$/;"	f	file:
scan_down_peer	pcu/pcu_coll.c	/^static int scan_down_peer(int bit)$/;"	f	file:
scan_down_receiver_for	pcu/pcu_coll.c	/^static int scan_down_receiver_for(int rank, int bit)$/;"	f	file:
scan_down_sender_for	pcu/pcu_coll.c	/^static int scan_down_sender_for(int rank, int bit)$/;"	f	file:
scan_down_shift	pcu/pcu_coll.c	/^static int scan_down_shift(int bit)$/;"	f	file:
scan_up	pcu/pcu_coll.c	/^static pcu_pattern scan_up =$/;"	v	file:
scan_up_action	pcu/pcu_coll.c	/^static int scan_up_action(int bit)$/;"	f	file:
scan_up_begin_bit	pcu/pcu_coll.c	/^static int scan_up_begin_bit(void)$/;"	f	file:
scan_up_could_receive	pcu/pcu_coll.c	/^static bool scan_up_could_receive(int rank, int bit)$/;"	f	file:
scan_up_end_bit	pcu/pcu_coll.c	/^static bool scan_up_end_bit(int bit)$/;"	f	file:
scan_up_peer	pcu/pcu_coll.c	/^static int scan_up_peer(int bit)$/;"	f	file:
scan_up_receiver_for	pcu/pcu_coll.c	/^static int scan_up_receiver_for(int rank, int bit)$/;"	f	file:
scan_up_sender_for	pcu/pcu_coll.c	/^static int scan_up_sender_for(int rank, int bit)$/;"	f	file:
scan_up_shift	pcu/pcu_coll.c	/^static int scan_up_shift(int bit)$/;"	f	file:
seekMarker	mds/mdsGmsh.cc	/^void seekMarker(Reader* r, char const* marker)$/;"	f	namespace:__anon96
seek_after_header	phasta/phIO.c	/^static int seek_after_header(FILE* f, const char* name)$/;"	f	file:
seek_marker	gmi/gmi_file.c	/^static void seek_marker(FILE* f, char const* marker)$/;"	f	file:
select	parma/diffMC/parma_vtxSelector.cc	/^  double VtxSelector::select(Targets* tgts, apf::Migration* plan, double planW,$/;"	f	class:parma::VtxSelector
selectVertices	apf/apfMIS.cc	/^  void selectVertices(Mesh* m, MeshTag* coloring, MeshTag* degrees,$/;"	f	namespace:apf
selects	parma/diffMC/parma_step.h	/^      Selector* selects;$/;"	m	class:parma::Stepper
self	parma/diffMC/parma_centroids.cc	/^  apf::Vector3 Centroids::self() {$/;"	f	class:parma::Centroids
self	parma/diffMC/parma_entWeights.cc	/^  double EntWeights::self() {$/;"	f	class:parma::EntWeights
self	parma/diffMC/parma_ghostMPASWeights.cc	/^      double self() {$/;"	f	class:parma::GhostMPASWeights
self	parma/diffMC/parma_ghostWeights.cc	/^      double self() {$/;"	f	class:parma::GhostToEntWeight
self	parma/diffMC/parma_ghostWeights.cc	/^      double self(int dim) {$/;"	f	class:parma::GhostWeights
selfCentroid	parma/diffMC/parma_centroids.cc	/^  apf::Vector3 Centroids::selfCentroid(apf::Mesh* m, apf::MeshTag* w) {$/;"	f	class:parma::Centroids
selfWeight	parma/diffMC/parma_centroids.cc	/^  double selfWeight(apf::Mesh* m, apf::MeshTag* w) {$/;"	f	namespace:__anon63
send	apf/apfMesh.cc	/^void Migration::send(MeshEntity* e, int to)$/;"	f	class:apf::Migration
send	ma/maCrawler.cc	/^  void send(Entity* v, int to)$/;"	f	struct:ma::LayerNumberer
send	ma/maLayerCoarsen.cc	/^  void send(Entity* v, int to)$/;"	f	struct:ma::CurveLocalizer
send	ma/maLayerRefine.cc	/^  void send(Entity* e, int to)$/;"	f	struct:ma::SplitTagger
send	ma/maLayerRefine.cc	/^  void send(Entity* t, int to)$/;"	f	struct:ma::Disambiguator
send	ma/maLayerSnap.cc	/^  void send(Entity* v, int to)$/;"	f	struct:ma::BaseTopLinker
send	ma/maLayerSnap.cc	/^  void send(Entity* v, int to)$/;"	f	struct:ma::LayerSnapper
send	ma/maLayerSnap.cc	/^  void send(Entity* v, int to)$/;"	f	struct:ma::SnapTagger
send	ma/maLayerSnap.cc	/^  void send(Entity* v, int to)$/;"	f	struct:ma::UnsnapChecker
send	ma/maLayerSnap.cc	/^  void send(Entity* v, int to)$/;"	f	struct:ma::Unsnapper
send	ma/maTetrahedronize.cc	/^  void send(Entity* e, int to)$/;"	f	struct:ma::QuadFlagger
send	ma/maTetrahedronize.cc	/^  void send(Entity*, int)$/;"	f	struct:ma::QuadMarker
send	pcu/pcu_mpi.h	/^  void (*send)(pcu_message* m, MPI_Comm comm);$/;"	m	struct:__anon34
send	phasta/phLinks.h	/^  int send;$/;"	m	struct:ph::LinkKey
send	pumi/pumi_ghost.cc	/^void Ghosting::send (int to)$/;"	f	class:Ghosting
send	pumi/pumi_ghost.cc	/^void Ghosting::send(pMeshEnt e, int to)$/;"	f	class:Ghosting
send	pumi/pumi_mesh.cc	/^void Distribution::send(pMeshEnt e, int to)$/;"	f	class:Distribution
sendAdjNetsToNeighbors	parma/diffMC/maximalIndependentSet/misLuby.cc	/^  int sendAdjNetsToNeighbors(partInfo& part, vector<adjPart>& nbNet) {$/;"	f	namespace:__anon50
sendAlignment	apf/apfVerify.cc	/^static void sendAlignment(Mesh* m, MeshEntity* e)$/;"	f	namespace:apf
sendAllCopies	apf/apfVerify.cc	/^static void sendAllCopies(Mesh* m, MeshEntity* e)$/;"	f	namespace:apf
sendCoords	apf/apfVerify.cc	/^static void sendCoords(Mesh* m, MeshEntity* e)$/;"	f	namespace:apf
sendEntities	apf/apfMigrate.cc	/^static void sendEntities($/;"	f	namespace:apf
sendFieldData	pumi/pumi_field.cc	/^static void sendFieldData(pMesh m, pMeshEnt e, pField f, int nf, pOwnership shr)$/;"	f	file:
sendGhostCopies	apf/apfVerify.cc	/^static void sendGhostCopies(Mesh* m, MeshEntity* e)$/;"	f	namespace:apf
sendIntsToNeighbors	parma/diffMC/maximalIndependentSet/misLuby.cc	/^  void sendIntsToNeighbors(partInfo& part, vector<int>& msg, int tag) {$/;"	f	namespace:__anon50
sendNetToNeighbors	parma/diffMC/maximalIndependentSet/misLuby.cc	/^  int sendNetToNeighbors(partInfo& part) {$/;"	f	namespace:__anon50
sendPullRequests	apf/apfCavityOp.cc	/^bool CavityOp::sendPullRequests(std::vector<PullRequest>& received)$/;"	f	class:apf::CavityOp
sendSelfToMatches	apf/apfVerify.cc	/^static void sendSelfToMatches(MeshEntity* e, Matches& matches)$/;"	f	namespace:apf
sendTag	parma/diffMC/parma_centroidSelector.cc	/^      apf::MeshTag* sendTag;$/;"	m	class:parma::CentroidSelector	file:
sendTagData	apf/apfVerify.cc	/^static void sendTagData(Mesh* m, MeshEntity* e, DynamicArray<MeshTag*>& tags, Copies& copies, bool is_ghost=false)$/;"	f	namespace:apf
send_entities	pumi/pumi_mesh.cc	/^void send_entities(pMesh mesh, int dim)$/;"	f
send_peers	pcu/pcu_msg.c	/^static void send_peers(pcu_aa_tree t)$/;"	f	file:
send_recv_state	pcu/pcu_msg.c	/^  send_recv_state, \/\/starting to receive, sends still going$/;"	e	enum:__anon32	file:
send_remote_link	mds/mds_net.c	/^static void send_remote_link(mds_id i, struct mds_copy c, void* u)$/;"	f	file:
sending	apf/apfMesh.cc	/^int Migration::sending(MeshEntity* e)$/;"	f	class:apf::Migration
sending	parma/diffMC/parma_centroidSelector.cc	/^      std::map<int,double> sending;$/;"	m	class:parma::CentroidSelector	file:
sending	parma/diffMC/parma_vtxSelector.h	/^      Mid sending;$/;"	m	class:parma::VtxSelector
sending	pumi/pumi_ghost.cc	/^Parts& Ghosting::sending(pMeshEnt e, int d)$/;"	f	class:Ghosting
sending	pumi/pumi_mesh.cc	/^Parts& Distribution::sending(pMeshEnt e)$/;"	f	class:Distribution
sent	parma/diffMC/parma_edgeEqVtxSelector.cc	/^      bool sent(apf::Migration* plan, apf::MeshEntity* e) {$/;"	f	class:__anon52::EdgeEqVtx
serial	test/xgc_split.cc	/^int serial=0;$/;"	v
serialGradation	test/capStoneAttachSolution.cc	/^int serialGradation(apf::Mesh* m,apf::Field* size_iso, std::queue<apf::MeshEntity*> &markedEdges,double gradingFactor)$/;"	f
set	apf/apfArrayData.cc	/^    virtual void set(MeshEntity* e, T const* data)$/;"	f	class:apf::ArrayDataOf
set	apf/apfCoordData.cc	/^void CoordData::set(MeshEntity* e, double const* data)$/;"	f	class:apf::CoordData
set	apf/apfNumbering.cc	/^void NumberingOf<T>::set(MeshEntity* e, int node, int component, T value)$/;"	f	class:apf::NumberingOf
set	apf/apfTagData.h	/^    virtual void set(MeshEntity* e, T const* data)$/;"	f	class:apf::TagDataOf
set	apf/apfTagData.h	/^    void set(Mesh* m, MeshEntity* e, MeshTag* t, double const* data)$/;"	f	class:apf::TagHelper
set	apf/apfTagData.h	/^    void set(Mesh* m, MeshEntity* e, MeshTag* t, int const* data)$/;"	f	class:apf::TagHelper
set	apf/apfTagData.h	/^    void set(Mesh* m, MeshEntity* e, MeshTag* t, long const* data)$/;"	f	class:apf::TagHelper
set	apf/apfUserData.cc	/^void UserData::set(MeshEntity*, double const*)$/;"	f	class:apf::UserData
set	apf_cap/apfCAP.cc	/^    void set(MeshEntity* e, double const* p)$/;"	f	class:apf::DoubleTagCAP
set	apf_cap/apfCAP.cc	/^    void set(MeshEntity* e, int const* p)$/;"	f	class:apf::IntTagCAP
set	apf_cap/apfCAP.cc	/^    void set(MeshEntity* e, void* p)$/;"	f	class:apf::TagCAP
set	apf_sim/apfSIM.cc	/^    void set(MeshEntity* e, double const* p)$/;"	f	class:apf::DoubleTagSIM
set	apf_sim/apfSIM.cc	/^    void set(MeshEntity* e, int const* p)$/;"	f	class:apf::IntTagSIM
set	apf_sim/apfSIM.cc	/^    void set(MeshEntity* e, long const* p)$/;"	f	class:apf::LongTagSIM
set	apf_sim/apfSIM.cc	/^    void set(MeshEntity* e, void* p)$/;"	f	class:apf::TagSIM
set	apf_sim/apfSIMDataOf.h	/^  virtual void set(MeshEntity * e, T const * data)$/;"	f	class:apf::SIMDataOf
set	ma/maExtrude.cc	/^  virtual void set(Entity* e, double const* data_in) const {$/;"	f	struct:ma::__anon28::FieldDataSetter
set	ma/maExtrude.cc	/^  virtual void set(Entity* v, double const* data_in) const {$/;"	f	struct:ma::__anon28::ZDataSetter
set	parma/diffMC/parma_associative.h	/^      void set(int key, T value) {$/;"	f	class:parma::Associative
set2dStencilNeighbors	parma/diffMC/maximalIndependentSet/test/testMIS.cc	/^void set2dStencilNeighbors(vector<int>& adjPartIds, const int r, const int c, $/;"	f
set2dStencilNets	parma/diffMC/maximalIndependentSet/test/testMIS.cc	/^void set2dStencilNets(vector<int>& nets, const int r, const int c, $/;"	f
setBadElements	ma/maSnapper.cc	/^void FirstProblemPlane::setBadElements(apf::Up& badElements)$/;"	f	class:ma::FirstProblemPlane
setBlendedQuadEdgePoints	crv/crvShapeHandler.cc	/^    void setBlendedQuadEdgePoints(ma::Entity* edge,$/;"	f	class:crv::BezierHandler
setBlendedQuadEdgePointsCross	crv/crvShapeHandler.cc	/^    bool setBlendedQuadEdgePointsCross(ma::EntityArray& cavity,$/;"	f	class:crv::BezierHandler
setBlendedQuadEdgePointsShared	crv/crvShapeHandler.cc	/^    void setBlendedQuadEdgePointsShared(ma::Entity* edge)$/;"	f	class:crv::BezierHandler
setBlendingOrder	crv/crvBlended.cc	/^void setBlendingOrder(const int type, const int b)$/;"	f	namespace:crv
setBubbleScalars	phasta/phBubble.cc	/^void setBubbleScalars(apf::Mesh* m, apf::MeshEntity* v,$/;"	f	namespace:ph
setBuildCallback	ma/maAdapt.cc	/^void setBuildCallback(Adapt* a, apf::BuildCallback* cb)$/;"	f	namespace:ma
setCachedQuality	ma/maAdapt.cc	/^void setCachedQuality(Adapt* a, Entity* e, double q)$/;"	f	namespace:ma
setClassification	test/icesheet.cc	/^void setClassification(gmi_model* model, apf::Mesh2* mesh, apf::MeshTag* t) {$/;"	f
setColor	apf/apfMIS.cc	/^  int setColor(Mesh* m, MeshTag* coloring, int vtx_dim,$/;"	f	namespace:apf
setColumn	apf/apfDynamicMatrix.h	/^    void setColumn(std::size_t j, DynamicVector const& r)$/;"	f	class:apf::DynamicMatrix
setComponents	apf/apf.cc	/^void setComponents(Field* f, MeshEntity* e, int node, double const* components)$/;"	f	namespace:apf
setCoordinateField	apf/apfMesh.cc	/^void Mesh::setCoordinateField(Field* field)$/;"	f	class:apf::Mesh
setCoords	apf/apfConstruct.cc	/^void setCoords(Mesh2* m, const double* coords, int nverts,$/;"	f	namespace:apf
setCubicEdgePointsUsingNormals	crv/crvCurveMesh.cc	/^void GregoryCurver::setCubicEdgePointsUsingNormals()$/;"	f	class:crv::GregoryCurver
setDefaultValues	ma/maInput.cc	/^void setDefaultValues(Input* in)$/;"	f	namespace:ma
setDefaults	phasta/phInput.cc	/^static void setDefaults(Input& in)$/;"	f	namespace:ph
setDepth	parma/diffMC/parma_components.cc	/^  void DCC::setDepth(unsigned i, unsigned d) { PCU_ALWAYS_ASSERT(i<n); depth[i] = d; }$/;"	f	class:parma::DCC
setDoubleTag	apf_cap/apfCAP.cc	/^void MeshCAP::setDoubleTag(MeshEntity* e, MeshTag* tag, double const* data)$/;"	f	class:apf::MeshCAP
setDoubleTag	apf_sim/apfSIM.cc	/^void MeshSIM::setDoubleTag(MeshEntity* e, MeshTag* tag, double const* data)$/;"	f	class:apf::MeshSIM
setDoubleTag	mds/apfMDS.cc	/^    void setDoubleTag(MeshEntity* e, MeshTag* tag, double const* data)$/;"	f	class:apf::MeshMDS
setEdge	ma/maCollapse.cc	/^bool Collapse::setEdge(Entity* e)$/;"	f	class:ma::Collapse
setEdge	ma/maEdgeSwap.cc	/^    bool setEdge(Entity* e)$/;"	f	class:ma::EdgeSwap2D
setEdge	ma/maEdgeSwap.cc	/^    void setEdge(Entity* e)$/;"	f	class:ma::SwapLoop
setEdge	ma/maMatchedCollapse.cc	/^void MatchedCollapse::setEdge(Entity* e)$/;"	f	class:ma::MatchedCollapse
setEdge	ma/maShortEdgeRemover.cc	/^void ShortEdgeRemover::setEdge(Entity* e)$/;"	f	class:ma::ShortEdgeRemover
setEdgeClassification	test/icesheet.cc	/^void setEdgeClassification(gmi_model* model, apf::Mesh2* mesh) {$/;"	f
setEdges	ma/maMatchedCollapse.cc	/^void MatchedCollapse::setEdges()$/;"	f	class:ma::MatchedCollapse
setEdges	ma/maSplits.cc	/^bool Splits::setEdges(Entity** e, int edgeCount)$/;"	f	class:ma::Splits
setElemDest	ma/maLayerCoarsen.cc	/^  void setElemDest(Entity* e, int to)$/;"	f	struct:ma::CurveLocalizer
setElmVtxIds	parma/diffMC/parma_components.cc	/^  void DCC::setElmVtxIds(apf::Downward& verts, const int nv, unsigned compId) {$/;"	f	class:parma::DCC
setEntity	apf/apfGradientByVolume.cc	/^    virtual Outcome setEntity(MeshEntity* v)$/;"	f	class:apf::RecoverGradient
setEntity	ma/maCoarsen.cc	/^    virtual Outcome setEntity(Entity* e)$/;"	f	class:ma::CollapseChecker
setEntity	ma/maCoarsen.cc	/^    virtual Outcome setEntity(Entity* v)$/;"	f	class:ma::IndependentSetFinder
setEntity	ma/maCrawler.cc	/^  Outcome setEntity(Entity* v_)$/;"	f	struct:ma::TopFlagger
setEntity	ma/maOperator.cc	/^    Outcome setEntity(Entity* e)$/;"	f	class:ma::CollectiveOperation
setEntity	ma/maTetrahedronize.cc	/^  Outcome setEntity(Entity* r)$/;"	f	struct:ma::UnsafePrismOverride
setEntity	ma/maTetrahedronize.cc	/^  Outcome setEntity(Entity* r)$/;"	f	struct:ma::UnsafePyramidOverride
setEntity	spr/sprEstimateError.cc	/^    virtual Outcome setEntity(apf::MeshEntity* e)$/;"	f	class:spr::AverageOp
setEntity	spr/sprEstimateTargetError.cc	/^    virtual Outcome setEntity(apf::MeshEntity* e)$/;"	f	class:spr::target::AverageOp
setEntity	spr/sprRecoverField.cc	/^  virtual Outcome setEntity(apf::MeshEntity* e)$/;"	f	class:spr::PatchOp
setEqualWeights	phasta/phPartition.cc	/^void setEqualWeights(pParMesh pmesh, int desiredTotNumParts, pProgress progress)$/;"	f	namespace:ph
setFace	ma/maFaceSplit.cc	/^bool FaceSplit::setFace(Entity* face)$/;"	f	class:ma::FaceSplit
setFaceClassification	test/icesheet.cc	/^void setFaceClassification(gmi_model* model, apf::Mesh2* mesh, apf::MeshTag* vtxType) {$/;"	f
setFaceTags	mds/mdsUgrid.cc	/^  void setFaceTags(Reader* r, apf::MeshTag* t, unsigned nfaces, int apfType) {$/;"	f	namespace:__anon101
setFaceTags	mds/mdsUgrid.cc	/^  void setFaceTags(Reader* r, header* h) {$/;"	f	namespace:__anon101
setFlag	ma/maAdapt.cc	/^void setFlag(Adapt* a, Entity* e, int flag)$/;"	f	namespace:ma
setFlagMatched	ma/maAdapt.cc	/^void setFlagMatched(Adapt* a, Entity* e, int flag)$/;"	f	namespace:ma
setFlagOnClosure	ma/maAdapt.cc	/^void setFlagOnClosure(Adapt* a, Entity* element, int flag)$/;"	f	namespace:ma
setFlags	ma/maAdapt.cc	/^void setFlags(Adapt* a, Entity* e, int flags)$/;"	f	namespace:ma
setFromEdge	ma/maEdgeSwap.cc	/^    bool setFromEdge(Entity* edge)$/;"	f	class:ma::SwapCavity
setFromEdgeAndFace	ma/maEdgeSwap.cc	/^    bool setFromEdgeAndFace(Entity* edge, Entity* face)$/;"	f	class:ma::SwapCavity
setFunction	apf/apfUserData.h	/^  void setFunction(Function* func) { function = func; }$/;"	f	struct:apf::UserData
setId	parma/diffMC/parma_components.cc	/^  void DCC::setId(apf::MeshEntity* e, unsigned compid) {$/;"	f	class:parma::DCC
setIntTag	apf_cap/apfCAP.cc	/^void MeshCAP::setIntTag(MeshEntity* e, MeshTag* tag, int const* data)$/;"	f	class:apf::MeshCAP
setIntTag	apf_sim/apfSIM.cc	/^void MeshSIM::setIntTag(MeshEntity* e, MeshTag* tag, int const* data)$/;"	f	class:apf::MeshSIM
setIntTag	mds/apfMDS.cc	/^    void setIntTag(MeshEntity* e, MeshTag* tag, int const* data)$/;"	f	class:apf::MeshMDS
setInternalPointsLocally	crv/crvCurveMesh.cc	/^void GregoryCurver::setInternalPointsLocally()$/;"	f	class:crv::GregoryCurver
setIsotropicValue	ma/maSize.cc	/^  void setIsotropicValue($/;"	f	struct:ma::AnisoSizeField
setIsotropicValue	ma/maSize.cc	/^  void setIsotropicValue($/;"	f	struct:ma::LogAnisoSizeField
setLenAndCnt	sam/samSz.cc	/^void setLenAndCnt(apf::Mesh* m, apf::Field* fLen, apf::Field* fCnt) {$/;"	f	namespace:__anon23
setLevelSetIsoField	phasta/phAdapt.cc	/^void setLevelSetIsoField(apf::MeshEntity* v, double* sol,$/;"	f	namespace:ph
setLinearEdgePoints	crv/crvShapeHandler.cc	/^static void setLinearEdgePoints(ma::Mesh* m, ma::Entity* edge)$/;"	f	namespace:crv
setLink	ma/maLayerSnap.cc	/^  void setLink(Entity* v, int peer, int idx)$/;"	f	struct:ma::BaseTopLinker
setLongTag	apf_cap/apfCAP.cc	/^void MeshCAP::setLongTag(MeshEntity* e, MeshTag* tag, long const* data)$/;"	f	class:apf::MeshCAP
setLongTag	apf_sim/apfSIM.cc	/^void MeshSIM::setLongTag(MeshEntity* e, MeshTag* tag, long const* data)$/;"	f	class:apf::MeshSIM
setLongTag	mds/apfMDS.cc	/^    void setLongTag(MeshEntity* e, MeshTag* tag, long const* data)$/;"	f	class:apf::MeshMDS
setMatField	test/test_matrix_grad.cc	/^void setMatField(apf::Mesh* mesh, apf::Field* nodal_fld)$/;"	f
setMatrix	apf/apf.cc	/^void setMatrix(Field* f, MeshEntity* e, int node, Matrix3x3 const& value)$/;"	f	namespace:apf
setMdsMatching	mds/apfMDS.cc	/^void setMdsMatching(Mesh2* in, bool has)$/;"	f	namespace:apf
setMigrationLimit	apf/apfMigrate.cc	/^void setMigrationLimit(size_t maxElements)$/;"	f	namespace:apf
setModelClassification	test/icesheet.cc	/^int setModelClassification(gmi_model* model,$/;"	f
setModelEntity	apf_cap/apfCAP.cc	/^void MeshCAP::setModelEntity(MeshEntity* e, ModelEntity* me)$/;"	f	class:apf::MeshCAP
setModelEntity	apf_sim/apfSIM.h	/^    void setModelEntity(MeshEntity*, ModelEntity*) {}$/;"	f	class:apf::MeshSIM
setModelEntity	mds/apfMDS.cc	/^    void setModelEntity(MeshEntity* e, ModelEntity* c)$/;"	f	class:apf::MeshMDS
setNodeComponents	apf/apfFieldData.cc	/^void FieldDataOf<T>::setNodeComponents(MeshEntity* e, int node,$/;"	f	class:apf::FieldDataOf
setNodeIds	mds/mdsUgrid.cc	/^  void setNodeIds(Reader* r, header* h) {$/;"	f	namespace:__anon101
setNodeStateInGraph	parma/diffMC/maximalIndependentSet/misLuby.cc	/^  void setNodeStateInGraph(partInfo& part) {$/;"	f	namespace:__anon50
setNodeValue	apf/apfFieldOf.h	/^    void setNodeValue(MeshEntity* e, int node, T const* value)$/;"	f	class:apf::FieldOf
setNumber	ma/maCrawler.cc	/^  void setNumber(Entity* v, int n)$/;"	f	struct:ma::Tagger
setNumberingOffset	apf/apfAdjReorder.cc	/^  void setNumberingOffset(Numbering * num, int off, Sharing * shr)$/;"	f	namespace:apf
setOrder	crv/crvBezier.cc	/^void setOrder(const int order)$/;"	f	namespace:crv
setOwners	mds/apfPM.cc	/^static void setOwners(PM& ps, CountMap& mp)$/;"	f	namespace:apf
setParam	apf_cap/apfCAP.cc	/^void MeshCAP::setParam(MeshEntity* e, Vector3 const& point)$/;"	f	class:apf::MeshCAP
setParam	apf_sim/apfSIM.h	/^    void setParam(MeshEntity*, Vector3 const &) {}$/;"	f	class:apf::MeshSIM
setParam	mds/apfMDS.cc	/^    void setParam(MeshEntity* e, Vector3 const& p)$/;"	f	class:apf::MeshMDS
setPoint	apf/apfMesh2.cc	/^void Mesh2::setPoint(MeshEntity* e, int node, Vector3 const& p)$/;"	f	class:apf::Mesh2
setPoint_	apf_cap/apfCAP.cc	/^void MeshCAP::setPoint_(MeshEntity * me, int node, Vector3 const & p)$/;"	f	class:apf::MeshCAP
setPoint_	apf_sim/apfSIM.cc	/^void MeshSIM::setPoint_(MeshEntity * me, int node, Vector3 const & p)$/;"	f	class:apf::MeshSIM
setPoint_	mds/apfMDS.cc	/^    void setPoint_(MeshEntity* e, int, Vector3 const& p)$/;"	f	class:apf::MeshMDS
setRandomNum	parma/diffMC/maximalIndependentSet/misLuby.cc	/^  void setRandomNum(partInfo& part) {$/;"	f	namespace:__anon50
setRegion	ma/maRegionCollapse.cc	/^bool RegionCollapse::setRegion(Entity* r)$/;"	f	class:ma::RegionCollapse
setRemotes	apf_cap/apfCAP.h	/^    void setRemotes(MeshEntity*, Copies&) {}$/;"	f	class:apf::MeshCAP
setRemotes	apf_sim/apfSIM.h	/^    void setRemotes(MeshEntity*, Copies&) {}$/;"	f	class:apf::MeshSIM
setRemotes	mds/apfMDS.cc	/^    void setRemotes(MeshEntity* e, Copies& remotes)$/;"	f	class:apf::MeshMDS
setResidence	apf_cap/apfCAP.h	/^    void setResidence(MeshEntity*, Parts&) {}$/;"	f	class:apf::MeshCAP
setResidence	apf_sim/apfSIM.h	/^    void setResidence(MeshEntity*, Parts&) {}$/;"	f	class:apf::MeshSIM
setResidence	mds/apfMDS.cc	/^    void setResidence(MeshEntity* e, Parts& residence)$/;"	f	class:apf::MeshMDS
setRgnClassification	test/icesheet.cc	/^void setRgnClassification(gmi_model* model, apf::Mesh2* mesh) {$/;"	f
setRow	apf/apfDynamicMatrix.h	/^    void setRow(std::size_t i, DynamicVector const& r)$/;"	f	class:apf::DynamicMatrix
setScalar	apf/apf.cc	/^void setScalar(Field* f, MeshEntity* e, int node, double value)$/;"	f	namespace:apf
setSize	apf/apfDynamicArray.h	/^    void setSize(unsigned n)$/;"	f	class:apf::DynamicArray
setSize	apf/apfDynamicMatrix.h	/^    void setSize(std::size_t m, std::size_t n)$/;"	f	class:apf::DynamicMatrix
setSizeField	test/capStoneAttachSolution.cc	/^void setSizeField(apf::Mesh* mesh, apf::Field* lambdaMaxField,apf::Field* sizeField,double lambda_max,double lambda_cutoff, double h_lambdamax,double h_global,double factor)$/;"	f
setSolutionTransfer	ma/maInput.cc	/^void setSolutionTransfer(Input* in, SolutionTransfer* s)$/;"	f	namespace:ma
setTag	crv/crvAdapt.cc	/^void setTag(Adapt* a, ma::Entity* e, int tag)$/;"	f	namespace:crv
setTag	mds/apfMDS.cc	/^    void setTag(MeshEntity* e, MeshTag* t, void const* data)$/;"	f	class:apf::MeshMDS
setTagData	pumi/GenTag.cc	/^void Taggable::setTagData(TagHandle* tag, void const* data)$/;"	f	class:Taggable
setTagString	pumi/GenTag.cc	/^void Taggable::setTagString(TagHandle* tag, const char* data)$/;"	f	class:Taggable
setTags	crv/crvAdapt.cc	/^static void setTags(Adapt* a, ma::Entity* e, int tags)$/;"	f	namespace:crv
setTensor2	test/tensor.cc	/^static void setTensor2(mth::Tensor<double>& a)$/;"	f	namespace:__anon5
setTensor3	test/tensor.cc	/^static void setTensor3(mth::Tensor<double>& a)$/;"	f	namespace:__anon5
setTet	crv/crvShapeFixer.cc	/^void CrvEdgeEdgeFixer::setTet(apf::MeshEntity** v)$/;"	f	class:crv::CrvEdgeEdgeFixer
setTet	crv/crvShapeFixer.cc	/^void CrvFaceVertFixer::setTet(apf::MeshEntity** v)$/;"	f	class:crv::CrvFaceVertFixer
setTet	ma/maShape.cc	/^    virtual void setTet(Entity** v)$/;"	f	class:ma::EdgeEdgeFixer
setTet	ma/maShape.cc	/^    virtual void setTet(Entity** v)$/;"	f	class:ma::FaceVertFixer
setTet	ma/maShape.cc	/^    virtual void setTet(Entity** v)$/;"	f	class:ma::FixBySwap
setValue	apf/apfGradientByVolume.cc	/^    SetValue<GT> setValue;$/;"	m	class:apf::RecoverGradient	file:
setValue	ma/maSize.cc	/^  void setValue($/;"	f	struct:ma::AnisoSizeField
setValue	ma/maSize.cc	/^  void setValue($/;"	f	struct:ma::LogAnisoSizeField
setValues	test/fusion2.cc	/^static void setValues(apf::Mesh2* m)$/;"	f	file:
setVector	apf/apf.cc	/^void setVector(Field* f, MeshEntity* e, int node, Vector3 const& value)$/;"	f	namespace:apf
setVert	ma/maMatchedSnapper.cc	/^void MatchedSnapper::setVert(Entity* v)$/;"	f	class:ma::MatchedSnapper
setVert	ma/maSnapper.cc	/^void Snapper::setVert(Entity* v)$/;"	f	class:ma::Snapper
setVert	ma/maVertRemover.cc	/^void VertRemover::setVert(Entity* v)$/;"	f	class:ma::VertRemover
setVertDest	ma/maLayerCoarsen.cc	/^  void setVertDest(Entity* v, int dest)$/;"	f	struct:ma::CurveLocalizer
setVertex	ma/maSnapper.cc	/^void FirstProblemPlane::setVertex(Entity* v)$/;"	f	class:ma::FirstProblemPlane
setVertexToCollapse	ma/maCollapse.cc	/^static bool setVertexToCollapse(Adapt* a, Entity* v)$/;"	f	namespace:ma
setVerts	ma/maCollapse.cc	/^void Collapse::setVerts()$/;"	f	class:ma::Collapse
setVerts	ma/maMatchedSnapper.cc	/^void MatchedSnapper::setVerts()$/;"	f	class:ma::MatchedSnapper
setVtxClassification	test/icesheet.cc	/^void setVtxClassification(gmi_model* model, apf::Mesh2* mesh, apf::MeshTag* t) {$/;"	f
setVtxWeights	test/vtxBalance.cc	/^  apf::MeshTag* setVtxWeights(apf::Mesh* m) {$/;"	f	namespace:__anon14
setWeight	phasta/phPartition.cc	/^void setWeight(apf::Mesh* m, apf::MeshTag* tag, int dim) {$/;"	f	namespace:ph
setWeight	test/ptnParma.cc	/^void setWeight(apf::Mesh* m, apf::MeshTag* tag, int dim) {$/;"	f	namespace:__anon10
setWeight	test/vtxEdgeElmBalance.cc	/^  void setWeight(apf::Mesh* m, apf::MeshTag* tag, int dim, double w=1.0) {$/;"	f	namespace:__anon7
setWeight	test/vtxElmBalance.cc	/^  void setWeight(apf::Mesh* m, apf::MeshTag* tag, int dim) {$/;"	f	namespace:__anon18
setWeights	phasta/phPartition.cc	/^apf::MeshTag* setWeights(apf::Mesh* m) {$/;"	f	namespace:ph
setWeights	test/elmBalance.cc	/^apf::MeshTag* setWeights(apf::Mesh* m) {$/;"	f
setWeights	test/gap.cc	/^  apf::MeshTag* setWeights(apf::Mesh* m) {$/;"	f	namespace:__anon16
setWeights	test/ptnParma.cc	/^apf::MeshTag* setWeights(apf::Mesh* m) {$/;"	f	namespace:__anon10
setWeights	test/vtxEdgeElmBalance.cc	/^  apf::MeshTag* setWeights(apf::Mesh* m, double edgeWeight) {$/;"	f	namespace:__anon7
setWeights	test/vtxElmBalance.cc	/^  apf::MeshTag* setWeights(apf::Mesh* m) {$/;"	f	namespace:__anon18
setZoltanLbApproach	zoltan/apfZoltanCallbacks.cc	/^static int setZoltanLbApproach(struct Zoltan_Struct* ztn, ZoltanMesh* zb)$/;"	f	namespace:apf
setZoltanLbMethod	zoltan/apfZoltanCallbacks.cc	/^static int setZoltanLbMethod(struct Zoltan_Struct* ztn, ZoltanMesh* zb)$/;"	f	namespace:apf
set_rotaxis	phasta/phastaChef.h	/^    void set_rotaxis(double x, double y, double z){$/;"	f	struct:ph::rigidBodyMotion
set_rotpt	phasta/phastaChef.h	/^    void set_rotpt(double x, double y, double z){$/;"	f	struct:ph::rigidBodyMotion
set_subtract	pumi/pumi_ghost.cc	/^void set_subtract(std::set<int> A, std::set<int> B, std::set<int>& C)$/;"	f
set_trans	phasta/phastaChef.h	/^    void set_trans(double x, double y, double z){$/;"	f	struct:ph::rigidBodyMotion
setstream	lion/lionPrint.c	37;"	d	file:
setup	ma/maLayerCollapse.cc	/^bool LayerCollapse::setup(Entity* edge)$/;"	f	class:ma::LayerCollapse
setup	mds/mdsUgrid.cc	/^      void setup() {$/;"	f	class:__anon101::ptnstats
setup	zoltan/apfZoltanCallbacks.cc	/^void ZoltanData::setup()$/;"	f	class:apf::ZoltanData
setupBalance	phasta/phAdapt.cc	/^void setupBalance(const char* key, std::string& method,$/;"	f	namespace:ph
setupCollapse	ma/maCollapse.cc	/^bool setupCollapse(Collapse& collapse, Entity* edge, Entity* vert)$/;"	f	namespace:ma
setupEstimation	spr/sprEstimateError.cc	/^static void setupEstimation(Estimation* e, apf::Field* eps, double tolerance)$/;"	f	namespace:spr
setupEstimation	spr/sprEstimateTargetError.cc	/^static void setupEstimation($/;"	f	namespace:spr::target
setupFlags	ma/maAdapt.cc	/^void setupFlags(Adapt* a)$/;"	f	namespace:ma
setupGhosts	pumi/pumi_ghost.cc	/^static void setupGhosts(pMesh m, EntityVector& received)$/;"	f	file:
setupInputSubdir	phasta/ph.cc	/^void setupInputSubdir(std::string& path)$/;"	f	namespace:ph
setupLayerForSplit	ma/maLayerRefine.cc	/^void setupLayerForSplit(Adapt* a)$/;"	f	namespace:ma
setupMatching	phasta/phAdapt.cc	/^void setupMatching(ma::Input& in) {$/;"	f	namespace:ph
setupNumberings	zoltan/apfZoltanMesh.cc	/^static void setupNumberings(ZoltanMesh* b)$/;"	f	namespace:apf
setupOutputDir	phasta/ph.cc	/^std::string setupOutputDir(bool all_mkdir)$/;"	f	namespace:ph
setupOutputSubdir	phasta/ph.cc	/^void setupOutputSubdir(std::string& path, bool all_mkdir)$/;"	f	namespace:ph
setupPatch	spr/sprRecoverField.cc	/^static void setupPatch(Patch* p, Recovery* r)$/;"	f	namespace:spr
setupPlan	parma/diffMC/parma_dcpartFixer.cc	/^    void setupPlan(muu& dcCompTgts, apf::Migration* plan) {$/;"	f	class:dcPartFixer::PartFixer	file:
setupQualityCache	ma/maAdapt.cc	/^void setupQualityCache(Adapt* a)$/;"	f	namespace:ma
setupRecovery	spr/sprRecoverField.cc	/^static void setupRecovery(Recovery* r, apf::Field* f)$/;"	f	namespace:spr
setupRefineForLayer	ma/maLayerRefine.cc	/^void setupRefineForLayer(Refine* r)$/;"	f	namespace:ma
setupRegionCollapse	ma/maRegionCollapse.cc	/^bool setupRegionCollapse(RegionCollapse& rcollapse, Entity* region)$/;"	f	namespace:ma
setupRemotes	apf/apfMigrate.cc	/^static void setupRemotes($/;"	f	namespace:apf
setup_	ma/maLayerCollapse.cc	/^bool LayerCollapse::setup_(Entity* edge)$/;"	f	class:ma::LayerCollapse
setup_grid	test/poisson.cc	/^    void setup_grid() {$/;"	f	class:__anon17::Poisson	file:
setup_lin_alg	test/poisson.cc	/^    void setup_lin_alg() {$/;"	f	class:__anon17::Poisson	file:
sf	crv/crvShapeFixer.h	/^    ma::SizeField* sf;$/;"	m	class:crv::CrvEdgeEdgeFixer
sf	ma/maShape.cc	/^    SizeField* sf;$/;"	m	class:ma::EdgeEdgeFixer	file:
sh	crv/crvShape.cc	/^  ma::ShapeHandler* sh;$/;"	m	struct:crv::IsBadCrvQuality	file:
shape	apf/apfCoordData.h	/^    FieldShape* shape;$/;"	m	class:apf::CoordData
shape	apf/apfElement.h	/^    EntityShape* shape;$/;"	m	class:apf::Element
shape	apf/apfField.h	/^    FieldShape* shape;$/;"	m	class:apf::FieldBase
shape	apf/apfTagData.h	/^    FieldShape* shape;$/;"	m	class:apf::TagData
shape	ma/maAdapt.h	/^    ShapeHandler* shape;$/;"	m	class:ma::Adapt
shape	ma/maAdapt.h	/^    ShapeHandler* shape;$/;"	m	class:ma::Cavity
shape	ma/maEdgeSwap.cc	/^    ShapeHandler* shape;$/;"	m	class:ma::SwapCavity	file:
shape	ma/maSolutionTransfer.cc	/^    apf::FieldShape* shape;$/;"	m	class:ma::FieldTransfer	file:
shape	test/hierarchic.cc	/^    apf::FieldShape* shape;$/;"	m	class:__anon20::L2Projector	file:
shape	test/poisson.cc	/^    apf::FieldShape* shape;$/;"	m	class:__anon17::Poisson	file:
shapeHandler	ma/maInput.h	/^    ShapeHandlerFunction shapeHandler;$/;"	m	class:ma::Input
sharBdryAvg	parma/extractParmaResults.py	/^sharBdryAvg = metric("sharedBoundaryVtxAvg")$/;"	v
sharBdryMax	parma/extractParmaResults.py	/^sharBdryMax = metric("sharedBoundaryVtxMax")$/;"	v
sharBdryMin	parma/extractParmaResults.py	/^sharBdryMin = metric("sharedBoundaryVtxMin")$/;"	v
sharBdryTot	parma/extractParmaResults.py	/^sharBdryTot = metric("sharedBoundaryVtxTotal")$/;"	v
sharedReduction	apf/apf.cc	/^void sharedReduction(Field* f, Sharing* shr, bool delete_shr,$/;"	f	namespace:apf
sharedWithPeer	parma/diffMC/parma_shapeSelector.cc	/^  bool sharedWithPeer(apf::Mesh* m, apf::MeshEntity* e, int peer) {$/;"	f	namespace:__anon57
sharedWithTarget	parma/diffMC/parma_shapeSelector.cc	/^  bool sharedWithTarget(apf::Mesh* m, apf::MeshEntity* e, parma::Targets* t) {$/;"	f	namespace:__anon57
sharing	apf/apfCavityOp.h	/^    Sharing* sharing;$/;"	m	class:apf::CavityOp
sharing	ma/maMatchedCollapse.h	/^  apf::Sharing* sharing;$/;"	m	struct:ma::MatchedCollapse
sharing	ma/maMatchedSnapper.h	/^    apf::Sharing* sharing;$/;"	m	class:ma::MatchedSnapper
shift	pcu/pcu_coll.h	/^  int (*shift)(int bit); \/\/shift the bit up or down$/;"	m	struct:__anon39
shift_matrix	mth/mthQR.cc	/^static void shift_matrix(Matrix<T,M,M>& a, double mu)$/;"	f	namespace:mth
shortEdgeRatio	crv/crvShapeFixer.h	/^    double shortEdgeRatio;$/;"	m	class:crv::CrvShortEdgeFixer
shortEdgeRatio	ma/maShape.cc	/^    double shortEdgeRatio;$/;"	m	class:ma::ShortEdgeFixer	file:
shouldApply	crv/crvShape.cc	/^  virtual bool shouldApply(ma::Entity* e)$/;"	f	class:crv::EdgeReshaper
shouldApply	crv/crvShape.cc	/^  virtual bool shouldApply(ma::Entity* e)$/;"	f	class:crv::EdgeSwapper
shouldApply	crv/crvShapeFixer.cc	/^bool CrvLargeAngleTetFixer::shouldApply(apf::MeshEntity* e)$/;"	f	class:crv::CrvLargeAngleTetFixer
shouldApply	crv/crvShapeFixer.cc	/^bool CrvLargeAngleTriFixer::shouldApply(apf::MeshEntity* e)$/;"	f	class:crv::CrvLargeAngleTriFixer
shouldApply	crv/crvShapeFixer.cc	/^bool CrvShortEdgeFixer::shouldApply(apf::MeshEntity* e)$/;"	f	class:crv::CrvShortEdgeFixer
shouldApply	ma/maCoarsen.cc	/^    virtual bool shouldApply(Entity* e)$/;"	f	class:ma::AllEdgeCollapser
shouldApply	ma/maCoarsen.cc	/^    virtual bool shouldApply(Entity* e)$/;"	f	class:ma::MatchedEdgeCollapser
shouldApply	ma/maShape.cc	/^    virtual bool shouldApply(Entity* e)$/;"	f	class:ma::LargeAngleTetAligner
shouldApply	ma/maShape.cc	/^    virtual bool shouldApply(Entity* e)$/;"	f	class:ma::LargeAngleTetFixer
shouldApply	ma/maShape.cc	/^    virtual bool shouldApply(Entity* e)$/;"	f	class:ma::LargeAngleTriFixer
shouldApply	ma/maShape.cc	/^    virtual bool shouldApply(Entity* e)$/;"	f	class:ma::QualityImprover2D
shouldApply	ma/maShape.cc	/^    virtual bool shouldApply(Entity* e)$/;"	f	class:ma::ShortEdgeFixer
shouldApply	ma/maSnap.cc	/^    bool shouldApply(Entity* e)$/;"	f	class:ma::SnapAll
shouldApply	ma/maSnap.cc	/^    bool shouldApply(Entity* e)$/;"	f	class:ma::SnapMatched
shouldApply	ma/maSnap_mohara.cc	/^    bool shouldApply(Entity* e)$/;"	f	class:ma::SnapAll
shouldApply	ma/maSnap_mohara.cc	/^    bool shouldApply(Entity* e)$/;"	f	class:ma::SnapMatched
shouldCheckQualityForDoubleSplits	ma/maInput.h	/^    double shouldCheckQualityForDoubleSplits;$/;"	m	class:ma::Input
shouldCleanupLayer	ma/maInput.h	/^    bool shouldCleanupLayer;$/;"	m	class:ma::Input
shouldCoarsen	ma/maInput.h	/^    bool shouldCoarsen;$/;"	m	class:ma::Input
shouldCoarsenLayer	ma/maInput.h	/^    bool shouldCoarsenLayer;$/;"	m	class:ma::Input
shouldCollapse	ma/maSize.cc	/^  bool shouldCollapse(Entity* edge)$/;"	f	struct:ma::MetricSizeField
shouldCollapse	ma/maSize.cc	/^bool IdentitySizeField::shouldCollapse(Entity*)$/;"	f	class:ma::IdentitySizeField
shouldCollect	ma/maRefine.h	/^    bool shouldCollect[4];$/;"	m	class:ma::Refine
shouldFit	ma/maAdapt.h	/^    bool shouldFit;$/;"	m	class:ma::Cavity
shouldFixShape	ma/maInput.h	/^    bool shouldFixShape;$/;"	m	class:ma::Input
shouldForceAdaptation	ma/maInput.h	/^    bool shouldForceAdaptation;$/;"	m	class:ma::Input
shouldHandleMatching	ma/maInput.h	/^    bool shouldHandleMatching;$/;"	m	class:ma::Input
shouldOutBeIn	apf/apfPartition.h	/^  bool shouldOutBeIn(int out)$/;"	f	struct:apf::Expand
shouldPrint	apf/apfVtk.cc	/^static bool shouldPrint($/;"	f	namespace:apf
shouldPrintQuality	ma/maInput.h	/^    bool shouldPrintQuality;$/;"	m	class:ma::Input
shouldRefineLayer	ma/maInput.h	/^    bool shouldRefineLayer;$/;"	m	class:ma::Input
shouldRunMidParma	ma/maInput.h	/^    bool shouldRunMidParma;$/;"	m	class:ma::Input
shouldRunMidZoltan	ma/maInput.h	/^    bool shouldRunMidZoltan;$/;"	m	class:ma::Input
shouldRunPostParma	ma/maInput.h	/^    bool shouldRunPostParma;$/;"	m	class:ma::Input
shouldRunPostZoltan	ma/maInput.h	/^    bool shouldRunPostZoltan;$/;"	m	class:ma::Input
shouldRunPostZoltanRib	ma/maInput.h	/^    bool shouldRunPostZoltanRib;$/;"	m	class:ma::Input
shouldRunPreParma	ma/maInput.h	/^    bool shouldRunPreParma;$/;"	m	class:ma::Input
shouldRunPreZoltan	ma/maInput.h	/^    bool shouldRunPreZoltan;$/;"	m	class:ma::Input
shouldRunPreZoltanRib	ma/maInput.h	/^    bool shouldRunPreZoltanRib;$/;"	m	class:ma::Input
shouldSnap	crv/crvShapeHandler.cc	/^    bool shouldSnap;$/;"	m	class:crv::BezierHandler	file:
shouldSnap	crv/crvShapeHandler.cc	/^    bool shouldSnap;$/;"	m	class:crv::BezierTransfer	file:
shouldSnap	ma/maInput.h	/^    bool shouldSnap;$/;"	m	class:ma::Input
shouldSplit	ma/maSize.cc	/^  bool shouldSplit(Entity* edge)$/;"	f	struct:ma::MetricSizeField
shouldSplit	ma/maSize.cc	/^bool IdentitySizeField::shouldSplit(Entity*)$/;"	f	class:ma::IdentitySizeField
shouldSplit	ma/maSize.h	/^  bool shouldSplit(Entity*)$/;"	f	struct:ma::UniformRefiner
shouldTransfer	ma/maAdapt.h	/^    bool shouldTransfer;$/;"	m	class:ma::Cavity
shouldTransferParametric	ma/maInput.h	/^    bool shouldTransferParametric;$/;"	m	class:ma::Input
shouldTransferToClosestPoint	ma/maInput.h	/^    bool shouldTransferToClosestPoint;$/;"	m	class:ma::Input
shouldTurnLayerToTets	ma/maInput.h	/^    bool shouldTurnLayerToTets;$/;"	m	class:ma::Input
should_attach_order	phasta/ph_convert.cc	/^int should_attach_order = 0;$/;"	v
should_attach_order	test/convert.cc	/^int should_attach_order = 0;$/;"	v
should_fix_pyramids	phasta/ph_convert.cc	/^int should_fix_pyramids = 1;$/;"	v
should_fix_pyramids	test/convert.cc	/^int should_fix_pyramids = 1;$/;"	v
should_log	phasta/ph_convert.cc	/^int should_log = 0;$/;"	v
should_log	test/convert.cc	/^int should_log = 0;$/;"	v
should_log	test/generate.cc	/^int should_log = 0;$/;"	m	namespace:__anon19	file:
should_log	test/rm_extrusion.cc	/^int should_log = 0;$/;"	v
sideTol	parma/diffMC/parma_elmBalancer.cc	/^      double sideTol;$/;"	m	class:__anon60::ElmBalancer	file:
sideTol	parma/diffMC/parma_elmLtVtxEdgeBalancer.cc	/^      int sideTol;$/;"	m	class:__anon66::ElmLtVtxEdge	file:
sideTol	parma/diffMC/parma_ghost.cc	/^      int sideTol;$/;"	m	class:__anon68::GhostElmBalancer	file:
sideTol	parma/diffMC/parma_ghost.cc	/^      int sideTol;$/;"	m	class:__anon68::GhostVtxLtElmBalancer	file:
sideTol	parma/diffMC/parma_ghostElement.cc	/^      int sideTol;$/;"	m	class:__anon45::GhostEdgeBalancer	file:
sideTol	parma/diffMC/parma_ghostMPAS.cc	/^      int sideTol;$/;"	m	class:__anon67::MPASGhostBalancer	file:
sideTol	parma/diffMC/parma_vtxBalancer.cc	/^      int sideTol;$/;"	m	class:__anon55::VtxBalancer	file:
sideTol	parma/diffMC/parma_vtxEdgeElmBalancer.cc	/^      int sideTol;$/;"	m	class:__anon46::VtxEdgeBalancer	file:
sideTol	parma/diffMC/parma_vtxElmBalancer.cc	/^      int sideTol;$/;"	m	class:__anon71::ElmLtVtx	file:
side_maps	stk/apfMeshSTK.cc	/^static unsigned const* side_maps[Mesh::TYPES] =$/;"	m	namespace:apf	file:
sides	parma/diffMC/parma_step.h	/^      Sides* sides;$/;"	m	class:parma::Stepper
sidesAvg	parma/extractParmaResults.py	/^sidesAvg = metric("averageSides")$/;"	v
sign	apf/apfHierarchic.cc	/^static double sign(bool should_flip) {$/;"	f	namespace:apf
sign	mth/mthQR.cc	/^static double sign(double x)$/;"	f	namespace:mth
sim	gmi_sim/gmi_sim.cc	/^  SGModel* sim;$/;"	m	struct:sim_model	file:
simStart	test/generate.cc	/^void simStart() {$/;"	f	namespace:__anon19
simStop	test/generate.cc	/^void simStop() {$/;"	f	namespace:__anon19
sim_iter	gmi_sim/gmi_sim.cc	/^struct sim_iter {$/;"	s	file:
sim_model	gmi_sim/gmi_sim.cc	/^struct sim_model {$/;"	s	file:
simmetrixBalance	phasta/phPartition.cc	/^void simmetrixBalance(apf::Mesh2* m)$/;"	f	namespace:ph
simmetrixMesh	phasta/phInput.h	/^    int simmetrixMesh;$/;"	m	class:ph::Input
simpleRotateHex	ma/maLayerTemplates.cc	/^static void simpleRotateHex(Entity** v, int n, Entity** v2)$/;"	f	namespace:ma
simplex	crv/crvShape.cc	/^  ma::Entity* simplex;$/;"	m	class:crv::EdgeReshaper	file:
simplex	crv/crvShape.cc	/^  ma::Entity* simplex;$/;"	m	class:crv::EdgeSwapper	file:
simplexTypes	apf/apfMesh.cc	/^Mesh::Type const Mesh::simplexTypes[4] =$/;"	m	class:apf::Mesh::Mesh	file:
simplexTypes	apf/apfMesh.h	/^    static Type const simplexTypes[4];$/;"	m	class:apf::Mesh
sin	mth/mthAD.h	/^AD<T, N> sin(AD<T, N> const& A)$/;"	f	namespace:mth
sin	mth/mthAD.h	/^double sin(double A)$/;"	f	namespace:mth
size	can/canArray.h	/^    unsigned size() const {return N;}$/;"	f	class:can::Array
size	can/canArray.h	/^    unsigned size() const {return sz;}$/;"	f	class:can::Array
size	dsp/dspAdapters.cc	/^    double size;$/;"	m	class:dsp::UniformAdapter::MyFunction	file:
size	ma/maEdgeSwap.cc	/^    int size;$/;"	m	class:ma::SwapLoop	file:
size	mds/apfBox.h	/^  Indices size;$/;"	m	struct:apf::Grid
size	mth/mthAD.h	/^    unsigned int size() const {return N;}$/;"	f	class:mth::AD
size	mth/mthAD.h	/^    unsigned size() const { return dx_.size();}$/;"	f	class:mth::AD
size	mth/mthAD.h	/^    unsigned size() { return dx_.size();}$/;"	f	class:mth::AD
size	parma/diffMC/parma_associative.h	/^      size_t size() {$/;"	f	class:parma::Associative
size	parma/diffMC/parma_components.cc	/^  unsigned DCC::size() { return n; }$/;"	f	class:parma::DCC
size	parma/diffMC/parma_components.cc	/^  unsigned dcComponents::size() { return c->size(); }$/;"	f	class:parma::dcComponents
size	parma/diffMC/parma_distQ.h	/^    size_t size()$/;"	f	class:parma::DistanceQueue
size	parma/diffMC/parma_monitor.cc	/^  unsigned int CircBuffer::size() { return sz; }$/;"	f	class:parma::CircBuffer
size	pcu/pcu_buffer.h	/^  size_t size;$/;"	m	struct:__anon36
size	pcu/pcu_mpi.h	/^  int (*size)(void);$/;"	m	struct:__anon34
size	phasta/phBC.cc	/^static struct { const char* name; int size; } const knownSizes[7] =$/;"	m	struct:ph::__anon90	file:
size	pumi/GenTag.h	/^    int size;$/;"	m	class:Taggable
size	pumi/mPartEntityContainer.cc	/^int mPartEntityContainer::size(int what) const $/;"	f	class:mPartEntityContainer
size	pumi/pumi.h	/^  int size(int d) {return allEntities.size(d); }$/;"	f	class:gModel
size	pumi/pumi_list.h	/^    std::size_t size() const {return count;}$/;"	f	class:List
size	spr/sprEstimateError.cc	/^  apf::Field* size;$/;"	m	struct:spr::Estimation	file:
sizeField	crv/crvShapeFixer.h	/^    ma::SizeField* sizeField;$/;"	m	class:crv::CrvShortEdgeFixer
sizeField	crv/crvShapeHandler.cc	/^    ma::SizeField * sizeField;$/;"	m	class:crv::BezierHandler	file:
sizeField	ma/maAdapt.h	/^    SizeField* sizeField;$/;"	m	class:ma::Adapt
sizeField	ma/maInput.h	/^    SizeField* sizeField;$/;"	m	class:ma::Input
sizeField	ma/maShape.cc	/^    SizeField* sizeField;$/;"	m	class:ma::ShortEdgeFixer	file:
sizeField	ma/maShapeHandler.cc	/^    SizeField* sizeField;$/;"	m	class:ma::LinearHandler	file:
sizeField	ma/maSize.cc	/^    SizeField* sizeField;$/;"	m	class:ma::SizeFieldIntegrator	file:
size_factor	spr/sprEstimateError.cc	/^  double size_factor;$/;"	m	struct:spr::Estimation	file:
size_factor	spr/sprEstimateTargetError.cc	/^  double size_factor;$/;"	m	struct:spr::target::Estimation	file:
sizesEval	ma/maSize.cc	/^  SizesEval sizesEval;$/;"	m	struct:ma::AnisoSizeField	file:
skew	pcu/pcu_aa.c	/^static void skew(pcu_aa_tree* t)$/;"	f	file:
skip	mds/mds.c	/^static mds_id skip(struct mds* m, mds_id e)$/;"	f	file:
skip_leading_spaces	phasta/phIO.c	/^static void skip_leading_spaces(char** s)$/;"	f	file:
slope	parma/diffMC/parma_monitor.cc	/^  double Slope::slope() {$/;"	f	class:parma::Slope
smallLimit	parma/diffMC/parma_shapeTargets.cc	/^      int smallLimit;$/;"	m	class:parma::ShapeTargets	file:
smartPrismToPyramidAndTet	ma/maLayerTemplates.cc	/^static void smartPrismToPyramidAndTet(Refine* r, Entity* p, Entity** v)$/;"	f	namespace:ma
smb2mds	mds/mds_smb.c	/^static int smb2mds(int smb_type)$/;"	f	file:
smb_path	phasta/ph_convert.cc	/^const char* smb_path = NULL;$/;"	v
smb_path	test/convert.cc	/^const char* smb_path = NULL;$/;"	v
smooth	dsp/dspSmoothers.cc	/^  void smooth(apf::Field* df, Boundary& fixed, Boundary& moving)$/;"	f	class:dsp::EmptySmoother
smooth	dsp/dspSmoothers.cc	/^  void smooth(apf::Field* df, Boundary& fixed, Boundary& moving)$/;"	f	class:dsp::LaplacianSmoother
smsNew_path	test/rm_extrusion.cc	/^const char* smsNew_path = NULL;$/;"	v
sms_path	phasta/ph_convert.cc	/^const char* sms_path = NULL;$/;"	v
sms_path	test/convert.cc	/^const char* sms_path = NULL;$/;"	v
sms_path	test/rm_extrusion.cc	/^const char* sms_path = NULL;$/;"	v
snap	ma/maLayerSnap.cc	/^  void snap(Entity* v)$/;"	f	struct:ma::LayerSnapper
snap	ma/maSnap.cc	/^void snap(Adapt* a)$/;"	f	namespace:ma
snap	ma/maSnap_mohara.cc	/^void snap(Adapt* a)$/;"	f	namespace:ma
snap	phasta/phInput.h	/^    int snap;$/;"	m	class:ph::Input
snapAllCurves	ma/maLayerSnap.cc	/^static long snapAllCurves(Adapt* a, Tag* snapTag)$/;"	f	namespace:ma
snapAllVerts	ma/maSnap.cc	/^bool snapAllVerts(Adapt* a, Tag* t, bool isSimple, long& successCount)$/;"	f	namespace:ma
snapAllVerts	ma/maSnap_mohara.cc	/^bool snapAllVerts(Adapt* a, Tag* t, bool isSimple, long& successCount)$/;"	f	namespace:ma
snapLayer	ma/maLayerSnap.cc	/^void snapLayer(Adapt* a, Tag* snapTag)$/;"	f	namespace:ma
snapMatchedVerts	ma/maSnap.cc	/^bool snapMatchedVerts(Adapt* a, Tag* t, bool isSimple, long& successCount)$/;"	f	namespace:ma
snapMatchedVerts	ma/maSnap_mohara.cc	/^bool snapMatchedVerts(Adapt* a, Tag* t, bool isSimple, long& successCount)$/;"	f	namespace:ma
snapOneRound	ma/maSnap.cc	/^bool snapOneRound(Adapt* a, Tag* t, bool isSimple, long& successCount)$/;"	f	namespace:ma
snapOneRound	ma/maSnap_mohara.cc	/^bool snapOneRound(Adapt* a, Tag* t, bool isSimple, long& successCount)$/;"	f	namespace:ma
snapTag	ma/maLayerSnap.cc	/^  Tag* snapTag;$/;"	m	struct:ma::LayerSnapper	file:
snapTag	ma/maLayerSnap.cc	/^  Tag* snapTag;$/;"	m	struct:ma::SnapTagger	file:
snapTag	ma/maLayerSnap.cc	/^  Tag* snapTag;$/;"	m	struct:ma::UnsnapChecker	file:
snapTag	ma/maLayerSnap.cc	/^  Tag* snapTag;$/;"	m	struct:ma::Unsnapper	file:
snapTag	ma/maMatchedSnapper.h	/^    Tag* snapTag;$/;"	m	class:ma::MatchedSnapper
snapTag	ma/maSnapper.h	/^    Tag* snapTag;$/;"	m	class:ma::FirstProblemPlane
snapTag	ma/maSnapper.h	/^    Tag* snapTag;$/;"	m	class:ma::Snapper
snapTaggedVerts	ma/maSnap.cc	/^long snapTaggedVerts(Adapt* a, Tag* tag)$/;"	f	namespace:ma
snapTaggedVerts	ma/maSnap_mohara.cc	/^long snapTaggedVerts(Adapt* a, Tag* tag)$/;"	f	namespace:ma
snapToInterpolate	crv/crvCurveMesh.cc	/^void MeshCurver::snapToInterpolate(int dim)$/;"	f	class:crv::MeshCurver
snapToInterpolate	crv/crvCurveMesh.cc	/^void snapToInterpolate(apf::Mesh2* m, apf::MeshEntity* e, bool isNew)$/;"	f	namespace:crv
snapToModel	apf/apfMesh.cc	/^void Mesh::snapToModel(ModelEntity* m, Vector3 const& p, Vector3& x)$/;"	f	class:apf::Mesh
snapper	ma/maSnap.cc	/^    MatchedSnapper snapper;$/;"	m	class:ma::SnapMatched	file:
snapper	ma/maSnap.cc	/^    Snapper snapper;$/;"	m	class:ma::SnapAll	file:
snapper	ma/maSnap_mohara.cc	/^    MatchedSnapper snapper;$/;"	m	class:ma::SnapMatched	file:
snapper	ma/maSnap_mohara.cc	/^    Snapper snapper;$/;"	m	class:ma::SnapAll	file:
snappers	ma/maMatchedSnapper.h	/^    apf::DynamicArray<Snapper*> snappers;$/;"	m	class:ma::MatchedSnapper
sol	test/poisson.cc	/^    apf::Field* sol;$/;"	m	class:__anon17::Poisson	file:
sol_mid	test/poisson.cc	/^    apf::Field* sol_mid;$/;"	m	class:__anon17::Poisson	file:
sol_vtx	test/poisson.cc	/^    apf::Field* sol_vtx;$/;"	m	class:__anon17::Poisson	file:
solution	test/poisson.cc	/^static double solution(apf::Vector3 const& p, int d) {$/;"	f	namespace:__anon17
solutionBCs	phasta/phBC.cc	/^static KnownBC const solutionBCs[7] = {$/;"	m	namespace:ph	file:
solutionMigration	phasta/phInput.h	/^    int solutionMigration;$/;"	m	class:ph::Input
solutionTransfer	ma/maAdapt.h	/^    SolutionTransfer* solutionTransfer;$/;"	m	class:ma::Adapt
solutionTransfer	ma/maAdapt.h	/^    SolutionTransfer* solutionTransfer;$/;"	m	class:ma::Cavity
solutionTransfer	ma/maInput.h	/^    SolutionTransfer* solutionTransfer;$/;"	m	class:ma::Input
solve	parma/diffMC/zeroOneKnapsack.c	/^size_t solve(Knapsack knapsack) {$/;"	f
solve	test/hierarchic.cc	/^void L2Projector::solve() {$/;"	f	class:__anon20::L2Projector
solveFromQR	mth/mthQR.cc	/^void solveFromQR(Matrix<T,M,M> const& q,$/;"	f	namespace:mth
solveQR	mth/mthQR.cc	/^bool solveQR(Matrix<T,M,N> const& a,$/;"	f	namespace:mth
solve_lin_sys	test/poisson.cc	/^    void solve_lin_sys() {$/;"	f	class:__anon17::Poisson	file:
sortByDepth	parma/diffMC/parma_components.cc	/^  void DCC::sortByDepth() {$/;"	f	class:parma::DCC
sortEigen	test/eigen_test.cc	/^static void sortEigen(apf::Matrix3x3 & ev, apf::Vector3 & ew)$/;"	f	file:
sortVectors	test/eigen_test.cc	/^static void sortVectors(apf::Vector<4> v[3])$/;"	f	file:
sort_verts	mds/mds_order.c	/^static mds_id* sort_verts(struct mds_apf* m, struct mds_tag* tag)$/;"	f	file:
sorted	gmi/gmi_lookup.c	/^  struct entry* sorted[AGM_ENT_TYPES];$/;"	m	struct:gmi_lookup	typeref:struct:gmi_lookup::entry	file:
special_declare_element_side	stk/apfMeshSTK.cc	/^static void special_declare_element_side($/;"	f	namespace:apf
specifiedIso	sam/sam.cc	/^apf::Field* specifiedIso(apf::Mesh* m, const char* fieldName, const unsigned idx)$/;"	f	namespace:sam
splineOrder	test/fusion3.cc	/^int splineOrder[6]={4,6,4,6,6,6};$/;"	v
split	apf/apfMigrate.cc	/^void split($/;"	f	namespace:apf
split	parma/rib/parma_mesh_rib.cc	/^    virtual apf::Migration* split(apf::MeshTag* weights, double,$/;"	f	class:parma::RibSplitter
split	pcu/pcu_aa.c	/^static void split(pcu_aa_tree* t)$/;"	f	file:
split	phasta/phPartition.cc	/^apf::Migration* split(Input& in, apf::Mesh2* m)$/;"	f	namespace:ph
split	zoltan/apfZoltan.cc	/^    virtual Migration* split(MeshTag* weights, double tolerance, int multiple)$/;"	f	class:apf::ZoltanSplitter
splitAllLayerEdges	ma/maInput.h	/^    bool splitAllLayerEdges;$/;"	m	class:ma::Input
splitAllLayerEdges	phasta/phInput.h	/^    int splitAllLayerEdges;$/;"	m	class:ph::Input
splitBezierTriangle	crv/crvSubdivision.cc	/^static void splitBezierTriangle(int P, apf::NewArray<T>& nodes,$/;"	f	namespace:crv
splitEdge	crv/crvSubdivision.cc	/^static void splitEdge(int P, double t, apf::NewArray<T>& nodes,$/;"	f	namespace:crv
splitEdge	ma/maTemplates.cc	/^static void splitEdge(Refine* r, Entity* edge, Entity** v)$/;"	f	namespace:ma
splitEdges	crv/crvAdapt.cc	/^void splitEdges(ma::Adapt* a)$/;"	f	namespace:crv
splitElement	ma/maRefine.cc	/^void splitElement(Refine* r, Entity* e)$/;"	f	namespace:ma
splitElements	ma/maRefine.cc	/^void splitElements(Refine* r)$/;"	f	namespace:ma
splitFactor	phasta/phInput.h	/^    int splitFactor;$/;"	m	class:ph::Input
splitMesh	parma/rib/parma_mesh_rib.cc	/^static apf::Migration* splitMesh(apf::Mesh* m, apf::MeshTag* weights, int depth)$/;"	f	namespace:parma
splitMeshOnGFace	phasta/splitMeshOnGFace_2arg.cpp	/^void ph::splitMeshOnGFace(pUnstructuredMesh pmesh, pGFace gf) {$/;"	f	class:ph
splitMeshOnGFace	phasta/splitMeshOnGFace_4arg.cpp	/^void ph::splitMeshOnGFace(pUnstructuredMesh pmesh, pGFace gf) {$/;"	f	class:ph
splitPrism_0	ma/maLayerTemplates.cc	/^void splitPrism_0(Refine* r, Entity* p, Entity** v)$/;"	f	namespace:ma
splitPrism_2	ma/maLayerTemplates.cc	/^void splitPrism_2(Refine* r, Entity* p, Entity** v)$/;"	f	namespace:ma
splitPrism_4	ma/maLayerTemplates.cc	/^void splitPrism_4(Refine* r, Entity* p, Entity** v)$/;"	f	namespace:ma
splitPrism_6	ma/maLayerTemplates.cc	/^void splitPrism_6(Refine* r, Entity* p, Entity** v)$/;"	f	namespace:ma
splitPrism_6_sv	ma/maLayerTemplates.cc	/^void splitPrism_6_sv(Refine* r, Entity* p, Entity** v, Entity** sv)$/;"	f	namespace:ma
splitPrism_9	ma/maLayerTemplates.cc	/^void splitPrism_9(Refine* r, Entity* p, Entity** v)$/;"	f	namespace:ma
splitPyramidCommon	ma/maLayerTemplates.cc	/^static void splitPyramidCommon(Refine* r, Entity* p, Entity** v)$/;"	f	namespace:ma
splitPyramidSearch	ma/maLayerTemplates.cc	/^static bool splitPyramidSearch(Refine* r, Entity* p, Entity** v)$/;"	f	namespace:ma
splitPyramidTop	ma/maLayerTemplates.cc	/^static void splitPyramidTop(Refine* r, Entity* p, Entity** v)$/;"	f	namespace:ma
splitPyramidUniform	ma/maLayerTemplates.cc	/^static void splitPyramidUniform(Refine* r, Entity* p, Entity** v)$/;"	f	namespace:ma
splitPyramid_0_b1	ma/maLayerTemplates.cc	/^static void splitPyramid_0_b1(Refine* r, Entity* p, Entity** v)$/;"	f	namespace:ma
splitPyramid_1_1	ma/maTemplates.cc	/^void splitPyramid_1_1(Refine* r, Entity* parent, Entity* v[5])$/;"	f	namespace:ma
splitPyramid_1_b0	ma/maLayerTemplates.cc	/^static void splitPyramid_1_b0(Refine* r, Entity* p, Entity** v)$/;"	f	namespace:ma
splitPyramid_1_b1	ma/maLayerTemplates.cc	/^static void splitPyramid_1_b1(Refine* r, Entity* p, Entity** v)$/;"	f	namespace:ma
splitPyramid_1_b1_a	ma/maLayerTemplates.cc	/^static void splitPyramid_1_b1_a(Refine* r, Entity* p, Entity** v)$/;"	f	namespace:ma
splitPyramid_1_b1_b	ma/maLayerTemplates.cc	/^static void splitPyramid_1_b1_b(Refine* r, Entity* p, Entity** v)$/;"	f	namespace:ma
splitPyramid_1_b2	ma/maLayerTemplates.cc	/^static void splitPyramid_1_b2(Refine* r, Entity* p, Entity** v)$/;"	f	namespace:ma
splitPyramid_1_b2_a	ma/maLayerTemplates.cc	/^static void splitPyramid_1_b2_a(Refine* r, Entity* p, Entity** v)$/;"	f	namespace:ma
splitPyramid_1_b2_b	ma/maLayerTemplates.cc	/^static void splitPyramid_1_b2_b(Refine* r, Entity* p, Entity** v)$/;"	f	namespace:ma
splitPyramid_2_b0	ma/maLayerTemplates.cc	/^static void splitPyramid_2_b0(Refine* r, Entity* p, Entity** v)$/;"	f	namespace:ma
splitPyramid_2_b1	ma/maLayerTemplates.cc	/^static void splitPyramid_2_b1(Refine* r, Entity* p, Entity** v)$/;"	f	namespace:ma
splitPyramid_2_b2	ma/maLayerTemplates.cc	/^static void splitPyramid_2_b2(Refine* r, Entity* p, Entity** v)$/;"	f	namespace:ma
splitPyramid_2_b2_bad	ma/maLayerTemplates.cc	/^void splitPyramid_2_b2_bad(Refine* r, Entity* p, Entity** v,$/;"	f	namespace:ma
splitPyramid_2_b2_sub_0	ma/maLayerTemplates.cc	/^void splitPyramid_2_b2_sub_0(Refine* r, Entity* p, Entity** v,$/;"	f	namespace:ma
splitPyramid_2_b2_sub_1	ma/maLayerTemplates.cc	/^void splitPyramid_2_b2_sub_1(Refine* r, Entity* p, Entity** v,$/;"	f	namespace:ma
splitPyramid_2_b2_sub_2	ma/maLayerTemplates.cc	/^void splitPyramid_2_b2_sub_2(Refine* r, Entity* p, Entity** v,$/;"	f	namespace:ma
splitPyramid_2_b2_sub_3	ma/maLayerTemplates.cc	/^void splitPyramid_2_b2_sub_3(Refine* r, Entity* p, Entity** v,$/;"	f	namespace:ma
splitPyramid_3_b0	ma/maLayerTemplates.cc	/^static void splitPyramid_3_b0(Refine* r, Entity* p, Entity** v)$/;"	f	namespace:ma
splitPyramid_3_b1	ma/maLayerTemplates.cc	/^static void splitPyramid_3_b1(Refine* r, Entity* p, Entity** v)$/;"	f	namespace:ma
splitPyramid_3_b2	ma/maLayerTemplates.cc	/^static void splitPyramid_3_b2(Refine* r, Entity* p, Entity** v)$/;"	f	namespace:ma
splitPyramid_4_b0	ma/maLayerTemplates.cc	/^static void splitPyramid_4_b0(Refine* r, Entity* p, Entity** v)$/;"	f	namespace:ma
splitPyramid_4_b1	ma/maLayerTemplates.cc	/^static void splitPyramid_4_b1(Refine* r, Entity* p, Entity** v)$/;"	f	namespace:ma
splitPyramid_4_b2	ma/maLayerTemplates.cc	/^static void splitPyramid_4_b2(Refine* r, Entity* p, Entity** v)$/;"	f	namespace:ma
splitPyramid_5_b0	ma/maLayerTemplates.cc	/^static void splitPyramid_5_b0(Refine* r, Entity* p, Entity** v)$/;"	f	namespace:ma
splitPyramid_5_b0_bad	ma/maLayerTemplates.cc	/^static void splitPyramid_5_b0_bad(Refine* r, Entity* p, Entity** v)$/;"	f	namespace:ma
splitPyramid_5_b1	ma/maLayerTemplates.cc	/^static void splitPyramid_5_b1(Refine* r, Entity* p, Entity** v)$/;"	f	namespace:ma
splitPyramid_b1_gen	ma/maLayerTemplates.cc	/^static void splitPyramid_b1_gen(Refine* r, Entity* p, Entity** v,$/;"	f	namespace:ma
splitQuad_0	ma/maLayerTemplates.cc	/^void splitQuad_0(Refine* r, Entity* q, Entity** v)$/;"	f	namespace:ma
splitQuad_2	ma/maLayerTemplates.cc	/^void splitQuad_2(Refine* r, Entity* q, Entity** v)$/;"	f	namespace:ma
splitQuad_4	ma/maLayerTemplates.cc	/^void splitQuad_4(Refine* r, Entity* q, Entity** v)$/;"	f	namespace:ma
splitSubTet	ma/maLayerTemplates.cc	/^static void splitSubTet(Refine* r, Entity* p, Entity** v, int code)$/;"	f	namespace:ma
splitTet	crv/crvSubdivision.cc	/^static void splitTet(int P, apf::Vector3& p, apf::NewArray<T>& nodes,$/;"	f	namespace:crv
splitTet_1	ma/maTemplates.cc	/^void splitTet_1(Refine* r, Entity* parent, Entity** v)$/;"	f	namespace:ma
splitTet_2_1	ma/maTemplates.cc	/^void splitTet_2_1(Refine* r, Entity* tet, Entity** v)$/;"	f	namespace:ma
splitTet_2_2	ma/maTemplates.cc	/^void splitTet_2_2(Refine* r, Entity* tet, Entity** v)$/;"	f	namespace:ma
splitTet_3_1	ma/maTemplates.cc	/^void splitTet_3_1(Refine* r, Entity* tet, Entity** v)$/;"	f	namespace:ma
splitTet_3_2	ma/maTemplates.cc	/^void splitTet_3_2(Refine* r, Entity* tet, Entity** v)$/;"	f	namespace:ma
splitTet_3_3	ma/maTemplates.cc	/^void splitTet_3_3(Refine* r, Entity* tet, Entity** v)$/;"	f	namespace:ma
splitTet_3_4	ma/maTemplates.cc	/^void splitTet_3_4(Refine* r, Entity* tet, Entity** v)$/;"	f	namespace:ma
splitTet_3_4_getCentroidXi	ma/maTemplates.cc	/^Vector splitTet_3_4_getCentroidXi($/;"	f	namespace:ma
splitTet_4_1	ma/maTemplates.cc	/^void splitTet_4_1(Refine* r, Entity* tet, Entity** v)$/;"	f	namespace:ma
splitTet_4_2	ma/maTemplates.cc	/^void splitTet_4_2(Refine* r, Entity* tet, Entity** v)$/;"	f	namespace:ma
splitTet_4_2_getCentroidXi	ma/maTemplates.cc	/^Vector splitTet_4_2_getCentroidXi($/;"	f	namespace:ma
splitTet_5	ma/maTemplates.cc	/^void splitTet_5(Refine* r, Entity* tet, Entity** v)$/;"	f	namespace:ma
splitTet_6	ma/maTemplates.cc	/^void splitTet_6(Refine* r, Entity* tet, Entity** v)$/;"	f	namespace:ma
splitTet_prismToTets	ma/maTemplates.cc	/^bool splitTet_prismToTets($/;"	f	namespace:ma
splitTri0	ma/maFaceSplit.cc	/^Entity* splitTri0(Adapt* a, Entity* parent)$/;"	f	namespace:ma
splitTri1	ma/maTemplates.cc	/^static void splitTri1(Refine* r, Entity* face, Entity** v)$/;"	f	namespace:ma
splitTri2	ma/maTemplates.cc	/^static void splitTri2(Refine* r, Entity* p, Entity** v)$/;"	f	namespace:ma
splitTri3	ma/maTemplates.cc	/^static void splitTri3(Refine* r, Entity* face, Entity** v)$/;"	f	namespace:ma
splitTriangle	crv/crvSubdivision.cc	/^static void splitTriangle(int P, apf::Vector3& p, apf::NewArray<T>& nodes,$/;"	f	namespace:crv
split_comm	pumi/pumi_mesh.cc	/^void split_comm(int num_out_comm)$/;"	f
splits	ma/maDoubleSplitCollapse.h	/^    Splits splits;$/;"	m	class:ma::DoubleSplitCollapse
spr	spr/spr.h	/^namespace spr {$/;"	n
spr	spr/sprEstimateError.cc	/^namespace spr {$/;"	n	file:
spr	spr/sprEstimateTargetError.cc	/^namespace spr {$/;"	n	file:
spr	spr/sprGetGradIPField.cc	/^namespace spr {$/;"	n	file:
spr	spr/sprRecoverField.cc	/^namespace spr {$/;"	n	file:
sqrt	mth/mthAD.h	/^AD<T, N> sqrt(AD<T, N> const& A)$/;"	f	namespace:mth
sqrt	mth/mthAD.h	/^double sqrt(double A)$/;"	f	namespace:mth
square	mth/mthQR.cc	/^static T square(T x)$/;"	f	namespace:mth
st	ma/maShapeHandler.cc	/^    SolutionTransfer* st;$/;"	m	class:ma::QuadraticHandler	file:
start	apf/apfGeometry.h	/^  Vector3 start;$/;"	m	struct:apf::LineSegment
start	apf/apfNumbering.cc	/^    T start;$/;"	m	class:apf::Globalizer	file:
start	ma/maSnapper.h	/^  Vector start;$/;"	m	struct:ma::Ray
start	pcu/pcu_buffer.h	/^  char* start;$/;"	m	struct:__anon36
startPatch	spr/sprRecoverField.cc	/^static void startPatch(Patch* p, apf::MeshEntity* e)$/;"	f	namespace:spr
startsWith	ma/maExtrude.cc	/^bool startsWith(std::string const& s, std::string const& pre) {$/;"	f	namespace:ma::__anon28
startsWith	mds/mdsGmsh.cc	/^bool startsWith(char const* prefix, char const* s)$/;"	f	namespace:__anon96
starts_with	gmi/gmi_file.c	/^static int starts_with(char const* with, char const* s)$/;"	f	file:
starts_with	mds/mds_smb.c	/^static int starts_with(const char* s, const char* w)$/;"	f	file:
state	pcu/pcu.c	/^enum state { uninit, init };$/;"	g	file:
state	pcu/pcu_msg.h	/^  int state; \/\/state within a communication phase$/;"	m	struct:pcu_msg_struct
stats	crv/crvAdapt.cc	/^void stats(ma::Mesh* m, ma::SizeField* sf,$/;"	f	namespace:crv
stats	ma/maStats.cc	/^void stats(ma::Mesh* m, ma::SizeField* sf,$/;"	f	namespace:ma
stats	test/capStoneIsoAdaptB737.cc	/^void stats(apf::Mesh2* m, apf::Field* f, double desiredQ, double &minQ, int &nQ, int &nMinL, int &nMaxL)$/;"	f
status	parma/diffMC/parma_commons.cc	/^void parmaCommons::status(const char* fmt,...) {$/;"	f	class:parmaCommons
step	parma/diffMC/parma_step.cc	/^  bool Stepper::step(double maxImb, int verbosity) {$/;"	f	class:parma::Stepper
stepDown	apf_cap/apfCAP.cc	/^static void stepDown(Mesh2* m, int type, int fromDim, MeshEntity** from, MeshEntity** to)$/;"	f	namespace:apf
stepNum	parma/diffMC/parma_ghost.cc	/^      int stepNum;$/;"	m	class:__anon68::GhostVtxLtElmBalancer	file:
step_down	mds/mds.c	/^static void step_down(struct mds* m,$/;"	f	file:
stitchMesh	apf/apfMesh2.cc	/^void stitchMesh(Mesh2* m)$/;"	f	namespace:apf
stitchVerts	ma/maExtrude.cc	/^void stitchVerts(Mesh* m, Crawler::Layer const& prev_verts,$/;"	f	namespace:ma::__anon28
stkField	stk/apfSTK.cc	/^    T* stkField;$/;"	m	class:apf::NodalBridge	file:
stkField	stk/apfSTK.cc	/^    T* stkField;$/;"	m	class:apf::QPBridge	file:
stkName	stk/apfAlbany.h	/^  std::string stkName;$/;"	m	struct:apf::StkModel
stop	parma/diffMC/parma_shapeOptimizer.cc	/^      bool stop(double imb, double maxImb) {$/;"	f	class:__anon47::ImbOrMaxNeighbor
stop	parma/diffMC/parma_step.h	/^      Stop* stop;$/;"	m	class:parma::Stepper
stop	parma/diffMC/parma_stop.cc	/^  bool BalOrStall::stop(double imb, double maxImb) {$/;"	f	class:parma::BalOrStall
stop	parma/diffMC/parma_stop.h	/^      bool stop(double imb, double maxImb) {$/;"	f	class:parma::Less
storeInArray	test/fusion2.cc	/^static void storeInArray(apf::Mesh2* m)$/;"	f	file:
stovAvg	parma/extractParmaResults.py	/^stovAvg = metric("sharedSidesToElementsAvg")$/;"	v
stovMax	parma/extractParmaResults.py	/^stovMax = metric("sharedSidesToElementsMax")$/;"	v
stovMin	parma/extractParmaResults.py	/^stovMin = metric("sharedSidesToElementsMin")$/;"	v
stride	mds/apfBox.h	/^  int stride[4];$/;"	m	struct:apf::Grid
stringset	phasta/phInput.cc	/^typedef std::set<std::string> stringset;$/;"	t	namespace:ph	file:
stripPath	apf/apfVtk.cc	/^static std::string stripPath(std::string const& s)$/;"	f	namespace:apf
subdivideBezierEdge	crv/crvSubdivision.cc	/^void subdivideBezierEdge(int P, double t, apf::NewArray<apf::Vector3>& nodes,$/;"	f	namespace:crv
subdivideBezierEdgeJacobianDet	crv/crvSubdivision.cc	/^static void subdivideBezierEdgeJacobianDet(int P, apf::NewArray<double>& nodes,$/;"	f	namespace:crv
subdivideBezierEntityJacobianDet	crv/crvSubdivision.cc	/^void subdivideBezierEntityJacobianDet(int P, int type,$/;"	f	namespace:crv
subdivideBezierJacobianDet	crv/crvSubdivision.cc	/^const SubdivisionFunction subdivideBezierJacobianDet[apf::Mesh::TYPES] =$/;"	m	namespace:crv	file:
subdivideBezierTet	crv/crvSubdivision.cc	/^void subdivideBezierTet(int P, apf::Vector3& p,$/;"	f	namespace:crv
subdivideBezierTriangle	crv/crvSubdivision.cc	/^void subdivideBezierTriangle(int P, apf::NewArray<apf::Vector3>& nodes,$/;"	f	namespace:crv
subdivideBezierTriangle	crv/crvSubdivision.cc	/^void subdivideBezierTriangle(int P, apf::Vector3& p,$/;"	f	namespace:crv
subdivideBezierTriangleJacobianDet	crv/crvSubdivision.cc	/^static void subdivideBezierTriangleJacobianDet(int P,$/;"	f	namespace:crv
subdivisionCoeffs	crv/crvQuality.cc	/^  apf::NewArray<double> subdivisionCoeffs[3];$/;"	m	class:crv::Quality2D	file:
subdivisionCoeffs	crv/crvQuality.cc	/^  apf::NewArray<double> subdivisionCoeffs[4];$/;"	m	class:crv::Quality3D	file:
successCount	ma/maCoarsen.cc	/^    int successCount;$/;"	m	class:ma::AllEdgeCollapser	file:
successCount	ma/maCoarsen.cc	/^    int successCount;$/;"	m	class:ma::MatchedEdgeCollapser	file:
successCount	ma/maSnap.cc	/^    int successCount;$/;"	m	class:ma::SnapAll	file:
successCount	ma/maSnap.cc	/^    int successCount;$/;"	m	class:ma::SnapMatched	file:
successCount	ma/maSnap_mohara.cc	/^    int successCount;$/;"	m	class:ma::SnapAll	file:
successCount	ma/maSnap_mohara.cc	/^    int successCount;$/;"	m	class:ma::SnapMatched	file:
successor	pcu/pcu_aa.c	/^  pcu_aa_node* successor;$/;"	m	struct:remove_vars	file:
sum	sam/samElementCount.cc	/^  double sum;$/;"	m	class:sam::TotalMetricVolumeIso	file:
sum	spr/sprEstimateError.cc	/^    double sum; \/\/element result$/;"	m	class:spr::ElementError	file:
sum	spr/sprEstimateTargetError.cc	/^    double sum;$/;"	m	class:spr::target::ElementError	file:
surfaceMeshFile	test/generate.cc	/^std::string surfaceMeshFile;$/;"	m	namespace:__anon19	file:
swap2d	ma/maEdgeSwap.cc	/^    EdgeSwap2D swap2d;$/;"	m	class:ma::EdgeSwap3D	file:
swapBytes	mds/mdsUgrid.cc	/^    bool swapBytes;$/;"	m	struct:__anon101::Reader	file:
swapInvalidEdges	crv/crvShape.cc	/^static void swapInvalidEdges(Adapt* a)$/;"	f	namespace:crv
swapRows	crv/crvMath.cc	/^static void swapRows(mth::Matrix<T>& a, int r1, int r2,$/;"	f	namespace:crv
swap_successor	pcu/pcu_aa.c	/^static void swap_successor(pcu_aa_tree* t, struct remove_vars* v)$/;"	f	file:
switchToAll	phasta/phCook.cc	/^void switchToAll(MPI_Comm orig)$/;"	f	namespace:__anon77
switchToAll	test/ptnParma.cc	/^void switchToAll()$/;"	f	namespace:__anon10
switchToAll	test/repartition.cc	/^void switchToAll()$/;"	f	namespace:__anon22
switchToAll	test/split.cc	/^void switchToAll()$/;"	f	namespace:__anon13
switchToAll	test/ugrid.cc	/^void switchToAll()$/;"	f
switchToAll	test/zsplit.cc	/^void switchToAll()$/;"	f	namespace:__anon4
switchToMasters	phasta/phCook.cc	/^void switchToMasters(int splitFactor)$/;"	f	namespace:__anon77
switchToMasters	test/ptnParma.cc	/^void switchToMasters()$/;"	f	namespace:__anon10
switchToOriginals	test/repartition.cc	/^bool switchToOriginals()$/;"	f	namespace:__anon22
switchToOriginals	test/split.cc	/^void switchToOriginals()$/;"	f	namespace:__anon13
switchToOriginals	test/ugrid.cc	/^void switchToOriginals(const int partitionFactor)$/;"	f
switchToOriginals	test/zsplit.cc	/^void switchToOriginals()$/;"	f	namespace:__anon4
sync	parma/rib/parma_mesh_rib.cc	/^    bool sync;$/;"	m	class:parma::RibSplitter	file:
syncFlag	ma/maAdapt.cc	/^void syncFlag(Adapt* a, int dimension, int flag)$/;"	f	namespace:ma
syncLayer	ma/maCrawler.cc	/^void syncLayer(Crawler* c, Crawler::Layer& layer)$/;"	f	namespace:ma
syncValues	test/fusion2.cc	/^static void syncValues(apf::Mesh2* m)$/;"	f	file:
synchronize	apf/apf.cc	/^void synchronize(Field* f, Sharing* shr)$/;"	f	namespace:apf
synchronize	apf/apfNumbering.cc	/^void synchronize(GlobalNumbering* n, Sharing* shr)$/;"	f	namespace:apf
synchronize	apf/apfNumbering.cc	/^void synchronize(Numbering * n, Sharing* shr, bool delete_shr)$/;"	f	namespace:apf
synchronize	crv/crvCurveMesh.cc	/^void MeshCurver::synchronize()$/;"	f	class:crv::MeshCurver
synchronizeEntitySet	apf/apfNumbering.cc	/^static void synchronizeEntitySet($/;"	f	namespace:apf
synchronizeFieldData	apf/apfFieldData.cc	/^void synchronizeFieldData(FieldDataOf<T>* data, Sharing* shr, bool delete_shr)$/;"	f	namespace:apf
sys	parma/extractParmaResults.py	/^import sys$/;"	i
sys	proteushash.py	/^import sys$/;"	i
sz	can/canArray.h	/^    unsigned sz;$/;"	m	class:can::Array
sz	parma/diffMC/parma_monitor.h	/^      unsigned int sz; \/* stored entries *\/$/;"	m	class:parma::CircBuffer
t	ma/maCrawler.cc	/^  Tagger t;$/;"	m	struct:ma::LayerNumberer	file:
t	ma/maCrawler.cc	/^  Tagger t;$/;"	m	struct:ma::TopFlagger	file:
t	parma/diffMC/parma_centroidSelector.cc	/^      apf::MeshTag* t;$/;"	m	class:__anon49::DistanceQueue	file:
t	parma/diffMC/parma_distQ.h	/^    apf::MeshTag* t;$/;"	m	class:parma::DistanceQueue
t0	mds/mds.c	/^static int const t0[] = {MDS_VERTEX,MDS_VERTEX,MDS_VERTEX};$/;"	v	file:
t01	apf_cap/apfCAP.cc	/^static int const t01[] =     {0,1,1,2,2,0};$/;"	m	namespace:apf	file:
t01	mds/mds.c	/^static int const t01[] =     {0,1,1,2,2,0};$/;"	v	file:
t1	mds/mds.c	/^static int const t1[] = {MDS_EDGE,MDS_EDGE,MDS_EDGE};$/;"	v	file:
t10	apf_cap/apfCAP.cc	/^static int const t10[] = {2,0,0,1,1,2};$/;"	m	namespace:apf	file:
t10	mds/mds.c	/^static int const t10[] = {2,0,0,1,1,2};$/;"	v	file:
tag	apf/apfMesh.h	/^    MeshTag* tag;$/;"	m	class:apf::Migration
tag	gmi/gmi.h	/^  int (*tag)(struct gmi_model* m, struct gmi_ent* e);$/;"	m	struct:gmi_model_ops
tag	gmi/gmi_lookup.c	/^  int tag;$/;"	m	struct:entry	file:
tag	gmi/gmi_lookup.c	/^  struct agm_tag* tag;$/;"	m	struct:gmi_lookup	typeref:struct:gmi_lookup::agm_tag	file:
tag	ma/maAdapt.h	/^  Tag* tag;$/;"	m	struct:ma::HasTag
tag	ma/maCrawler.cc	/^  Tag* tag;$/;"	m	struct:ma::LayerNumberer	file:
tag	ma/maCrawler.cc	/^  Tag* tag;$/;"	m	struct:ma::Tagger	file:
tag	ma/maLayerCoarsen.cc	/^  Tag* tag;$/;"	m	struct:ma::CurveLocalizer	file:
tag	ma/maSnap.cc	/^    Tag* tag;$/;"	m	class:ma::SnapAll	file:
tag	ma/maSnap.cc	/^    Tag* tag;$/;"	m	class:ma::SnapMatched	file:
tag	ma/maSnap_mohara.cc	/^    Tag* tag;$/;"	m	class:ma::SnapAll	file:
tag	ma/maSnap_mohara.cc	/^    Tag* tag;$/;"	m	class:ma::SnapMatched	file:
tag	mds/apfBox.h	/^  struct { int dim; int tag; } modelTable[27];$/;"	m	struct:apf::BoxBuilder::__anon95
tag	phasta/phBC.h	/^  int tag;$/;"	m	struct:ph::BC
tag	phasta/phastaChef.h	/^    int tag;$/;"	m	struct:ph::rigidBodyMotion
tag	stk/apfSTK.cc	/^  static const QPDimTag & tag()        \/\/\/< Singleton$/;"	f	struct:apf::QPDimTag
tagAngles	phasta/phAxisymmetry.cc	/^apf::MeshTag* tagAngles(apf::Mesh* m, BCs& bcs, apf::MatchedSharing* ms)$/;"	f	namespace:ph
tagContainer	apf_cap/apfCAP.cc	/^    std::map<MeshEntity*, void*> tagContainer;$/;"	m	class:apf::TagCAP	file:
tagData	apf/apfTagData.h	/^    TagData tagData;$/;"	m	class:apf::TagDataOf
tagLayerForSnap	ma/maLayerSnap.cc	/^static void tagLayerForSnap(Adapt* a, Tag* snapTag)$/;"	f	namespace:ma
tagOpposites	zoltan/apfInterElement.cc	/^MeshTag* tagOpposites(GlobalNumbering* gn, const char* name)$/;"	f	namespace:apf
tagSplits	ma/maLayerRefine.cc	/^static void tagSplits(Adapt* a)$/;"	f	namespace:ma
tagVertsToSnap	ma/maSnap.cc	/^long tagVertsToSnap(Adapt* a, Tag*& t)$/;"	f	namespace:ma
tagVertsToSnap	ma/maSnap_mohara.cc	/^long tagVertsToSnap(Adapt* a, Tag*& t)$/;"	f	namespace:ma
tag_name	pumi/GenTag.h	/^    std::string tag_name;$/;"	m	class:TagHandle
tag_size	pumi/GenTag.h	/^    int tag_size;$/;"	m	class:TagHandle
tag_type	pumi/GenTag.h	/^    int tag_type;$/;"	m	class:TagHandle
tags	apf/apfTagData.h	/^    MeshTag* tags[Mesh::TYPES];$/;"	m	class:apf::TagData
tags	apf_cap/apfCAP.h	/^    std::vector<TagCAP*> tags;$/;"	m	class:apf::MeshCAP
tags	apf_sim/apfSIM.h	/^    std::vector<TagSIM*> tags;$/;"	m	class:apf::MeshSIM
tags	gmi/agm.c	/^  struct agm_tags tags;$/;"	m	struct:agm	typeref:struct:agm::agm_tags	file:
tags	mds/mds_apf.h	/^  struct mds_tags tags;$/;"	m	struct:mds_apf	typeref:struct:mds_apf::mds_tags
tags	pumi/GenTag.h	/^    std::set<TagHandle> tags; $/;"	m	class:TagHolder
takeFirst	phasta/phConstraint.cc	/^static Constraint* takeFirst(Constraint* a, Constraint* b)$/;"	f	namespace:ph
take_local_link	mds/mds_net.c	/^static void take_local_link(mds_id i, struct mds_copy c, void* u)$/;"	f	file:
take_message	pcu/pcu_order.c	/^static struct message* take_message(pcu_msg* t)$/;"	f	file:
take_remote_link	mds/mds_net.c	/^static void take_remote_link(mds_id i, struct mds_copy c, void* u)$/;"	f	file:
tan	mth/mthAD.h	/^AD<T, N> tan(AD<T, N> const& A)$/;"	f	namespace:mth
target	spr/sprEstimateTargetError.cc	/^namespace target {$/;"	n	namespace:spr	file:
target_number	spr/sprEstimateTargetError.cc	/^  size_t target_number;$/;"	m	struct:spr::target::Estimation	file:
targets	parma/diffMC/parma_step.h	/^      Targets* targets;$/;"	m	class:parma::Stepper
tempTet	ma/maEdgeSwap.cc	/^    Cavity tempTet;$/;"	m	class:ma::SwapCavity	file:
tensor0Factory	phasta/phAttrib.cc	/^static ph::BC* tensor0Factory(pAttribute a, pGEntity ge)$/;"	f	file:
tensor1Factory	phasta/phAttrib.cc	/^static ph::BC* tensor1Factory(pAttribute a, pGEntity ge)$/;"	f	file:
tensorProduct	apf/apfMatrix.h	/^Matrix<M,N> tensorProduct(Vector<M> const& a, Vector<N> const& b)$/;"	f	namespace:apf
terms	parma/extractParmaResults.py	/^terms = []$/;"	v
test	test/1d.cc	/^void test(apf::Mesh2* m)$/;"	f
test	test/hierarchic.cc	/^void test(apf::Mesh* m, int p_order) {$/;"	f	namespace:__anon20
test	test/poisson.cc	/^void test(int dim, int p) {$/;"	f	namespace:__anon17
test	test/shapefun2.cc	/^namespace test {$/;"	n	file:
test1	parma/diffMC/zeroOneKnapsackTest.c	/^void test1() {$/;"	f
test2	parma/diffMC/zeroOneKnapsackTest.c	/^void test2() {$/;"	f
test2D	test/bezierMesh.cc	/^void test2D()$/;"	f
test2D	test/bezierRefine.cc	/^void test2D()$/;"	f
test2D	test/bezierValidity.cc	/^void test2D()$/;"	f
test3D	test/bezierMesh.cc	/^void test3D(apf::Mesh2* m)$/;"	f
test3D	test/bezierRefine.cc	/^void test3D()$/;"	f
test3D	test/bezierValidity.cc	/^void test3D()$/;"	f
test3DBlended	test/bezierMesh.cc	/^void test3DBlended()$/;"	f
test3DFull	test/bezierMesh.cc	/^void test3DFull()$/;"	f
test3DJacobian	test/bezierMesh.cc	/^void test3DJacobian(apf::Mesh2* m)$/;"	f
test3DJacobianTri	test/bezierMesh.cc	/^void test3DJacobianTri(apf::Mesh2* m)$/;"	f
testAlternateTetJacobian	test/bezierMesh.cc	/^static void testAlternateTetJacobian(apf::Mesh2* m)$/;"	f	file:
testBezier	test/curvetest.cc	/^static void testBezier(const char* modelFile, const char* meshFile,$/;"	f	file:
testDeterminant	test/tensor.cc	/^static void testDeterminant(mth::Tensor<double>& a)$/;"	f	namespace:__anon5
testDeviatoric	test/tensor.cc	/^static void testDeviatoric(mth::Tensor<double>& a)$/;"	f	namespace:__anon5
testEdgeElevation	test/bezierElevation.cc	/^void testEdgeElevation()$/;"	f
testEdgeGradients	test/bezierValidity.cc	/^static void testEdgeGradients(apf::Mesh2* m)$/;"	f	file:
testEdgeSubdivision	test/bezierSubdivision.cc	/^void testEdgeSubdivision()$/;"	f
testEigenQR	test/qr.cc	/^void testEigenQR()$/;"	f
testElementSize	test/curvetest.cc	/^static void testElementSize(apf::Mesh* m)$/;"	f	file:
testGregory	test/curvetest.cc	/^static void testGregory(const char* modelFile, const char* meshFile,$/;"	f	file:
testHessenberg	test/qr.cc	/^void testHessenberg()$/;"	f
testIndexing	test/fusion.cc	/^static void testIndexing(apf::Mesh2* m)$/;"	f	file:
testInterpolatedPoints2D	test/bezierMesh.cc	/^void testInterpolatedPoints2D(apf::Mesh2* m){$/;"	f
testInterpolating	test/curvetest.cc	/^static void testInterpolating(const char* modelFile, const char* meshFile,$/;"	f	file:
testInterpolationError	test/curvetest.cc	/^static void testInterpolationError(apf::Mesh* m, int entityDim,$/;"	f	file:
testInverse	test/tensor.cc	/^static void testInverse(mth::Tensor<double>& a)$/;"	f	namespace:__anon5
testJacobian	test/bezierValidity.cc	/^static void testJacobian(apf::Mesh2* m)$/;"	f	file:
testMatrixInverse	test/bezierMisc.cc	/^void testMatrixInverse(){$/;"	f
testMultiply	test/tensor.cc	/^static void testMultiply(mth::Tensor<double>& a)$/;"	f	namespace:__anon5
testNodeIndexing	test/bezierMisc.cc	/^void testNodeIndexing(){$/;"	f
testNodeValues	test/shapefun.cc	/^void testNodeValues(apf::EntityShape* shp, apf::Vector3 const* nodes, int nnodes)$/;"	f
testNorm	test/tensor.cc	/^static void testNorm(mth::Tensor<double>& a)$/;"	f	namespace:__anon5
testOwnership	test/pumi.cc	/^  testOwnership(pMesh m)$/;"	f	struct:testOwnership
testOwnership	test/pumi.cc	/^struct testOwnership : public Ownership $/;"	s	file:
testP1LineNodeValues	test/shapefun.cc	/^void testP1LineNodeValues()$/;"	f
testP1TetNodeValues	test/shapefun.cc	/^void testP1TetNodeValues() {$/;"	f
testP1TriNodeValues	test/shapefun.cc	/^void testP1TriNodeValues() {$/;"	f
testP2LineNodeValues	test/shapefun.cc	/^void testP2LineNodeValues()$/;"	f
testP2TetNodeValues	test/shapefun.cc	/^void testP2TetNodeValues() {$/;"	f
testP2TriNodeValues	test/shapefun.cc	/^void testP2TriNodeValues() {$/;"	f
testP3LineNodeValues	test/shapefun.cc	/^void testP3LineNodeValues()$/;"	f
testP3TetNodeValues	test/shapefun.cc	/^void testP3TetNodeValues() {$/;"	f
testP3TriNodeValues	test/shapefun.cc	/^void testP3TriNodeValues() {$/;"	f
testPrismNodeValues	test/shapefun.cc	/^void testPrismNodeValues()$/;"	f
testPrismVolume	test/shapefun.cc	/^void testPrismVolume()$/;"	f
testPyramidNodeValues	test/shapefun.cc	/^void testPyramidNodeValues()$/;"	f
testPyramidVolume	test/shapefun.cc	/^void testPyramidVolume()$/;"	f
testQuadrilateralNodeValues	test/shapefun.cc	/^void testQuadrilateralNodeValues() {$/;"	f
testReduce	test/fieldReduce.cc	/^bool testReduce(apf::Mesh* m, int casenum)$/;"	f	namespace:__anon15
testSize2D	test/bezierMesh.cc	/^void testSize2D(apf::Mesh2* m, int order)$/;"	f
testSize3D	test/bezierMesh.cc	/^void testSize3D(apf::Mesh2* m)$/;"	f
testSolveQR	test/qr.cc	/^static void testSolveQR()$/;"	f	file:
testTetEdge	test/align.cc	/^void testTetEdge()$/;"	f
testTetElevation	test/bezierElevation.cc	/^void testTetElevation()$/;"	f
testTetSubdivision1	test/bezierSubdivision.cc	/^void testTetSubdivision1()$/;"	f
testTetTri	test/align.cc	/^void testTetTri()$/;"	f
testTranspose	test/tensor.cc	/^static void testTranspose(mth::Tensor<double>& a)$/;"	f	namespace:__anon5
testTriEdge	test/align.cc	/^void testTriEdge()$/;"	f
testTriElevation	test/bezierElevation.cc	/^void testTriElevation()$/;"	f
testTriSubdivision1	test/bezierSubdivision.cc	/^void testTriSubdivision1()$/;"	f
testTriSubdivision4	test/bezierSubdivision.cc	/^void testTriSubdivision4()$/;"	f
testType	test/integrate.cc	/^static void testType(int type, double expectedSum)$/;"	f	file:
testVolume	test/shapefun.cc	/^void testVolume(int type, apf::Vector3 const* points, double volume)$/;"	f
test_2dStencil	parma/diffMC/maximalIndependentSet/test/testMIS.cc	/^int test_2dStencil(const int rank, const int totNumParts,$/;"	f
test_4partsA	parma/diffMC/maximalIndependentSet/test/testMIS.cc	/^int test_4partsA(const int rank, const int totNumParts, $/;"	f
test_4partsB	parma/diffMC/maximalIndependentSet/test/testMIS.cc	/^int test_4partsB(const int rank, const int totNumParts, $/;"	f
test_4partsC	parma/diffMC/maximalIndependentSet/test/testMIS.cc	/^int test_4partsC(const int rank, const int totNumParts,$/;"	f
test_StarA	parma/diffMC/maximalIndependentSet/test/testMIS.cc	/^int test_StarA(const int rank, const int totNumParts, $/;"	f
test_numbering	test/mixedNumbering.cc	/^static void test_numbering(apf::Mesh* m) {$/;"	f	file:
tet	crv/crvShapeFixer.h	/^    apf::MeshEntity* tet;$/;"	m	class:crv::CrvLargeAngleTetFixer
tet	ma/maShape.cc	/^    Entity* tet;$/;"	m	class:ma::FaceVertFixer	file:
tet	ma/maShape.cc	/^    Entity* tet;$/;"	m	class:ma::LargeAngleTetAligner	file:
tet	ma/maShape.cc	/^    Entity* tet;$/;"	m	class:ma::LargeAngleTetFixer	file:
tet	test/shapefun2.cc	/^static apf::Vector3 const tet[4] = {$/;"	m	class:test::apf	file:
tet_code_match	ma/maTables.cc	/^CodeMatch const tet_code_match[(1<<6)] =$/;"	m	namespace:ma	file:
tet_edge_code_count	ma/maTables.h	/^  tet_edge_code_count = 12,$/;"	e	enum:ma::__anon27
tet_edge_codes	ma/maTables.cc	/^int const tet_edge_codes[tet_edge_code_count] =$/;"	m	namespace:ma	file:
tet_edge_verts	apf/apfMesh.cc	/^int const tet_edge_verts[6][2] =$/;"	m	namespace:apf	file:
tet_edge_xi	crv/crvTables.cc	/^static apf::Vector3 const tet_edge_xi[6] = {$/;"	m	class:crv::apf	file:
tet_entity_quality	ma/maReposition.cc	/^static AD tet_entity_quality(Mesh* m, Entity* tet, Entity* v)$/;"	f	namespace:ma
tet_face_apf2ph	phasta/phAdjacent.cc	/^static int const tet_face_apf2ph[4] = {0,3,2,1};$/;"	m	namespace:ph	file:
tet_face_map	stk/apfMeshSTK.cc	/^static unsigned const tet_face_map[4] = {3,0,1,2};$/;"	m	namespace:apf	file:
tet_quality	ma/maReposition.cc	/^static AD tet_quality(ADVec v[4])$/;"	f	namespace:ma
tet_rotation	ma/maTables.cc	/^int const tet_rotation[12][4] =$/;"	m	namespace:ma	file:
tet_templates	ma/maTemplates.cc	/^SplitFunction tet_templates[tet_edge_code_count] =$/;"	m	namespace:ma	file:
tet_tri	crv/crvTables.cc	/^unsigned const* const* const* const tet_tri[7] =$/;"	m	namespace:crv	file:
tet_tri4	crv/crvTables.cc	/^static unsigned const* const* const tet_tri4[2] = {tet_tri4_f0,tet_tri4_f1};$/;"	m	namespace:crv	file:
tet_tri4_f0	crv/crvTables.cc	/^static unsigned const* const tet_tri4_f0[3] =$/;"	m	namespace:crv	file:
tet_tri4_f0r0	crv/crvTables.cc	/^static unsigned const tet_tri4_f0r0[3] = {0,1,2};$/;"	m	namespace:crv	file:
tet_tri4_f0r1	crv/crvTables.cc	/^static unsigned const tet_tri4_f0r1[3] = {2,0,1};$/;"	m	namespace:crv	file:
tet_tri4_f0r2	crv/crvTables.cc	/^static unsigned const tet_tri4_f0r2[3] = {1,2,0};$/;"	m	namespace:crv	file:
tet_tri4_f1	crv/crvTables.cc	/^static unsigned const* const tet_tri4_f1[3] =$/;"	m	namespace:crv	file:
tet_tri4_f1r0	crv/crvTables.cc	/^static unsigned const tet_tri4_f1r0[3] = {2,1,0};$/;"	m	namespace:crv	file:
tet_tri4_f1r1	crv/crvTables.cc	/^static unsigned const tet_tri4_f1r1[3] = {1,0,2};$/;"	m	namespace:crv	file:
tet_tri4_f1r2	crv/crvTables.cc	/^static unsigned const tet_tri4_f1r2[3] = {0,2,1};$/;"	m	namespace:crv	file:
tet_tri5	crv/crvTables.cc	/^static unsigned const* const* const tet_tri5[2] = {tet_tri5_f0,tet_tri5_f1};$/;"	m	namespace:crv	file:
tet_tri5_f0	crv/crvTables.cc	/^static unsigned const* const tet_tri5_f0[3] =$/;"	m	namespace:crv	file:
tet_tri5_f0r0	crv/crvTables.cc	/^static unsigned const tet_tri5_f0r0[6] = {0,1,2,3,4,5};$/;"	m	namespace:crv	file:
tet_tri5_f0r1	crv/crvTables.cc	/^static unsigned const tet_tri5_f0r1[6] = {5,3,0,4,1,2};$/;"	m	namespace:crv	file:
tet_tri5_f0r2	crv/crvTables.cc	/^static unsigned const tet_tri5_f0r2[6] = {2,4,5,1,3,0};$/;"	m	namespace:crv	file:
tet_tri5_f1	crv/crvTables.cc	/^static unsigned const* const tet_tri5_f1[3] =$/;"	m	namespace:crv	file:
tet_tri5_f1r0	crv/crvTables.cc	/^static unsigned const tet_tri5_f1r0[6] = {5,4,2,3,1,0};$/;"	m	namespace:crv	file:
tet_tri5_f1r1	crv/crvTables.cc	/^static unsigned const tet_tri5_f1r1[6] = {2,1,0,4,3,5};$/;"	m	namespace:crv	file:
tet_tri5_f1r2	crv/crvTables.cc	/^static unsigned const tet_tri5_f1r2[6] = {0,3,5,1,4,2};$/;"	m	namespace:crv	file:
tet_tri6	crv/crvTables.cc	/^static unsigned const* const* const tet_tri6[2] = {tet_tri6_f0,tet_tri6_f1};$/;"	m	namespace:crv	file:
tet_tri6_f0	crv/crvTables.cc	/^static unsigned const* const tet_tri6_f0[3] =$/;"	m	namespace:crv	file:
tet_tri6_f0r0	crv/crvTables.cc	/^static unsigned const tet_tri6_f0r0[10] = {0,1,2,3,4,5,6,7,8,9};$/;"	m	namespace:crv	file:
tet_tri6_f0r1	crv/crvTables.cc	/^static unsigned const tet_tri6_f0r1[10] = {9,7,4,0,8,5,1,6,2,3};$/;"	m	namespace:crv	file:
tet_tri6_f0r2	crv/crvTables.cc	/^static unsigned const tet_tri6_f0r2[10] = {3,6,8,9,2,5,7,1,4,0};$/;"	m	namespace:crv	file:
tet_tri6_f1	crv/crvTables.cc	/^static unsigned const* const tet_tri6_f1[3] =$/;"	m	namespace:crv	file:
tet_tri6_f1r0	crv/crvTables.cc	/^static unsigned const tet_tri6_f1r0[10] = {9,8,6,3,7,5,2,4,1,0};$/;"	m	namespace:crv	file:
tet_tri6_f1r1	crv/crvTables.cc	/^static unsigned const tet_tri6_f1r1[10] = {3,2,1,0,6,5,4,8,7,9};$/;"	m	namespace:crv	file:
tet_tri6_f1r2	crv/crvTables.cc	/^static unsigned const tet_tri6_f1r2[10] = {0,4,7,9,1,5,8,2,6,3};$/;"	m	namespace:crv	file:
tet_tri_edges	crv/crvTables.h	/^static int const tet_tri_edges[4][3] =$/;"	m	namespace:crv
tet_tri_verts	apf/apfMesh.cc	/^int const tet_tri_verts[4][3] =$/;"	m	namespace:apf	file:
tet_vert_xi	apf/apfBoundaryToElementXi.cc	/^static Vector3 const tet_vert_xi[4] = {$/;"	m	namespace:apf	file:
tet_vert_xi	crv/crvTables.cc	/^static apf::Vector3 const tet_vert_xi[4] = {$/;"	m	class:crv::apf	file:
tet_volume	ma/maReposition.cc	/^static AD tet_volume(ADVec v[4])$/;"	f	namespace:ma
tetrahedronize	ma/maTetrahedronize.cc	/^void tetrahedronize(Adapt* a)$/;"	f	namespace:ma
tetrahedronize	phasta/phAdapt.cc	/^void tetrahedronize(Input& in, apf::Mesh2* m)$/;"	f	namespace:ph
tetrahedronize	phasta/phInput.h	/^    int tetrahedronize;$/;"	m	class:ph::Input
tetrahedronizeCommon	ma/maTetrahedronize.cc	/^void tetrahedronizeCommon(Refine* r)$/;"	f	namespace:ma
tets	ma/maEdgeSwap.cc	/^    EntityArray tets;$/;"	m	class:ma::SwapCavity	file:
tetw	test/ugridptnstats.cc	/^const double tetw = 1.0;$/;"	v
tgts	parma/diffMC/parma_shapeOptimizer.cc	/^      int tgts;$/;"	m	class:__anon47::ImbOrMaxNeighbor	file:
theIter	pumi/GenIterator.h	/^    Iterator theIter;$/;"	m	class:GenIterator
threaded	phasta/phInput.h	/^    int threaded;$/;"	m	class:ph::Input
timeStepNumber	phasta/phInput.h	/^    int timeStepNumber;$/;"	m	class:ph::Input
timing	phasta/phInput.h	/^    int timing;$/;"	m	class:ph::Input
to	apf/apfCavityOp.h	/^    struct PullRequest { MeshEntity* e; int to; };$/;"	m	struct:apf::CavityOp::PullRequest
to	apf/apfFieldData.cc	/^    FieldDataOf<T>* to;$/;"	m	class:apf::AddOp	file:
to	apf/apfFieldData.cc	/^    FieldDataOf<T>* to;$/;"	m	class:apf::CopyOp	file:
to	apf/apfFieldData.cc	/^    FieldDataOf<T>* to;$/;"	m	class:apf::MultiplyOp	file:
to	apf/apfFieldOf.cc	/^    FieldOf<T>* to;$/;"	m	class:apf::Project	file:
to	apf/apfHierarchic.cc	/^    FieldOf<T>* to;$/;"	m	class:apf::Projector	file:
toArray	apf/apfMatrix.h	/^    void toArray(double (*array)[3]) const$/;"	f	class:apf::Matrix3x3
toArray	apf/apfVector.h	/^    void toArray(double* abc) const$/;"	f	class:apf::Vector3
toArray	mth/mthMatrix.h	/^    void toArray(T (*array)[3]) const$/;"	f	class:mth::Matrix3x3
toArray	mth/mthVector.h	/^    void toArray(T* abc) const$/;"	f	class:mth::Vector3
toEnt	mds/apfMDS.cc	/^static MeshEntity* toEnt(mds_id id)$/;"	f	namespace:apf
toEntity	apf_cap/apfCAP.cc	/^MeshEntity* toEntity(M_MTopo topo)$/;"	f	namespace:apf
toGmiEntity	gmi_cap/gmi_cap.cc	/^gmi_ent* toGmiEntity(M_GTopo topo)$/;"	f
toIter	mds/apfMDS.cc	/^static void toIter(mds_id id, MeshIterator* it)$/;"	f	namespace:apf
toModel	apf_cap/apfCAP.cc	/^ModelEntity* MeshCAP::toModel(MeshEntity* e)$/;"	f	class:apf::MeshCAP
toModel	apf_sim/apfSIM.cc	/^ModelEntity* MeshSIM::toModel(MeshEntity* e)$/;"	f	class:apf::MeshSIM
toModel	mds/apfMDS.cc	/^    ModelEntity* toModel(MeshEntity* e)$/;"	f	class:apf::MeshMDS
toSplit	ma/maFaceSplit.h	/^    EntityArray toSplit[4];$/;"	m	class:ma::FaceSplit
toSplit	ma/maRefine.h	/^    EntityArray toSplit[4];$/;"	m	class:ma::Refine
toVectors	test/eigen_test.cc	/^static void toVectors(apf::Matrix3x3 ev, apf::Vector3 ew,$/;"	f	file:
to_base	gmi/gmi_base.c	/^static struct gmi_base* to_base(struct gmi_model* m)$/;"	f	file:
to_model	gmi/gmi_analytic.c	/^static struct gmi_analytic* to_model(struct gmi_model* m)$/;"	f	file:
to_mth	apf/apf2mth.h	/^mth::Matrix<double, M, N> to_mth(apf::Matrix<M,N> const& a)$/;"	f	namespace:apf
to_mth	apf/apf2mth.h	/^mth::Vector<double, M> to_mth(apf::Vector<M> const& a)$/;"	f	namespace:apf
to_omega_h	omega_h/apfOmega_h.cc	/^void to_omega_h(osh::Mesh* om, apf::Mesh* am) {$/;"	f	namespace:apf
tol	ma/maSnapper.h	/^    double tol;$/;"	m	class:ma::FirstProblemPlane
tolerance	phasta/phModelGeometry.cc	/^double const tolerance = 1e-9;$/;"	m	namespace:ph	file:
tolerance	spr/sprEstimateError.cc	/^  double tolerance;$/;"	m	struct:spr::Estimation	file:
tolerance	zoltan/apfZoltanMesh.h	/^    double tolerance;$/;"	m	class:apf::ZoltanMesh
top	ma/maExtrude.h	/^  Model* top;$/;"	m	struct:ma::ModelExtrusion
topo	gmi/gmi_base.h	/^  struct agm* topo;$/;"	m	struct:gmi_base	typeref:struct:gmi_base::agm
topo	gmi/gmi_lookup.c	/^  struct agm* topo;$/;"	m	struct:gmi_lookup	typeref:struct:gmi_lookup::agm	file:
topo	pumi/GenIterator.h	/^    int topo; $/;"	m	class:GenIterator
totNumDc	parma/diffMC/parma_dcpartFixer.cc	/^    int totNumDc() {$/;"	f	class:dcPartFixer::PartFixer	file:
totTime	parma/extractParmaResults.py	/^totTime = sum(balAll)$/;"	v
totW	parma/diffMC/parma_elmLtVtxEdgeTargets.cc	/^      double totW;$/;"	m	class:parma::ElmLtVtxEdge	file:
totW	parma/diffMC/parma_preserveTargets.cc	/^      double totW;$/;"	m	class:parma::PreserveTargets	file:
totW	parma/diffMC/parma_shapeTargets.cc	/^      double totW;$/;"	m	class:parma::ShapeTargets	file:
totW	parma/diffMC/parma_vtxEdgeTargets.cc	/^      double totW;$/;"	m	class:parma::VtxEdgeTargets	file:
totW	parma/diffMC/parma_weightSideTargets.cc	/^      double totW;$/;"	m	class:parma::WeightSideTargets	file:
totW	parma/diffMC/parma_weightTargets.cc	/^      double totW;$/;"	m	class:parma::WeightTargets	file:
total	mds/apfBox.cc	/^int Grid::total() {return stride[3];}$/;"	f	class:apf::Grid
total	parma/diffMC/parma_elmLtVtxEdgeTargets.cc	/^      double total() {$/;"	f	class:parma::ElmLtVtxEdge
total	parma/diffMC/parma_preserveTargets.cc	/^      double total() {$/;"	f	class:parma::PreserveTargets
total	parma/diffMC/parma_shapeTargets.cc	/^      double total() {$/;"	f	class:parma::ShapeTargets
total	parma/diffMC/parma_sides.h	/^      virtual int total() { return totalSides;}$/;"	f	class:parma::Sides
total	parma/diffMC/parma_vtxEdgeTargets.cc	/^      double total() {$/;"	f	class:parma::VtxEdgeTargets
total	parma/diffMC/parma_weightSideTargets.cc	/^      double total() {$/;"	f	class:parma::WeightSideTargets
total	parma/diffMC/parma_weightTargets.cc	/^      double total() {$/;"	f	class:parma::WeightTargets
totalSides	parma/diffMC/parma_sides.h	/^      int totalSides;$/;"	m	class:parma::Sides
trace	mth/mth_def.h	/^T trace(Tensor<T> const& a)$/;"	f	namespace:mth
trans	apf/apfGeometry.h	/^  Vector3 trans;$/;"	m	struct:apf::Frame
trans	phasta/phastaChef.h	/^    double trans[3];$/;"	m	struct:ph::rigidBodyMotion
transfer	ma/maAdapt.cc	/^void Cavity::transfer(EntityArray& oldElements)$/;"	f	class:ma::Cavity
transfer	ma/maFaceSplit.cc	/^void FaceSplit::transfer()$/;"	f	class:ma::FaceSplit
transfer	ma/maSolutionTransfer.cc	/^    void transfer($/;"	f	class:ma::CavityTransfer
transfer	ma/maSplits.cc	/^void Splits::transfer()$/;"	f	class:ma::Splits
transfer	stk/apfSTK.cc	/^    void transfer($/;"	f	class:apf::StkBridge
transferElements	ma/maRefine.cc	/^void transferElements(Refine* r)$/;"	f	namespace:ma
transferField	stk/apfSTK.cc	/^void transferField($/;"	f	namespace:apf
transferFields	stk/apfSTK.cc	/^void transferFields($/;"	f	namespace:apf
transferParametric	phasta/phInput.h	/^    int transferParametric;$/;"	m	class:ph::Input
transferParametricBetween	crv/crvSnap.cc	/^static void transferParametricBetween($/;"	f	namespace:crv
transferParametricBetween	ma/maSnap.cc	/^static void transferParametricBetween($/;"	f	namespace:ma
transferParametricBetween	ma/maSnap_mohara.cc	/^static void transferParametricBetween($/;"	f	namespace:ma
transferParametricOnEdgeSplit	crv/crvSnap.cc	/^void transferParametricOnEdgeSplit($/;"	f	namespace:crv
transferParametricOnEdgeSplit	ma/maSnap.cc	/^void transferParametricOnEdgeSplit($/;"	f	namespace:ma
transferParametricOnEdgeSplit	ma/maSnap_mohara.cc	/^void transferParametricOnEdgeSplit($/;"	f	namespace:ma
transferParametricOnGeometricEdgeSplit	crv/crvSnap.cc	/^void transferParametricOnGeometricEdgeSplit($/;"	f	namespace:crv
transferParametricOnGeometricTriSplit	crv/crvSnap.cc	/^void transferParametricOnGeometricTriSplit($/;"	f	namespace:crv
transferParametricOnQuadSplit	ma/maSnap.cc	/^void transferParametricOnQuadSplit($/;"	f	namespace:ma
transferParametricOnQuadSplit	ma/maSnap_mohara.cc	/^void transferParametricOnQuadSplit($/;"	f	namespace:ma
transferParametricOnTriSplit	crv/crvSnap.cc	/^void transferParametricOnTriSplit($/;"	f	namespace:crv
transferParametricOnTriSplit	ma/maSnap.cc	/^void transferParametricOnTriSplit($/;"	f	namespace:ma
transferParametricOnTriSplit	ma/maSnap_mohara.cc	/^void transferParametricOnTriSplit($/;"	f	namespace:ma
transferToClosestPointOnEdgeSplit	ma/maSnap.cc	/^void transferToClosestPointOnEdgeSplit($/;"	f	namespace:ma
transferToClosestPointOnEdgeSplit	ma/maSnap_mohara.cc	/^void transferToClosestPointOnEdgeSplit($/;"	f	namespace:ma
transferToClosestPointOnQuadSplit	ma/maSnap.cc	/^void transferToClosestPointOnQuadSplit($/;"	f	namespace:ma
transferToClosestPointOnQuadSplit	ma/maSnap_mohara.cc	/^void transferToClosestPointOnQuadSplit($/;"	f	namespace:ma
transferToClosestPointOnTriSplit	ma/maSnap.cc	/^void transferToClosestPointOnTriSplit($/;"	f	namespace:ma
transferToClosestPointOnTriSplit	ma/maSnap_mohara.cc	/^void transferToClosestPointOnTriSplit($/;"	f	namespace:ma
transferToNode	ma/maSolutionTransfer.cc	/^    void transferToNode($/;"	f	class:ma::CavityTransfer
transferToNodeIn	ma/maSolutionTransfer.cc	/^    void transferToNodeIn($/;"	f	class:ma::CavityTransfer
transfers	ma/maSolutionTransfer.h	/^    Transfers transfers;$/;"	m	class:ma::SolutionTransfers
transformationMatrix	crv/crvQuality.cc	/^  mth::Matrix<double> transformationMatrix;$/;"	m	class:crv::Quality3D	file:
translateModel	test/simTranslate.cc	/^void translateModel(std::string mdlName, pGModel* simmodel, pProgress& progress)$/;"	f
transpose	apf/apfDynamicMatrix.h	/^inline void transpose(DynamicMatrix const& a,$/;"	f	namespace:apf
transpose	apf/apfMatrix.h	/^Matrix<N,M> transpose(Matrix<M,N> const& m)$/;"	f	namespace:apf
transpose	mth/mth_def.h	/^void transpose(Matrix<T,M,N> const& a,$/;"	f	namespace:mth
transpose	mth/mth_def.h	/^void transpose(Tensor<T> const& a, Tensor<T>& r)$/;"	f	namespace:mth
tree	pcu/pcu_order.c	/^  pcu_aa_tree tree;$/;"	m	struct:pcu_order_struct	file:
tri	crv/crvShapeFixer.h	/^    apf::MeshEntity* tri;$/;"	m	class:crv::CrvLargeAngleTriFixer
tri	ma/maShape.cc	/^    Entity* tri;$/;"	m	class:ma::LargeAngleTriFixer	file:
tri	test/shapefun2.cc	/^static apf::Vector3 const tri[3] = {$/;"	m	class:test::apf	file:
triQuality	test/capStoneIsoAdaptB737.cc	/^static double triQuality(apf::Mesh2* m, apf::MeshEntity* tri)$/;"	f	file:
tri_code_match	ma/maTables.cc	/^CodeMatch const tri_code_match[(1<<3)] =$/;"	m	namespace:ma	file:
tri_edge_code_count	ma/maTables.h	/^  tri_edge_code_count = 4,$/;"	e	enum:ma::__anon27
tri_edge_codes	ma/maTables.cc	/^int const tri_edge_codes[tri_edge_code_count] =$/;"	m	namespace:ma	file:
tri_edge_verts	apf/apfMesh.cc	/^int const tri_edge_verts[3][2] =$/;"	m	namespace:apf	file:
tri_edge_xi	crv/crvTables.cc	/^static apf::Vector3 const tri_edge_xi[3] = {$/;"	m	class:crv::apf	file:
tri_templates	ma/maTemplates.cc	/^SplitFunction tri_templates[tri_edge_code_count] =$/;"	m	namespace:ma	file:
tri_vert_xi	apf/apfBoundaryToElementXi.cc	/^static Vector3 const tri_vert_xi[3] = {$/;"	m	namespace:apf	file:
tri_vert_xi	crv/crvTables.cc	/^static apf::Vector3 const tri_vert_xi[3] = {$/;"	m	class:crv::apf	file:
triangleChecked	ma/maEdgeSwap.cc	/^    apf::DynamicArray<int> triangleChecked;$/;"	m	class:ma::SwapCavity	file:
triangleOk	ma/maEdgeSwap.cc	/^    apf::DynamicArray<int> triangleOk;$/;"	m	class:ma::SwapCavity	file:
triangle_area	ma/maReposition.cc	/^static AD triangle_area(ADVec v[3])$/;"	f	namespace:ma
triangles	ma/maEdgeSwap.cc	/^static int (*triangles[MAX_VERTS+1])[3] =$/;"	m	namespace:ma	file:
triangles_3	ma/maEdgeSwap.cc	/^static int triangles_3[1][3] = {{0,1,2}};$/;"	m	namespace:ma	file:
triangles_4	ma/maEdgeSwap.cc	/^static int triangles_4[4][3] =$/;"	m	namespace:ma	file:
triangles_5	ma/maEdgeSwap.cc	/^static int triangles_5[10][3] =$/;"	m	namespace:ma	file:
triangles_6	ma/maEdgeSwap.cc	/^static int triangles_6[20][3] =$/;"	m	namespace:ma	file:
triangles_7	ma/maEdgeSwap.cc	/^static int triangles_7[35][3] =$/;"	m	namespace:ma	file:
triangulation	ma/maEdgeSwap.cc	/^    apf::DynamicArray<int> triangulation;$/;"	m	class:ma::SwapCavity	file:
triangulation_count	ma/maEdgeSwap.cc	/^static int triangulation_count[MAX_VERTS+1] =$/;"	m	namespace:ma	file:
triangulation_size	ma/maEdgeSwap.cc	/^static int triangulation_size[MAX_VERTS+1] =$/;"	m	namespace:ma	file:
triangulations_3	ma/maEdgeSwap.cc	/^static int triangulations_3[1][1] = {{0}};$/;"	m	namespace:ma	file:
triangulations_4	ma/maEdgeSwap.cc	/^static int triangulations_4[2][2] =$/;"	m	namespace:ma	file:
triangulations_5	ma/maEdgeSwap.cc	/^static int triangulations_5[5][3] =$/;"	m	namespace:ma	file:
triangulations_6	ma/maEdgeSwap.cc	/^static int triangulations_6[14][4] =$/;"	m	namespace:ma	file:
triangulations_7	ma/maEdgeSwap.cc	/^static int triangulations_7[42][5] =$/;"	m	namespace:ma	file:
trim	parma/diffMC/parma_edgeEqVtxSelector.cc	/^      parma::Mid* trim(parma::Targets*, apf::Migration* plan) {$/;"	f	class:__anon52::EdgeEqVtx
trim	parma/diffMC/parma_elmLtVtxEdgeSelector.cc	/^      Midd* trim(parma::Targets*, apf::Migration* plan) {$/;"	f	class:__anon64::ElmLtVtxEdgeSelector
trim	parma/diffMC/parma_ltSelector.cc	/^      parma::Mid* trim(parma::Targets*, apf::Migration* plan) {$/;"	f	class:__anon58::LtSelector
trimColoring	apf/apfMIS.cc	/^  void trimColoring(Mesh* m,MeshTag* coloring, MeshTag* degrees,$/;"	f	namespace:apf
trinomial	crv/crvMath.cc	/^int trinomial(int n, int i, int j)$/;"	f	namespace:crv
triw	test/ugridptnstats.cc	/^const double triw = 1.0;$/;"	v
tryAttachingAngleBCs	phasta/phAxisymmetry.cc	/^static void tryAttachingAngleBCs(BCs& bcs, gmi_model* gm, gmi_ent* f, gmi_ent* of)$/;"	f	namespace:ph
tryBothCollapses	ma/maDoubleSplitCollapse.cc	/^bool DoubleSplitCollapse::tryBothCollapses(Entity* e)$/;"	f	class:ma::DoubleSplitCollapse
tryBothCollapses	ma/maFaceSplitCollapse.cc	/^  bool FaceSplitCollapse::tryBothCollapses(Entity* e)$/;"	f	class:ma::FaceSplitCollapse
tryBothDirections	ma/maCollapse.cc	/^bool Collapse::tryBothDirections(double qualityToBeat)$/;"	f	class:ma::Collapse
tryBothDirections	ma/maMatchedCollapse.cc	/^bool MatchedCollapse::tryBothDirections(double qualityToBeat)$/;"	f	class:ma::MatchedCollapse
tryDigging	ma/maSnapper.cc	/^static bool tryDigging(Adapt* a, Collapse& c, Entity* v,$/;"	f	namespace:ma
tryDigging2	ma/maSnapper.cc	/^static bool tryDigging2(Adapt* a, Collapse& c, apf::Up& badElements,$/;"	f	namespace:ma
tryDiggingEdge	ma/maSnapper.cc	/^static bool tryDiggingEdge(Adapt* adapter, Collapse& collapse, Entity* e)$/;"	f	namespace:ma
tryMoving	ma/maSnapper.cc	/^static bool tryMoving(Adapt* adapter, Entity* v, Tag* tag)$/;"	f	namespace:ma
tryReading	phasta/phInput.cc	/^static bool tryReading(std::string const& name,$/;"	f	namespace:ph
trySending	parma/diffMC/parma_centroidSelector.cc	/^      void trySending(Targets* tgts, DistanceQueue* distQ, $/;"	f	class:parma::CentroidSelector	file:
trySimpleSnap	ma/maSnapper.cc	/^bool Snapper::trySimpleSnap()$/;"	f	class:ma::Snapper
trySnapping	ma/maSnapper.cc	/^static bool trySnapping(Adapt* adapter, Tag* tag, Entity* vert,$/;"	f	namespace:ma
trySnaps	ma/maMatchedSnapper.cc	/^bool MatchedSnapper::trySnaps()$/;"	f	class:ma::MatchedSnapper
tryThisDirection	ma/maCollapse.cc	/^bool Collapse::tryThisDirection(double qualityToBeat)$/;"	f	class:ma::Collapse
tryThisDirection	ma/maMatchedCollapse.cc	/^bool MatchedCollapse::tryThisDirection(double qualityToBeat)$/;"	f	class:ma::MatchedCollapse
tryThisDirectionNoCancel	ma/maCollapse.cc	/^bool Collapse::tryThisDirectionNoCancel(double qualityToBeat)$/;"	f	class:ma::Collapse
tryToCollapse	ma/maVertRemover.cc	/^bool VertRemover::tryToCollapse(Entity* e)$/;"	f	class:ma::VertRemover
tryToDisplace	dsp/dsp.cc	/^bool tryToDisplace(apf::Mesh2* m, apf::Field* df)$/;"	f	namespace:dsp
tryToGetIntegration	apf/apfIPShape.cc	/^static Integration const* tryToGetIntegration(int type, int order)$/;"	f	namespace:apf
tryToPull	apf/apfCavityOp.cc	/^bool CavityOp::tryToPull()$/;"	f	class:apf::CavityOp
tryToRemoveVert	ma/maShortEdgeRemover.cc	/^bool ShortEdgeRemover::tryToRemoveVert(int vi)$/;"	f	class:ma::ShortEdgeRemover
tryTriangulation	ma/maEdgeSwap.cc	/^    bool tryTriangulation(int i)$/;"	f	class:ma::SwapCavity
twox	test/verify_convert.cc	/^  twox(apf::Field* x) : x(x) {}$/;"	f	class:twox
twox	test/verify_convert.cc	/^class twox : public apf::Function {$/;"	c	file:
type	apf/apfGradientByVolume.cc	/^    typedef Matrix3x3 type;$/;"	t	class:apf::GradientOf	file:
type	apf/apfGradientByVolume.cc	/^    typedef Vector3 type;$/;"	t	class:apf::GradientOf	file:
type	gmi/agm.h	/^  enum agm_bdry_type type;$/;"	m	struct:agm_bdry	typeref:enum:agm_bdry::agm_bdry_type
type	gmi/agm.h	/^  enum agm_ent_type type;$/;"	m	struct:agm_ent	typeref:enum:agm_ent::agm_ent_type
type	gmi/agm.h	/^  enum agm_use_type type;$/;"	m	struct:agm_use	typeref:enum:agm_use::agm_use_type
typeDimension	apf/apfMesh.cc	/^int const Mesh::typeDimension[TYPES] = $/;"	m	class:apf::Mesh	file:
typeDimension	apf/apfMesh.h	/^    static int const typeDimension[TYPES];$/;"	m	class:apf::Mesh
typeName	apf/apfMesh.cc	/^char const* const Mesh::typeName[TYPES] =$/;"	m	class:apf::Mesh	file:
typeName	apf/apfMesh.h	/^    static char const* const typeName[TYPES];$/;"	m	class:apf::Mesh
typeName	test/capStoneGeomTest.cc	/^char const* const typeName[4] =$/;"	v
typePostfix	apf/apfTagData.cc	/^static const char* typePostfix[Mesh::TYPES] =$/;"	m	namespace:apf	file:
typeSizes	pumi/GenTag.cc	/^size_t const TagHandle::typeSizes[PUMI_TAGTYPES] = $/;"	m	class:TagHandle	file:
typeSizes	pumi/GenTag.h	/^    static size_t const typeSizes[PUMI_TAGTYPES];$/;"	m	class:TagHandle
u	test/poisson.cc	/^    mth::Vector<double> u;$/;"	m	class:__anon17::Poisson	file:
ugridToMdsElmIdx	mds/mdsUgrid.cc	/^  inline unsigned ugridToMdsElmIdx(int apfType, int ugridIdx) {$/;"	f	namespace:__anon101
uint	parma/diffMC/parma_shapeSelector.cc	/^typedef unsigned uint;$/;"	t	file:
uint	parma/diffMC/parma_vtxSelector.cc	/^typedef unsigned int uint;$/;"	t	file:
unMarkBadQuality	ma/maShape.cc	/^void unMarkBadQuality(Adapt* a)$/;"	f	namespace:ma
unfreeze	apf/apf.cc	/^void unfreeze(Field* f)$/;"	f	namespace:apf
unfreezeFieldData	apf/apfArrayData.cc	/^void unfreezeFieldData(FieldBase* field) {$/;"	f	namespace:apf
unfreezeFields	apf/apfMesh.cc	/^void unfreezeFields(Mesh* m) {$/;"	f	namespace:apf
unfreezeLayer	ma/maLayer.cc	/^void unfreezeLayer(Adapt* a)$/;"	f	namespace:ma
uniformRefinement	phasta/phAdapt.cc	/^  void uniformRefinement(ph::Input& in, apf::Mesh2* m)$/;"	f	namespace:chef
uninit	pcu/pcu.c	/^enum state { uninit, init };$/;"	e	enum:state	file:
unique_triangle_count	ma/maEdgeSwap.cc	/^static int unique_triangle_count[MAX_VERTS+1] =$/;"	m	namespace:ma	file:
unit	mds/apfBox.cc	/^Indices Indices::unit(int d)$/;"	f	class:apf::Indices
unite	apf/apfMesh.cc	/^void unite(Parts& into, Parts const& from)$/;"	f	namespace:apf
unite	mds/mds.c	/^static void unite(struct mds_set* s, struct mds_set* with)$/;"	f	file:
unlink	pumi/pumi_list.h	/^    void unlink()$/;"	f	class:ListMember
unmark	ma/maCollapse.cc	/^void Collapse::unmark()$/;"	f	class:ma::Collapse
unmark	ma/maLayerCollapse.cc	/^void LayerCollapse::unmark()$/;"	f	class:ma::LayerCollapse
unmark	ma/maMatchedCollapse.cc	/^void MatchedCollapse::unmark()$/;"	f	class:ma::MatchedCollapse
unmark	ma/maRegionCollapse.cc	/^void RegionCollapse::unmark()$/;"	f	class:ma::RegionCollapse
unpackAdjPart	parma/diffMC/maximalIndependentSet/misLuby.cc	/^  void unpackAdjPart(vector<adjPart>& msg) {$/;"	f	namespace:__anon50
unpackCommon	apf/apfMigrate.cc	/^void unpackCommon($/;"	f	namespace:apf
unpackCopies	apf/apfMigrate.cc	/^static void unpackCopies($/;"	f	namespace:apf
unpackCopies	apf/apfVerify.cc	/^static void unpackCopies($/;"	f	namespace:apf
unpackDataClone	apf/apfMesh2.cc	/^void unpackDataClone(Mesh2* m)$/;"	f	namespace:apf
unpackDownward	apf/apfMigrate.cc	/^static void unpackDownward($/;"	f	namespace:apf
unpackEntity	apf/apfMigrate.cc	/^static MeshEntity* unpackEntity($/;"	f	namespace:apf
unpackFieldClone	apf/apfMesh2.cc	/^static Field* unpackFieldClone(Mesh2* m)$/;"	f	namespace:apf
unpackFieldClones	apf/apfMesh2.cc	/^static void unpackFieldClones(Mesh2* m)$/;"	f	namespace:apf
unpackFieldInfo	apf/apfVerify.cc	/^void unpackFieldInfo(std::string& name, int& type, int& size)$/;"	f	namespace:apf
unpackGhost	pumi/pumi_ghost.cc	/^static pMeshEnt unpackGhost(Ghosting* plan, apf::DynamicArray<pMeshTag>& tags)$/;"	f	file:
unpackInts	parma/diffMC/maximalIndependentSet/misLuby.cc	/^  void unpackInts(vector<int>& msg, int tag) {$/;"	f	namespace:__anon50
unpackMeshShape	apf/apfMesh2.cc	/^static void unpackMeshShape(Mesh2* m)$/;"	f	namespace:apf
unpackNet	parma/diffMC/maximalIndependentSet/misLuby.cc	/^  void unpackNet(vector<adjPart>& msg) {$/;"	f	namespace:__anon50
unpackNonVertex	apf/apfMigrate.cc	/^MeshEntity* unpackNonVertex($/;"	f	namespace:apf
unpackOtherGid	zoltan/apfInterElement.cc	/^static void unpackOtherGid(Mesh* m, MeshTag* t)$/;"	f	namespace:apf
unpackParts	apf/apfMigrate.cc	/^void unpackParts(Parts& parts)$/;"	f	namespace:apf
unpackProposal	apf/apfMesh2.cc	/^static void unpackProposal(int& t, MeshEntity*& e, Downward& da)$/;"	f	namespace:apf
unpackRemotes	apf/apfMigrate.cc	/^void unpackRemotes(Mesh2* m, MeshEntity* e)$/;"	f	namespace:apf
unpackSplits	ma/maMatch.cc	/^static void unpackSplits(EntityArray& splits)$/;"	f	namespace:ma
unpackString	apf/apfMesh.cc	/^std::string unpackString()$/;"	f	namespace:apf
unpackTagClone	apf/apfMesh2.cc	/^static MeshTag* unpackTagClone(Mesh2* m)$/;"	f	namespace:apf
unpackTagClones	apf/apfMesh2.cc	/^static void unpackTagClones(Mesh2* m)$/;"	f	namespace:apf
unpackTagInfo	apf/apfMesh.cc	/^void unpackTagInfo(std::string& name, int& type, int& size)$/;"	f	namespace:apf
unpackTags	apf/apfMigrate.cc	/^void unpackTags($/;"	f	namespace:apf
unpackVertex	apf/apfMigrate.cc	/^MeshEntity* unpackVertex($/;"	f	namespace:apf
unrelate_back_up	mds/mds.c	/^static void unrelate_back_up(struct mds* m, mds_id* from, mds_id to)$/;"	f	file:
unrelate_ent	mds/mds.c	/^static void unrelate_ent(struct mds* m, mds_id e)$/;"	f	file:
unrelate_up	mds/mds.c	/^static void unrelate_up(struct mds* m, mds_id e, mds_id node)$/;"	f	file:
unrotateTetXi	ma/maMesh.cc	/^void unrotateTetXi(Vector& xi, int rotation)$/;"	f	namespace:ma
unrotate_prism_diagonal_code	ma/maQuality.cc	/^static int unrotate_prism_diagonal_code(int code, int rot)$/;"	f	namespace:ma
unsnap	ma/maLayerSnap.cc	/^  void unsnap(Entity* v)$/;"	f	struct:ma::Unsnapper
unsnapMarkedCurves	ma/maLayerSnap.cc	/^static long unsnapMarkedCurves(Adapt* a, Tag* snapTag)$/;"	f	namespace:ma
up	mds/mds.h	/^  mds_id* up[4][MDS_TYPES];$/;"	m	struct:mds
updateCache	ma/maSize.cc	/^  void updateCache(Entity* v)$/;"	f	struct:ma::BothEval
updateCache	ma/maSize.cc	/^  void updateCache(Entity* v)$/;"	f	struct:ma::LogMEval
updateDistance	parma/diffMC/parma_graphDist.cc	/^  apf::MeshTag* updateDistance(apf::Mesh* m) {$/;"	f	namespace:__anon74
updateMatching	apf/apfMigrate.cc	/^void updateMatching($/;"	f	namespace:apf
updateNeighbors	parma/diffMC/maximalIndependentSet/misLuby.cc	/^void partInfo::updateNeighbors(){$/;"	f	class:partInfo
updateOwners	mds/apfPM.cc	/^void updateOwners(apf::Mesh* m, PM& ps)$/;"	f	namespace:apf
updateResidences	apf/apfMigrate.cc	/^static void updateResidences($/;"	f	namespace:apf
updateSenderMatching	apf/apfMigrate.cc	/^static void updateSenderMatching($/;"	f	namespace:apf
updateUserField	apf/apf.cc	/^void updateUserField(Field* field, Function* newFunc)$/;"	f	namespace:apf
updateVertexParametricCoords	ma/maSnapper.cc	/^static void updateVertexParametricCoords($/;"	f	namespace:ma
upper	test/aniso_ma_test.cc	/^    ma::Vector upper;$/;"	m	class:AnIso	file:
upper	test/capStoneSizeFields.h	/^    ma::Vector upper;$/;"	m	class:GeomB737
upper	test/capStoneSizeFields.h	/^    ma::Vector upper;$/;"	m	class:GeomRobin
upper	test/capStoneSizeFields.h	/^    ma::Vector upper;$/;"	m	class:Linear3
upper	test/curvetest.cc	/^    ma::Vector upper;$/;"	m	class:Linear	file:
upper	test/dg_ma_test.cc	/^    ma::Vector upper;$/;"	m	class:Linear	file:
upper	test/ma_test.cc	/^    ma::Vector upper;$/;"	m	class:Linear	file:
useAttachedFields	phasta/phInput.h	/^    int useAttachedFields;$/;"	m	class:ph::Input
useBlending	crv/crvBezier.cc	/^static bool useBlending(int type)$/;"	f	namespace:crv
use_bdry_types	gmi/agm.c	/^static enum agm_bdry_type const use_bdry_types[AGM_USE_TYPES] = {$/;"	v	file:
use_ent_types	gmi/agm.c	/^static enum agm_ent_type const use_ent_types[AGM_USE_TYPES] = {$/;"	v	file:
used	gmi/agm.c	/^  int* used[AGM_USE_TYPES];$/;"	m	struct:uses	file:
user	gmi/agm.c	/^  int* user[AGM_USE_TYPES];$/;"	m	struct:uses	file:
userDefinedLayerTagName	ma/maInput.h	/^    const char* userDefinedLayerTagName;$/;"	m	class:ma::Input
user_model	mds/mds_apf.h	/^  struct gmi_model* user_model;$/;"	m	struct:mds_apf	typeref:struct:mds_apf::gmi_model
user_type	mds/mds_tag.h	/^  int user_type;$/;"	m	struct:mds_tag
uses	gmi/agm.c	/^  struct uses uses;$/;"	m	struct:agm	typeref:struct:agm::uses	file:
uses	gmi/agm.c	/^struct uses {$/;"	s	file:
v	gmi_sim/gmi_sim.cc	/^    GVIter v;$/;"	m	union:sim_iter::__anon103	file:
v	ma/maCrawler.cc	/^  Entity* v;$/;"	m	struct:ma::TopFlagger	file:
v	ma/maMatchedCollapse.h	/^  std::vector<Rebuild> v;$/;"	m	struct:ma::Rebuilds
v	mds/apfBox.h	/^  std::vector<MeshEntity*> v;$/;"	m	struct:apf::BoxBuilder
v	spr/sprEstimateError.cc	/^    apf::DynamicVector v;$/;"	m	class:spr::SelfProduct	file:
v	test/capStoneAttachSolution.cc	/^  apf::Vector3 v;$/;"	m	struct:SortingStruct	file:
v1	spr/sprEstimateError.cc	/^    apf::DynamicVector v1, v2;$/;"	m	class:spr::ElementError	file:
v1	spr/sprEstimateTargetError.cc	/^    apf::DynamicVector v1,v2;$/;"	m	class:spr::target::ElementError	file:
v2	spr/sprEstimateError.cc	/^    apf::DynamicVector v1, v2;$/;"	m	class:spr::ElementError	file:
v2	spr/sprEstimateTargetError.cc	/^    apf::DynamicVector v1,v2;$/;"	m	class:spr::target::ElementError	file:
val	mth/mthAD.h	/^    const double& val() const {return x_;}$/;"	f	class:mth::AD
val	mth/mthAD.h	/^    double& val() {return x_;}$/;"	f	class:mth::AD
validQuality	ma/maInput.h	/^    double validQuality;$/;"	m	class:ma::Input
validQuality	phasta/phInput.h	/^    double validQuality;$/;"	m	class:ph::Input
valid_check	pumi/GenIterator.h	/^     inline void valid_check ()$/;"	f	class:GenIterator
validate	phasta/phInput.cc	/^static void validate(Input& in)$/;"	f	namespace:ph
validateInput	ma/maInput.cc	/^void validateInput(Input* in)$/;"	f	namespace:ma
validityTag	crv/crvAdapt.h	/^    ma::Tag* validityTag;$/;"	m	class:crv::Adapt
value	ma/maSolutionTransfer.cc	/^    apf::NewArray<double> value;$/;"	m	class:ma::FieldTransfer	file:
value	parma/diffMC/zeroOneKnapsack.c	/^    size_t *value;$/;"	m	struct:zeroOneKnapsack	file:
value	pcu/pcu_byteorder.h	/^  uint32_t value;$/;"	m	union:__anon42
value	phasta/phBC.h	/^  double* value;$/;"	m	struct:ph::ConstantBC
values	apf/apfDynamicMatrix.h	/^    DynamicArray<double> values;$/;"	m	class:apf::DynamicMatrix
values	spr/sprRecoverField.cc	/^  apf::NewArray<apf::NewArray<double> > values;$/;"	m	struct:spr::Samples	file:
vb	parma/diffMC/parma_components.h	/^      unsigned vb;$/;"	m	class:parma::dcComponents::Components
vb	parma/diffMC/parma_dcpartFixer.cc	/^    unsigned vb;$/;"	m	class:dcPartFixer::PartFixer	file:
vec	test/runSimxAnisoAdapt.cc	/^typedef vector<double> vec;$/;"	t	file:
vector_to_set	gmi_cap/gmi_cap.cc	/^static gmi_set* vector_to_set(std::vector<M_GTopo> gtopos)$/;"	f	file:
vectors_from_osh	omega_h/apfOmega_h.cc	/^static void vectors_from_osh($/;"	f	namespace:apf
vectors_to_osh	omega_h/apfOmega_h.cc	/^static void vectors_to_osh($/;"	f	namespace:apf
verbose	parma/diffMC/parma_balancer.h	/^      int verbose;$/;"	m	class:parma::Balancer
verbose	parma/diffMC/parma_dcpart.h	/^      unsigned verbose;$/;"	m	class:dcPart
verbose	parma/diffMC/parma_shapeOptimizer.cc	/^      int verbose;$/;"	m	class:__anon47::ImbOrMaxNeighbor	file:
verbose	parma/diffMC/parma_step.h	/^      int verbose;$/;"	m	class:parma::Stepper
verbose	parma/diffMC/parma_stop.h	/^      int verbose;$/;"	m	class:parma::BalOrStall
verify	apf/apfVerify.cc	/^void verify(Mesh* m, bool abort_on_error)$/;"	f	namespace:apf
verify	apf_cap/apfCAP.cc	/^void MeshCAP::verify()$/;"	f	class:apf::MeshCAP
verify	apf_sim/apfSIM.cc	/^void MeshSIM::verify()$/;"	f	class:apf::MeshSIM
verify	mds/apfMDS.cc	/^    void verify()$/;"	f	class:apf::MeshMDS
verifyAlignment	apf/apfVerify.cc	/^static void verifyAlignment(Mesh* m)$/;"	f	namespace:apf
verifyAllCopies	apf/apfVerify.cc	/^static void verifyAllCopies(Copies& a)$/;"	f	namespace:apf
verifyArgs	test/box.cc	/^void verifyArgs(int argc, char** argv)$/;"	f	namespace:__anon8
verifyCoords	apf/apfVerify.cc	/^static long verifyCoords(Mesh* m)$/;"	f	namespace:apf
verifyDown	apf/apfVerify.cc	/^static void verifyDown(Mesh* m, MeshEntity* e, int gd, int ed)$/;"	f	namespace:apf
verifyEntity	apf/apfVerify.cc	/^static void verifyEntity(Mesh* m, UpwardCounts& guc, MeshEntity* e, bool abort_on_error)$/;"	f	namespace:apf
verifyFields	apf/apfVerify.cc	/^static void verifyFields(Mesh* m) $/;"	f	namespace:apf
verifyGhostCopies	apf/apfVerify.cc	/^static void verifyGhostCopies(Mesh* m)$/;"	f	namespace:apf
verifyMatches	apf/apfVerify.cc	/^static void verifyMatches(Mesh* m)$/;"	f	namespace:apf
verifyRemoteCopies	apf/apfVerify.cc	/^static void verifyRemoteCopies(Mesh* m)$/;"	f	namespace:apf
verifyResidence	apf/apfVerify.cc	/^static void verifyResidence(Mesh* m, MeshEntity* e)$/;"	f	namespace:apf
verifyTags	apf/apfVerify.cc	/^static void verifyTags(Mesh* m)$/;"	f	namespace:apf
verifyUp	apf/apfVerify.cc	/^static void verifyUp(Mesh* m, UpwardCounts& guc,$/;"	f	namespace:apf
verifyVolumes	apf/apfVerify.cc	/^long verifyVolumes(Mesh* m, bool printVolumes)$/;"	f	namespace:apf
verify_fields	apf/apfMixedNumbering.cc	/^static void verify_fields(std::vector<Field*> const& f) {$/;"	f	namespace:apf
vert	apf/apfGradientByVolume.cc	/^    MeshEntity* vert;$/;"	m	class:apf::RecoverGradient	file:
vert	ma/maMatchedSnapper.h	/^    Entity* vert;$/;"	m	class:ma::MatchedSnapper
vert	ma/maSnap.cc	/^    Entity* vert;$/;"	m	class:ma::SnapAll	file:
vert	ma/maSnap.cc	/^    Entity* vert;$/;"	m	class:ma::SnapMatched	file:
vert	ma/maSnap_mohara.cc	/^    Entity* vert;$/;"	m	class:ma::SnapAll	file:
vert	ma/maSnap_mohara.cc	/^    Entity* vert;$/;"	m	class:ma::SnapMatched	file:
vert	ma/maSnapper.h	/^    Entity* vert;$/;"	m	class:ma::FirstProblemPlane
vert	ma/maSnapper.h	/^    Entity* vert;$/;"	m	class:ma::Snapper
vert	ma/maVertRemover.h	/^    Entity* vert;$/;"	m	class:ma::VertRemover
vert	test/nektar_align.cc	/^  apf::MeshEntity* vert;$/;"	m	struct:VertId	file:
vert0	test/bezierElevation.cc	/^void vert0(double const p[2], double x[3], void*)$/;"	f
vert0	test/bezierMesh.cc	/^void vert0(double const p[2], double x[3], void*)$/;"	f
vert0	test/bezierRefine.cc	/^void vert0(double const p[2], double x[3], void*)$/;"	f
vert0	test/bezierSubdivision.cc	/^void vert0(double const p[2], double x[3], void*)$/;"	f
vert0	test/bezierValidity.cc	/^void vert0(double const p[2], double x[3], void*)$/;"	f
vertEdges	crv/crvTables.h	/^static int const vertEdges[4][3] = {{3,0,2},{0,4,1},{1,5,2},{3,5,4}};$/;"	m	namespace:crv
vertFunction	test/bezierElevation.cc	/^void vertFunction(double const p[2], double x[3], void*)$/;"	f
vertFunction	test/bezierSubdivision.cc	/^void vertFunction(double const p[2], double x[3], void*)$/;"	f
vertRemovers	ma/maShortEdgeRemover.h	/^    VertRemover vertRemovers[2];$/;"	m	class:ma::ShortEdgeRemover
vertToCollapse	ma/maCollapse.h	/^    Entity* vertToCollapse;$/;"	m	class:ma::Collapse
vertToKeep	ma/maCollapse.h	/^    Entity* vertToKeep;$/;"	m	class:ma::Collapse
vert_face	ma/sliverCodeMatch.cc	/^  vert_face=1$/;"	e	enum:__anon30	file:
vertex	ma/maCoarsen.cc	/^    Entity* vertex;$/;"	m	class:ma::IndependentSetFinder	file:
vertexFunction	test/fusion3.cc	/^void vertexFunction(double const p[2], double x[3], void * data)$/;"	f
vertexImbalance	phasta/phInput.h	/^    double vertexImbalance;$/;"	m	class:ph::Input
verts	ma/maEdgeSwap.cc	/^    Entity* verts[7];$/;"	m	class:ma::SwapLoop	file:
verts	ma/maShape.cc	/^    Entity* verts[4];$/;"	m	class:ma::FaceVertFixer	file:
verts	ma/maSolutionTransfer.cc	/^    LinearTransfer verts;$/;"	m	class:ma::HighOrderTransfer	file:
verts_from_osh	omega_h/apfOmega_h.cc	/^verts_from_osh(apf::Mesh2* am, osh::Mesh* om) {$/;"	f	namespace:apf
visit	mds/mds_order.c	/^static int visit($/;"	f	file:
visited	mds/apfMDS.cc	/^bool visited(Queue& q, apf::Numbering* nn, MeshEntity* e)$/;"	f	namespace:apf
visualizeEdge	test/capStoneGeomTest.cc	/^void visualizeEdge(gmi_model* model, gmi_ent* entity, int n, const char* fileName)$/;"	f
visualizeEdges	test/capStoneGeomTest.cc	/^void visualizeEdges(gmi_model* model, int n, const char* fileName)$/;"	f
visualizeFace	test/capStoneGeomTest.cc	/^void visualizeFace(gmi_model* model, gmi_ent* entity, int n, int m, const char* fileName)$/;"	f
visualizeGeometricInfo	ma/maSnap.cc	/^void visualizeGeometricInfo(Mesh* m, const char* name)$/;"	f	namespace:ma
visualizeGeometricInfo	ma/maSnap_mohara.cc	/^void visualizeGeometricInfo(Mesh* m, const char* name)$/;"	f	namespace:ma
visualizeSizeField	test/visualizeAnisoSizes.cc	/^void visualizeSizeField($/;"	f
viter	apf_sim/apfSIM.h	/^    VIter viter;$/;"	m	class:apf::MeshSIM
volumeSum	apf/apfGradientByVolume.cc	/^    double volumeSum;$/;"	m	class:apf::GradientIntegrator	file:
vprint	lion/lionPrint.c	55;"	d	file:
vtag	parma/diffMC/parma_dcpart.h	/^      apf::MeshTag* vtag;$/;"	m	class:dcPart
vtxAvg	parma/extractParmaResults.py	/^vtxAvg = metric("vertexAvg")$/;"	v
vtxImb	parma/extractParmaResults.py	/^vtxImb = metric("vertexImbalance")$/;"	v
vtxImbAll	parma/extractParmaResults.py	/^vtxImbAll = []$/;"	v
vtxImbPtReduction	parma/extractParmaResults.py	/^vtxImbPtReduction = (vtxImbAll[0]-vtxImbAll[-1])*100$/;"	v
vtxMax	parma/extractParmaResults.py	/^vtxMax = metric("vertexMax")$/;"	v
vtxMin	parma/extractParmaResults.py	/^vtxMin = metric("vertexMin")$/;"	v
vtxTot	parma/extractParmaResults.py	/^vtxTot = metric("vertexTotal")$/;"	v
vtx_dim	apf/apfMIS.h	/^    const int vtx_dim;$/;"	m	class:apf::MIS
vtx_size	spr/sprEstimateTargetError.cc	/^  apf::Field* vtx_size;$/;"	m	struct:spr::target::Estimation	file:
vtxw	test/ugridptnstats.cc	/^const double vtxw = 1.0;$/;"	v
vw	parma/diffMC/parma_elmLtVtxEdgeSelector.cc	/^        double vw;$/;"	m	struct:__anon64::ElmLtVtxEdgeSelector::Migr	file:
w	mds/apfBox.h	/^  double w[3];$/;"	m	struct:apf::BoxBuilder
wTag	parma/diffMC/parma_centroidSelector.cc	/^      apf::MeshTag* wTag;$/;"	m	class:parma::CentroidSelector	file:
walkCavEdges	parma/diffMC/parma_dijkstra.cc	/^  void walkCavEdges(apf::Mesh* m, CavEnts* ce, apf::MeshEntity* p,$/;"	f	namespace:__anon70
walkComp	parma/diffMC/parma_components.cc	/^  void DCC::walkComp(apf::MeshEntity* src, unsigned comp) {$/;"	f	class:parma::DCC
walkInward	parma/diffMC/parma_components.cc	/^  void DCC::walkInward(unsigned compId) {$/;"	f	class:parma::DCC
walkPart	parma/diffMC/parma_dcpart.cc	/^unsigned dcPart::walkPart(unsigned visited) {$/;"	f	class:dcPart
warnAboutEmptyParts	apf/apfMesh.cc	/^void warnAboutEmptyParts(Mesh* m)$/;"	f	namespace:apf
warnAboutShrinking	phasta/phAdapt.cc	/^static void warnAboutShrinking(int factor) {$/;"	f	namespace:ph
weight	apf/apfIntegrate.h	/^  double weight;$/;"	m	struct:apf::IntegrationPoint
weight	parma/diffMC/parma_centroids.h	/^      double weight;$/;"	m	class:parma::Centroids
weight	parma/diffMC/parma_edgeEqVtxSelector.cc	/^      double weight(SetEnt& s) {$/;"	f	class:__anon52::EdgeEqVtx
weight	parma/diffMC/parma_elmLtVtxEdgeSelector.cc	/^      double weight(SetEnt& s) {$/;"	f	class:__anon64::ElmLtVtxEdgeSelector
weight	parma/diffMC/parma_entWeights.h	/^      double weight;$/;"	m	class:parma::EntWeights
weight	parma/diffMC/parma_ghostMPASWeights.cc	/^      double weight(int peer) {$/;"	f	class:parma::GhostElementFinder
weight	parma/diffMC/parma_ghostMPASWeights.cc	/^      double weight;$/;"	m	class:parma::GhostMPASWeights	file:
weight	parma/diffMC/parma_ghostWeights.cc	/^      double weight;$/;"	m	class:parma::GhostToEntWeight	file:
weight	parma/diffMC/parma_ghostWeights.cc	/^      double* weight(int peer) {$/;"	f	class:parma::ElmGhostFinder
weight	parma/diffMC/parma_ghostWeights.cc	/^      double* weight(int peer) {$/;"	f	class:parma::VtxGhostFinder
weight	parma/diffMC/parma_ghostWeights.cc	/^      double* weight;$/;"	m	class:parma::GhostWeights	file:
weight	parma/diffMC/parma_ltSelector.cc	/^      double weight(SetEnt& s) {$/;"	f	class:__anon58::LtSelector
weight	parma/diffMC/zeroOneKnapsack.c	/^    size_t *weight;$/;"	m	struct:zeroOneKnapsack	file:
weights	parma/diffMC/parma_step.h	/^      Weights* weights;$/;"	m	class:parma::Stepper
weights	test/ugridptnstats.cc	/^const double weights[8] = {vtxw, edgew, triw, quadw, tetw, hexw, przw, pyrw};$/;"	v
weights	zoltan/apfZoltanMesh.h	/^    MeshTag* weights;$/;"	m	class:apf::ZoltanMesh
whichStream	phasta/phstream.cc	/^void whichStream(const char* name, bool& isR, bool& isG) {$/;"	f
withinBox	apf/apfGeometry.cc	/^bool withinBox(Vector3 const& point, Vector3 const& center, Vector3 const& size)$/;"	f	namespace:apf
withinBox	apf/apfGeometry.cc	/^bool withinBox(Vector3 const& point, Vector3 const& center, Vector3 const& size,$/;"	f	namespace:apf
withinCyl	apf/apfGeometry.cc	/^bool withinCyl(Vector3 const& point, Vector3 const& center,$/;"	f	namespace:apf
wm	test/capStoneAttachSolution.cc	/^  double wm;$/;"	m	struct:SortingStruct	file:
word	mds/mdsGmsh.cc	/^  char* word;$/;"	m	struct:__anon96::Reader	file:
workaround	apf/apfVtk.cc	/^static float workaround(double v)$/;"	f	namespace:apf
workaround	apf/apfVtk.cc	/^static int workaround(int v)$/;"	f	namespace:apf
workaround	apf/apfVtk.cc	/^static long workaround(long v)$/;"	f	namespace:apf
wouldEmptyParts	ma/maLayerCoarsen.cc	/^static bool wouldEmptyParts(apf::Migration* plan)$/;"	f	namespace:ma
wouldInvert	ma/maEdgeSwap.cc	/^    bool wouldInvert()$/;"	f	class:ma::EdgeSwap2D
wrapSIMField	apf_sim/apfSIM.cc	/^apf::Field* apf::wrapSIMField(Mesh* m, ::Field* fd)$/;"	f	class:apf
wrapSIMField	apf_sim/apfSIM.cc	/^apf::Field* apf::wrapSIMField(Mesh* m, pField fd)$/;"	f	class:apf
wrapper	ma/maSize.cc	/^  IsoWrapper wrapper;$/;"	m	struct:ma::IsoSizeField	file:
write	pcu/pcu_io.c	/^  bool write;$/;"	m	struct:pcu_file	file:
write	phasta/phConstraint.cc	/^  virtual void write(int* iBC, double* BC)$/;"	f	struct:ph::LineConstraint
write	phasta/phConstraint.cc	/^  virtual void write(int* iBC, double* BC)$/;"	f	struct:ph::LineConstraintElas
write	phasta/phConstraint.cc	/^  virtual void write(int* iBC, double* BC)$/;"	f	struct:ph::PlaneConstraint
write	phasta/phConstraint.cc	/^  virtual void write(int* iBC, double* BC)$/;"	f	struct:ph::PlaneConstraintElas
write	phasta/phConstraint.cc	/^  virtual void write(int* iBC, double* BC)$/;"	f	struct:ph::PointConstraint
write	phasta/phConstraint.cc	/^  virtual void write(int* iBC, double* BC)$/;"	f	struct:ph::PointConstraintElas
write	stk/apfSTK.cc	/^    virtual void write($/;"	f	class:apf::NodalBridge
write	stk/apfSTK.cc	/^    virtual void write($/;"	f	class:apf::QPBridge
writeASCIIVtkFiles	apf/apfVtk.cc	/^void writeASCIIVtkFiles($/;"	f	namespace:apf
writeASCIIVtkFiles	apf/apfVtk.cc	/^void writeASCIIVtkFiles(const char* prefix, Mesh* m)$/;"	f	namespace:apf
writeAuxiliaryFiles	phasta/ph.cc	/^void writeAuxiliaryFiles(std::string path, int timestep_or_dat)$/;"	f	namespace:ph
writeBlocks	phasta/phGeomBC.cc	/^void writeBlocks(FILE* f, Output& o)$/;"	f	namespace:ph
writeBytes	phasta/phiotimer.cc	/^  size_t writeBytes[NUM_PHASTAIO_MODES];$/;"	m	struct:phastaio_stats	file:
writeCellData	apf/apfVtk.cc	/^static void writeCellData(std::ostream& file,$/;"	f	namespace:apf
writeCellParts	apf/apfVtk.cc	/^static void writeCellParts(std::ostream& file,$/;"	f	namespace:apf
writeCells	apf/apfVtk.cc	/^static void writeCells(std::ostream& file,$/;"	f	namespace:apf
writeCells	crv/crvVtk.cc	/^static void writeCells(std::ostream& file,$/;"	f	namespace:crv
writeConnectivity	apf/apfVtk.cc	/^static void writeConnectivity(std::ostream& file,$/;"	f	namespace:apf
writeConnectivity	crv/crvVtk.cc	/^static void writeConnectivity(std::ostream& file, int type, int c, int n)$/;"	f	namespace:crv
writeControlPointVtuFiles	crv/crvVtk.cc	/^void writeControlPointVtuFiles(apf::Mesh* m, const char* prefix)$/;"	f	namespace:crv
writeCre	test/capStoneAnisoAdapt.cc	/^void writeCre(CapstoneModule& cs, const std::string& vtkFileName)$/;"	f
writeCre	test/capStoneAnisoAdaptWing.cc	/^void writeCre(CapstoneModule& cs, const std::string& vtkFileName)$/;"	f
writeCre	test/capStoneAttachSolution.cc	/^void writeCre(CapstoneModule& cs, const std::string& fileName)$/;"	f
writeCre	test/capStoneIsoAdaptB737.cc	/^void writeCre(CapstoneModule& cs, const std::string& vtkFileName)$/;"	f
writeCurvedVtuFiles	crv/crvVtk.cc	/^void writeCurvedVtuFiles(apf::Mesh* m, int type, int n, const char* prefix)$/;"	f	namespace:crv
writeCurvedWireFrame	crv/crvVtk.cc	/^void writeCurvedWireFrame(apf::Mesh* m, int n, const char* prefix)$/;"	f	namespace:crv
writeDataHeader	apf/apfVtk.cc	/^static void writeDataHeader(std::ostream& file,$/;"	f	namespace:apf
writeDataHeader	crv/crvVtk.cc	/^static void writeDataHeader(std::ostream& file, const char* name,$/;"	f	namespace:crv
writeDebugFiles	phasta/phInput.h	/^    int writeDebugFiles;$/;"	m	class:ph::Input
writeDoubles	phasta/phGeomBC.cc	/^static void writeDoubles(FILE* f, const char* name, double* d, int n)$/;"	f	namespace:ph
writeEdgeConnectivity	crv/crvVtk.cc	/^static void writeEdgeConnectivity(std::ostream& file, int c, int n)$/;"	f	namespace:crv
writeEdgeJacobianDet	crv/crvVtk.cc	/^static void writeEdgeJacobianDet(std::ostream& file, apf::Mesh* m, int n)$/;"	f	namespace:crv
writeEdgeNodalField	crv/crvVtk.cc	/^static void writeEdgeNodalField(std::ostream& file, int n, apf::Field* f)$/;"	f	namespace:crv
writeEdges	phasta/phGeomBC.cc	/^static void writeEdges(Output& o, FILE* f)$/;"	f	namespace:ph
writeElementGraph	phasta/phGeomBC.cc	/^static void writeElementGraph(Output& o, FILE* f)$/;"	f	namespace:ph
writeEncodedArray	apf/apfVtk.cc	/^static void writeEncodedArray(std::ostream& file,$/;"	f	namespace:apf
writeEnd	crv/crvVtk.cc	/^static void writeEnd(std::ostream& file)$/;"	f	namespace:crv
writeExodus	stk/apfExodusOutput.cc	/^void writeExodus($/;"	f	namespace:apf
writeFineStats	parma/parma.cc	/^  void writeFineStats(apf::Mesh* m, std::string key,$/;"	f	namespace:__anon75
writeGeomBC	phasta/phGeomBC.cc	/^void writeGeomBC(Output& o, std::string path, int timestep)$/;"	f	namespace:ph
writeGeomBCFiles	phasta/phInput.h	/^    int writeGeomBCFiles;$/;"	m	class:ph::Input
writeGrowthCurves	phasta/phGeomBC.cc	/^static void writeGrowthCurves(Output& o, FILE* f)$/;"	f	namespace:ph
writeIP_PCellData	apf/apfVtk.cc	/^static void writeIP_PCellData(std::ostream& file,$/;"	f	namespace:apf
writeInt	phasta/phGeomBC.cc	/^static void writeInt(FILE* f, const char* name, int i)$/;"	f	namespace:ph
writeInterpolationPointVtuFiles	crv/crvVtk.cc	/^void writeInterpolationPointVtuFiles(apf::Mesh* m, const char* prefix)$/;"	f	namespace:crv
writeInts	phasta/phGeomBC.cc	/^static void writeInts(FILE* f, const char* name, int* i, int n)$/;"	f	namespace:ph
writeJacobianDet	crv/crvVtk.cc	/^static void writeJacobianDet(std::ostream& file, apf::Mesh* m, int type, int n)$/;"	f	namespace:crv
writeMdsMesh	test/capStoneAttachSolution.cc	/^void writeMdsMesh(apf::Mesh2* m, const char* name, const char* fieldName)$/;"	f
writeMdsPart	mds/apfMDS.cc	/^void writeMdsPart(Mesh2* in, const char* meshfile)$/;"	f	namespace:apf
writeMesh	ma/maDBG.cc	/^void writeMesh(ma::Mesh* m,$/;"	f	namespace:ma_dbg
writeMinTetJacobianDet	crv/crvVtk.cc	/^static void writeMinTetJacobianDet(std::ostream& file, apf::Mesh* m, int n)$/;"	f	namespace:crv
writeNative	apf_cap/apfCAP.cc	/^void MeshCAP::writeNative(const char* fileName)$/;"	f	class:apf::MeshCAP
writeNative	apf_sim/apfSIM.cc	/^void MeshSIM::writeNative(const char* fileName)$/;"	f	class:apf::MeshSIM
writeNative	mds/apfMDS.cc	/^    void writeNative(const char* fileName)$/;"	f	class:apf::MeshMDS
writeNodalField	apf/apfVtk.cc	/^static void writeNodalField(std::ostream& file,$/;"	f	namespace:apf
writeNodalField	crv/crvVtk.cc	/^static void writeNodalField(std::ostream& file, int type, int n,$/;"	f	namespace:crv
writeOffsets	apf/apfVtk.cc	/^static void writeOffsets(std::ostream& file,$/;"	f	namespace:apf
writeOffsets	crv/crvVtk.cc	/^static void writeOffsets(std::ostream& file, int type, int nCells)$/;"	f	namespace:crv
writeOneVtkFile	apf/apfVtk.cc	/^void writeOneVtkFile(const char* prefix, Mesh* m)$/;"	f	namespace:apf
writePCellData	apf/apfVtk.cc	/^static void writePCellData(std::ostream& file,$/;"	f	namespace:apf
writePCellParts	apf/apfVtk.cc	/^static void writePCellParts(std::ostream& file, bool isWritingBinary = false)$/;"	f	namespace:apf
writePDataArray	apf/apfVtk.cc	/^static void writePDataArray($/;"	f	namespace:apf
writePDataArray	crv/crvVtk.cc	/^static void writePDataArray($/;"	f	namespace:crv
writePPointData	apf/apfVtk.cc	/^static void writePPointData(std::ostream& file,$/;"	f	namespace:apf
writePPointData	crv/crvVtk.cc	/^static void writePPointData(std::ostream& file, apf::Mesh* m)$/;"	f	namespace:crv
writePPoints	apf/apfVtk.cc	/^static void writePPoints(std::ostream& file,$/;"	f	namespace:apf
writePSources	apf/apfVtk.cc	/^static void writePSources(std::ostream& file)$/;"	f	namespace:apf
writePoint	crv/crvVtk.cc	/^static void writePoint(std::ostream& file, apf::Vector3 & pt)$/;"	f	namespace:crv
writePointConnectivity	crv/crvVtk.cc	/^static void writePointConnectivity(std::ostream& file, int n)$/;"	f	namespace:crv
writePointData	apf/apfVtk.cc	/^static void writePointData(std::ostream& file,$/;"	f	namespace:apf
writePointData	crv/crvVtk.cc	/^static void writePointData(std::ostream& file, apf::Mesh* m,$/;"	f	namespace:crv
writePoints	apf/apfVtk.cc	/^static void writePoints(std::ostream& file,$/;"	f	namespace:apf
writePtnArray	parma/diffMC/parma_vtxPtnWriter.cc	/^  void writePtnArray(int* a, int n, std::fstream& f) {$/;"	f	namespace:__anon72
writePvtuFile	apf/apfVtk.cc	/^static void writePvtuFile(const char* prefix,$/;"	f	namespace:apf
writePvtuFile	crv/crvVtk.cc	/^static void writePvtuFile(const char* prefix, const char* suffix,$/;"	f	namespace:crv
writeRestartFiles	phasta/phInput.h	/^    int writeRestartFiles;$/;"	m	class:ph::Input
writeStart	crv/crvVtk.cc	/^static void writeStart(std::ostream& file, int nPoints, int nCells)$/;"	f	namespace:crv
writeStep	test/moving.cc	/^static void writeStep(apf::Mesh* m, int i)$/;"	f	file:
writeStkField	stk/apfSTK.cc	/^void writeStkField($/;"	f	namespace:apf
writeTable	test/measureAnisoStats.cc	/^void writeTable(const char* outFile,$/;"	f
writeTable	test/measureIsoStats.cc	/^void writeTable(const char* outFile,$/;"	f
writeTetConnectivity	crv/crvVtk.cc	/^static void writeTetConnectivity(std::ostream& file, int c, int n)$/;"	f	namespace:crv
writeTetJacobianDet	crv/crvVtk.cc	/^static void writeTetJacobianDet(std::ostream& file, apf::Mesh* m, int n)$/;"	f	namespace:crv
writeTetNodalField	crv/crvVtk.cc	/^static void writeTetNodalField(std::ostream& file, int n, apf::Field* f)$/;"	f	namespace:crv
writeTime	phasta/phiotimer.cc	/^  size_t writeTime[NUM_PHASTAIO_MODES];$/;"	m	struct:phastaio_stats	file:
writeTriJacobianDet	crv/crvVtk.cc	/^static void writeTriJacobianDet(std::ostream& file, apf::Mesh* m, int n)$/;"	f	namespace:crv
writeTriNodalField	crv/crvVtk.cc	/^static void writeTriNodalField(std::ostream& file, int n, apf::Field* f)$/;"	f	namespace:crv
writeTriangleConnectivity	crv/crvVtk.cc	/^static void writeTriangleConnectivity(std::ostream& file, int c, int n)$/;"	f	namespace:crv
writeTypes	apf/apfVtk.cc	/^static void writeTypes(std::ostream& file,$/;"	f	namespace:apf
writeTypes	crv/crvVtk.cc	/^static void writeTypes(std::ostream& file, int type, int nCells)$/;"	f	namespace:crv
writeUnknown	phasta/phstream.cc	/^void writeUnknown(const char* fname) {$/;"	f
writeVtkFiles	apf/apfVtk.cc	/^void writeVtkFiles($/;"	f	namespace:apf
writeVtkFiles	apf/apfVtk.cc	/^void writeVtkFiles(const char* prefix, Mesh* m, int cellDim)$/;"	f	namespace:apf
writeVtkFilesRunner	apf/apfVtk.cc	/^void writeVtkFilesRunner(const char* prefix,$/;"	f	namespace:apf
writeVtuFile	apf/apfVtk.cc	/^static void writeVtuFile(const char* prefix,$/;"	f	namespace:apf
writeVtxPtn	parma/diffMC/parma_vtxPtnWriter.cc	/^  void writeVtxPtn(apf::Mesh* m, const char* name) {$/;"	f	namespace:__anon72
writeWeightedEntStats	parma/parma.cc	/^  void writeWeightedEntStats(apf::Mesh* m, apf::MeshTag* w, std::string key) {$/;"	f	namespace:__anon75
write_class	mds/mds_smb.c	/^static void write_class(struct pcu_file* f, struct mds_apf* m)$/;"	f	file:
write_conn	mds/mds_smb.c	/^static void write_conn(struct pcu_file* f, struct mds_apf* m)$/;"	f	file:
write_coords	mds/mds_smb.c	/^static void write_coords(struct pcu_file* f, struct mds_apf* m)$/;"	f	file:
write_dbl_tag	mds/mds_smb.c	/^static void write_dbl_tag(struct pcu_file* f, struct mds_apf* m,$/;"	f	file:
write_header	mds/mds_smb.c	/^static void write_header(struct pcu_file* f, unsigned dim,$/;"	f	file:
write_int_tag	mds/mds_smb.c	/^static void write_int_tag(struct pcu_file* f, struct mds_apf* m,$/;"	f	file:
write_links	mds/mds_smb.c	/^static void write_links(struct pcu_file* f, struct mds_links* l)$/;"	f	file:
write_magic_number	phasta/phIO.c	/^static void write_magic_number(FILE* f)$/;"	f	file:
write_matches	mds/mds_smb.c	/^static void write_matches(struct pcu_file* f, struct mds_apf* m,$/;"	f	file:
write_output	test/mixedNumbering.cc	/^static void write_output(apf::Mesh* m, const char* out) {$/;"	f	file:
write_remotes	mds/mds_smb.c	/^static void write_remotes(struct pcu_file* f, struct mds_apf* m,$/;"	f	file:
write_smb	mds/mds_smb.c	/^static void write_smb(struct mds_apf* m, const char* filename,$/;"	f	file:
write_tag_header	mds/mds_smb.c	/^static void write_tag_header(struct pcu_file* f, struct mds_tag* t)$/;"	f	file:
write_tags	mds/mds_smb.c	/^static void write_tags(struct pcu_file* f, struct mds_apf* m)$/;"	f	file:
write_type_matches	mds/mds_smb.c	/^static void write_type_matches(struct pcu_file* f, struct mds_apf* m, int t,$/;"	f	file:
writes	phasta/phiotimer.cc	/^  size_t writes[NUM_PHASTAIO_MODES];$/;"	m	struct:phastaio_stats	file:
wtag	parma/diffMC/parma_ghostMPASWeights.cc	/^      apf::MeshTag* wtag;$/;"	m	class:parma::GhostElementFinder	file:
wtag	parma/diffMC/parma_ghostWeights.cc	/^      apf::MeshTag* wtag;$/;"	m	class:parma::ElmGhostFinder	file:
wtag	parma/diffMC/parma_ghostWeights.cc	/^      apf::MeshTag* wtag;$/;"	m	class:parma::VtxGhostFinder	file:
wtag	parma/diffMC/parma_selector.h	/^      apf::MeshTag* wtag;$/;"	m	class:parma::Selector
wx	test/box.cc	/^double wx = 0.0;$/;"	m	namespace:__anon8	file:
wy	test/box.cc	/^double wy = 0.0;$/;"	m	namespace:__anon8	file:
wz	test/box.cc	/^double wz = 0.0;$/;"	m	namespace:__anon8	file:
x	apf/apfFieldOf.cc	/^    FieldOf<T>* x;$/;"	m	class:apf::Axpy	file:
x	apf/apfVector.h	/^    double x() const {return (*this)[0];}$/;"	f	class:apf::Vector3
x	apf/apfVector.h	/^    double& x() {return (*this)[0];}$/;"	f	class:apf::Vector3
x	mds/apfBox.h	/^  int x, y, z;$/;"	m	struct:apf::Indices
x	mth/mthVector.h	/^    T const& x() const {return (*this)[0];}$/;"	f	class:mth::Vector3
x	mth/mthVector.h	/^    T& x() {return (*this[0]);}$/;"	f	class:mth::Vector3
x	pcu/pcu_aa.c	/^  pcu_aa_node* x;$/;"	m	struct:remove_vars	file:
x	test/hierarchic.cc	/^    mth::Vector<double> x;$/;"	m	class:__anon20::L2Projector	file:
x	test/poisson.cc	/^    apf::Vector3 x;$/;"	m	class:__anon17::Poisson	file:
x	test/scale.cc	/^  double x;$/;"	m	struct:__anon3::Scale	file:
x	test/verify_convert.cc	/^  apf::Field* x;$/;"	m	class:twox	file:
x_	mth/mthAD.h	/^    double x_;$/;"	m	class:mth::AD
x_data	test/qr.cc	/^static double const x_data[10] = {$/;"	v	file:
xi	crv/crvQuality.cc	/^  apf::NewArray<apf::Vector3> xi;$/;"	m	class:crv::Quality3D	file:
xi	test/poisson.cc	/^    apf::Vector3 xi;$/;"	m	class:__anon17::Poisson	file:
y	apf/apfFieldOf.cc	/^    FieldOf<T>* y;$/;"	m	class:apf::Axpy	file:
y	apf/apfVector.h	/^    double y() const {return (*this)[1];}$/;"	f	class:apf::Vector3
y	apf/apfVector.h	/^    double& y() {return (*this)[1];}$/;"	f	class:apf::Vector3
y	mds/apfBox.h	/^  int x, y, z;$/;"	m	struct:apf::Indices
y	mth/mthVector.h	/^    T const& y() const {return (*this)[1];}$/;"	f	class:mth::Vector3
y	mth/mthVector.h	/^    T& y() {return (*this[1]);}$/;"	f	class:mth::Vector3
y	test/scale.cc	/^  double y;$/;"	m	struct:__anon3::Scale	file:
z	apf/apfVector.h	/^    double z() const {return (*this)[2];}$/;"	f	class:apf::Vector3
z	apf/apfVector.h	/^    double& z() {return (*this)[2];}$/;"	f	class:apf::Vector3
z	mds/apfBox.h	/^  int x, y, z;$/;"	m	struct:apf::Indices
z	mth/mthVector.h	/^    T const& z() const {return (*this)[2];}$/;"	f	class:mth::Vector3
z	mth/mthVector.h	/^    T& z() {return (*this[2]);}$/;"	f	class:mth::Vector3
z	test/scale.cc	/^  double z;$/;"	m	struct:__anon3::Scale	file:
zb	zoltan/apfZoltanCallbacks.h	/^    ZoltanMesh* zb;$/;"	m	class:apf::ZoltanData
zero	apf/apfDynamicMatrix.h	/^    void zero()$/;"	f	class:apf::DynamicMatrix
zero	apf/apfDynamicVector.h	/^    void zero()$/;"	f	class:apf::DynamicVector
zero	apf/apfVector.h	/^    void zero()$/;"	f	class:apf::Vector
zero	mth/mthAD.h	/^    void zero()$/;"	f	class:mth::AD
zero	mth/mthMatrix.h	/^    void zero()$/;"	f	class:mth::Matrix
zero	mth/mthVector.h	/^    void zero()$/;"	f	class:mth::Vector
zeroField	apf/apfField.cc	/^void zeroField(Field* f)$/;"	f	namespace:apf
zeroOneKnapsack	parma/diffMC/zeroOneKnapsack.c	/^struct zeroOneKnapsack {$/;"	s	file:
zeroOutZCoords	ma/maExtrude.cc	/^void zeroOutZCoords(Mesh* m) {$/;"	f	namespace:ma::__anon28
zoks	parma/diffMC/zeroOneKnapsack.c	/^typedef struct zeroOneKnapsack* zoks;$/;"	t	typeref:struct:zeroOneKnapsack	file:
zoltanBalance	phasta/phPartition.cc	/^void zoltanBalance(apf::Mesh2* m, Input& in, int method)$/;"	f	namespace:ph
zoltanCountEdges	zoltan/apfZoltanCallbacks.cc	/^int zoltanCountEdges(void* data, int, int,$/;"	f	namespace:apf
zoltanCountNodes	zoltan/apfZoltanCallbacks.cc	/^int zoltanCountNodes(void* data, int* ierr)$/;"	f	namespace:apf
zoltanGetEdges	zoltan/apfZoltanCallbacks.cc	/^void zoltanGetEdges(void* data, int ngid, int,$/;"	f	namespace:apf
zoltanGetNodes	zoltan/apfZoltanCallbacks.cc	/^void zoltanGetNodes(void* data, int ngid, int nlid,$/;"	f	namespace:apf
ztn	zoltan/apfZoltanCallbacks.h	/^    Zoltan_Struct* ztn;$/;"	m	class:apf::ZoltanData
~Adapt	ma/maAdapt.cc	/^Adapt::~Adapt()$/;"	f	class:ma::Adapt
~Adapter	dsp/dspAdapters.cc	/^Adapter::~Adapter()$/;"	f	class:dsp::Adapter
~AnisoSizeField	ma/maSize.cc	/^  ~AnisoSizeField()$/;"	f	struct:ma::AnisoSizeField
~AnisotropicFunction	ma/maSize.cc	/^AnisotropicFunction::~AnisotropicFunction()$/;"	f	class:ma::AnisotropicFunction
~AnisotropicX	test/refine2x.cc	/^    ~AnisotropicX() {$/;"	f	class:AnisotropicX
~Array	can/canArray.h	/^    ~Array() {delete [] elems;}$/;"	f	class:can::Array
~Array	can/canArray.h	/^    ~Array() {}$/;"	f	class:can::Array
~ArrayDataOf	apf/apfArrayData.cc	/^    virtual ~ArrayDataOf()$/;"	f	class:apf::ArrayDataOf
~BC	phasta/phBC.h	/^  virtual ~BC() {}$/;"	f	struct:ph::BC
~BSpline	test/fusion3.cc	/^  ~BSpline () {};$/;"	f	class:BSpline
~BalOrStall	parma/diffMC/parma_stop.h	/^      ~BalOrStall() {}$/;"	f	class:parma::BalOrStall
~Balancer	apf/apfPartition.h	/^    virtual ~Balancer() {}$/;"	f	class:apf::Balancer
~Balancer	parma/diffMC/parma_balancer.cc	/^  Balancer::~Balancer() {$/;"	f	class:parma::Balancer
~BaseTopLinker	ma/maLayerSnap.cc	/^  ~BaseTopLinker()$/;"	f	struct:ma::BaseTopLinker
~BdryVtxItr	parma/diffMC/parma_bdryVtx.h	/^      virtual ~BdryVtxItr() {}$/;"	f	class:parma::BdryVtxItr
~BezierHandler	crv/crvShapeHandler.cc	/^    ~BezierHandler()$/;"	f	class:crv::BezierHandler
~BezierTransfer	crv/crvShapeHandler.cc	/^    ~BezierTransfer()$/;"	f	class:crv::BezierTransfer
~Bodies	parma/rib/parma_rib.cc	/^Bodies::~Bodies()$/;"	f	class:parma::Bodies
~CentroidSelector	parma/diffMC/parma_centroidSelector.cc	/^      ~CentroidSelector() {}$/;"	f	class:parma::CentroidSelector	file:
~Centroids	parma/diffMC/parma_centroids.h	/^      ~Centroids() {}$/;"	f	class:parma::Centroids
~CircBuffer	parma/diffMC/parma_monitor.cc	/^  CircBuffer::~CircBuffer() { free(q); }$/;"	f	class:parma::CircBuffer
~CompContains	parma/diffMC/parma_graphDist.cc	/^      ~CompContains() {}$/;"	f	class:__anon74::CompContains
~CompUpdateContains	parma/diffMC/parma_graphDist.cc	/^      ~CompUpdateContains() {}$/;"	f	class:__anon74::CompUpdateContains
~Components	parma/diffMC/parma_components.cc	/^  DCC::~Components() {$/;"	f	class:parma::DCC
~ConstantBC	phasta/phBC.cc	/^ConstantBC::~ConstantBC()$/;"	f	class:ph::ConstantBC
~Constraint	phasta/phConstraint.cc	/^  virtual ~Constraint() {}$/;"	f	struct:ph::Constraint
~Crawler	ma/maCrawler.h	/^  virtual ~Crawler() {}$/;"	f	struct:ma::Crawler
~CrvEdgeEdgeFixer	crv/crvShapeFixer.cc	/^CrvEdgeEdgeFixer::~CrvEdgeEdgeFixer()$/;"	f	class:crv::CrvEdgeEdgeFixer
~CrvFaceVertFixer	crv/crvShapeFixer.cc	/^CrvFaceVertFixer::~CrvFaceVertFixer()$/;"	f	class:crv::CrvFaceVertFixer
~CrvLargeAngleTetFixer	crv/crvShapeFixer.cc	/^CrvLargeAngleTetFixer::~CrvLargeAngleTetFixer()$/;"	f	class:crv::CrvLargeAngleTetFixer
~CrvLargeAngleTriFixer	crv/crvShapeFixer.cc	/^CrvLargeAngleTriFixer::~CrvLargeAngleTriFixer()$/;"	f	class:crv::CrvLargeAngleTriFixer
~CrvShortEdgeFixer	crv/crvShapeFixer.cc	/^CrvShortEdgeFixer::~CrvShortEdgeFixer()$/;"	f	class:crv::CrvShortEdgeFixer
~DeleteCallback	ma/maAdapt.cc	/^DeleteCallback::~DeleteCallback()$/;"	f	class:ma::DeleteCallback
~DijkstraContains	parma/diffMC/parma_dijkstra.h	/^      virtual ~DijkstraContains() {}$/;"	f	class:parma::DijkstraContains
~DistItr	parma/diffMC/parma_bdryVtx.cc	/^      ~DistItr() $/;"	f	class:__anon54::DistItr
~Distance	parma/diffMC/parma_centroidSelector.cc	/^      ~Distance() {}$/;"	f	class:__anon49::Distance
~DistanceQueue	parma/diffMC/parma_centroidSelector.cc	/^      ~DistanceQueue() {}$/;"	f	class:__anon49::DistanceQueue
~DistanceQueue	parma/diffMC/parma_distQ.h	/^    ~DistanceQueue()$/;"	f	class:parma::DistanceQueue
~Distribution	pumi/pumi_mesh.cc	/^Distribution::~Distribution()$/;"	f	class:Distribution
~EdgeEdgeFixer	ma/maShape.cc	/^    ~EdgeEdgeFixer()$/;"	f	class:ma::EdgeEdgeFixer
~EdgeIteratorSIM	apf_sim/apfSIM.cc	/^    virtual ~EdgeIteratorSIM()$/;"	f	class:apf::EdgeIteratorSIM
~EdgeReshaper	crv/crvShape.cc	/^  virtual ~EdgeReshaper()$/;"	f	class:crv::EdgeReshaper
~EdgeSwap	ma/maEdgeSwap.h	/^    virtual ~EdgeSwap() {};$/;"	f	class:ma::EdgeSwap
~EdgeSwap2D	ma/maEdgeSwap.cc	/^    virtual ~EdgeSwap2D() {}$/;"	f	class:ma::EdgeSwap2D
~EdgeSwap3D	ma/maEdgeSwap.cc	/^    virtual ~EdgeSwap3D() {}$/;"	f	class:ma::EdgeSwap3D
~EdgeSwapper	crv/crvShape.cc	/^  virtual ~EdgeSwapper()$/;"	f	class:crv::EdgeSwapper
~Element	apf/apfElement.cc	/^Element::~Element()$/;"	f	class:apf::Element
~ElementOf	apf/apfElementOf.h	/^    virtual ~ElementOf() {}$/;"	f	class:apf::ElementOf
~EntityIntegration	apf/apfIntegrate.h	/^    virtual ~EntityIntegration() {}$/;"	f	class:apf::EntityIntegration
~EntityShape	apf/apfShape.cc	/^EntityShape::~EntityShape()$/;"	f	class:apf::EntityShape
~FaceIteratorSIM	apf_sim/apfSIM.cc	/^    virtual ~FaceIteratorSIM()$/;"	f	class:apf::FaceIteratorSIM
~FaceVertFixer	ma/maShape.cc	/^    ~FaceVertFixer()$/;"	f	class:ma::FaceVertFixer
~FieldBCs	phasta/phBC.cc	/^FieldBCs::~FieldBCs()$/;"	f	class:ph::FieldBCs
~FieldBase	apf/apfField.cc	/^FieldBase::~FieldBase()$/;"	f	class:apf::FieldBase
~FieldData	apf/apfFieldData.cc	/^FieldData::~FieldData()$/;"	f	class:apf::FieldData
~FieldOf	apf/apfFieldOf.h	/^    virtual ~FieldOf() {}$/;"	f	class:apf::FieldOf
~FieldReader	ma/maSize.cc	/^    virtual ~FieldReader() {}$/;"	f	class:ma::FieldReader
~FieldShape	apf/apfShape.cc	/^FieldShape::~FieldShape()$/;"	f	class:apf::FieldShape
~FixBySwap	ma/maShape.cc	/^    ~FixBySwap()$/;"	f	class:ma::FixBySwap
~Function	apf/apf.cc	/^Function::~Function()$/;"	f	class:apf::Function
~GenIterator	pumi/GenIterator.h	/^    ~GenIterator() {}$/;"	f	class:GenIterator
~GhostMPASWeights	parma/diffMC/parma_ghostMPASWeights.cc	/^      ~GhostMPASWeights() {}$/;"	f	class:parma::GhostMPASWeights
~GhostWeights	parma/diffMC/parma_ghostWeights.cc	/^      ~GhostWeights() {$/;"	f	class:parma::GhostWeights
~Ghosting	pumi/pumi_ghost.cc	/^Ghosting::~Ghosting()$/;"	f	class:Ghosting
~Input	ma/maInput.cc	/^Input::~Input()$/;"	f	class:ma::Input
~Integration	apf/apfIntegrate.h	/^    virtual ~Integration() {}$/;"	f	class:apf::Integration
~Integrator	apf/apfIntegrate.cc	/^Integrator::~Integrator()$/;"	f	class:apf::Integrator
~InterpolatingCurver	crv/crv.h	/^    virtual ~InterpolatingCurver() {};$/;"	f	class:crv::InterpolatingCurver
~IsBadCrvQuality	crv/crvShape.cc	/^  ~IsBadCrvQuality()$/;"	f	struct:crv::IsBadCrvQuality
~IsotropicFunction	ma/maSize.cc	/^IsotropicFunction::~IsotropicFunction()$/;"	f	class:ma::IsotropicFunction
~IteratorSIM	apf_sim/apfSIM.cc	/^    virtual ~IteratorSIM() {}$/;"	f	class:apf::IteratorSIM
~LargeAngleTetAligner	ma/maShape.cc	/^    virtual ~LargeAngleTetAligner()$/;"	f	class:ma::LargeAngleTetAligner
~LargeAngleTetFixer	ma/maShape.cc	/^    virtual ~LargeAngleTetFixer()$/;"	f	class:ma::LargeAngleTetFixer
~LargeAngleTriFixer	ma/maShape.cc	/^    virtual ~LargeAngleTriFixer()$/;"	f	class:ma::LargeAngleTriFixer
~Less	parma/diffMC/parma_stop.h	/^      ~Less() {}$/;"	f	class:parma::Less
~LineConstraint	phasta/phConstraint.cc	/^  ~LineConstraint()$/;"	f	struct:ph::LineConstraint
~LineConstraintElas	phasta/phConstraint.cc	/^  ~LineConstraintElas()$/;"	f	struct:ph::LineConstraintElas
~LogAnisoSizeField	ma/maSize.cc	/^  ~LogAnisoSizeField()$/;"	f	struct:ma::LogAnisoSizeField
~MatchedCollapse	ma/maMatchedCollapse.cc	/^MatchedCollapse::~MatchedCollapse()$/;"	f	class:ma::MatchedCollapse
~MatchedSnapper	ma/maMatchedSnapper.cc	/^MatchedSnapper::~MatchedSnapper()$/;"	f	class:ma::MatchedSnapper
~MatrixElement	apf/apfMatrixField.cc	/^MatrixElement::~MatrixElement()$/;"	f	class:apf::MatrixElement
~MatrixField	apf/apfMatrixField.h	/^    virtual ~MatrixField() {}$/;"	f	class:apf::MatrixField
~Mesh	apf/apfMesh.cc	/^Mesh::~Mesh()$/;"	f	class:apf::Mesh
~MeshCAP	apf_cap/apfCAP.cc	/^MeshCAP::~MeshCAP()$/;"	f	class:apf::MeshCAP
~MeshCurver	crv/crv.h	/^    virtual ~MeshCurver() {};$/;"	f	class:crv::MeshCurver
~MeshMDS	mds/apfMDS.cc	/^    ~MeshMDS()$/;"	f	class:apf::MeshMDS
~MeshSIM	apf_sim/apfSIM.cc	/^MeshSIM::~MeshSIM()$/;"	f	class:apf::MeshSIM
~Migration	apf/apfMesh.cc	/^Migration::~Migration()$/;"	f	class:apf::Migration
~NewArray	can/canNewArray.h	/^    ~NewArray() {}$/;"	f	class:can::NewArray
~NodalBridge	stk/apfSTK.cc	/^    virtual ~NodalBridge() {}$/;"	f	class:apf::NodalBridge
~Operator	ma/maOperator.cc	/^Operator::~Operator() {}$/;"	f	class:ma::Operator
~Output	phasta/phOutput.cc	/^Output::~Output()$/;"	f	class:ph::Output
~PackedField	apf/apfPackedField.h	/^    virtual ~PackedField() {}$/;"	f	class:apf::PackedField
~PhastaSharing	phasta/phLinks.cc	/^  ~PhastaSharing()$/;"	f	struct:ph::PhastaSharing
~Poisson	test/poisson.cc	/^    ~Poisson() {$/;"	f	class:__anon17::Poisson
~QPBridge	stk/apfSTK.cc	/^    virtual ~QPBridge() {}$/;"	f	class:apf::QPBridge
~QuadraticHandler	ma/maShapeHandler.cc	/^    ~QuadraticHandler()$/;"	f	class:ma::QuadraticHandler
~Quality	crv/crv.h	/^  virtual ~Quality() {};$/;"	f	class:crv::Quality
~Quality2D	crv/crvQuality.cc	/^  virtual ~Quality2D() {};$/;"	f	class:crv::Quality2D
~Quality3D	crv/crvQuality.cc	/^  virtual ~Quality3D() {};$/;"	f	class:crv::Quality3D
~QualityImprover2D	ma/maShape.cc	/^    virtual ~QualityImprover2D()$/;"	f	class:ma::QualityImprover2D
~Refine	ma/maRefine.cc	/^Refine::~Refine()$/;"	f	class:ma::Refine
~RegionIteratorSIM	apf_sim/apfSIM.cc	/^    virtual ~RegionIteratorSIM()$/;"	f	class:apf::RegionIteratorSIM
~RibSplitter	parma/rib/parma_mesh_rib.cc	/^    virtual ~RibSplitter() {}$/;"	f	class:parma::RibSplitter
~SIMDataOf	apf_sim/apfSIMDataOf.h	/^  ~SIMDataOf()$/;"	f	class:apf::SIMDataOf
~ScalarElement	apf/apfScalarElement.h	/^    virtual ~ScalarElement() {}$/;"	f	class:apf::ScalarElement
~ScalarField	apf/apfScalarField.h	/^    virtual ~ScalarField() {}$/;"	f	class:apf::ScalarField
~Selector	parma/diffMC/parma_selector.h	/^      virtual ~Selector() {}$/;"	f	class:parma::Selector
~Sharing	apf/apfMesh.h	/^  virtual ~Sharing() {}$/;"	f	struct:apf::Sharing
~ShortEdgeFixer	ma/maShape.cc	/^    virtual ~ShortEdgeFixer()$/;"	f	class:ma::ShortEdgeFixer
~Sides	parma/diffMC/parma_sides.h	/^      virtual ~Sides() {}$/;"	f	class:parma::Sides
~SizeField	ma/maSize.cc	/^SizeField::~SizeField()$/;"	f	class:ma::SizeField
~Smoother	dsp/dspSmoothers.cc	/^Smoother::~Smoother()$/;"	f	class:dsp::Smoother
~SolutionTransfer	ma/maSolutionTransfer.cc	/^SolutionTransfer::~SolutionTransfer()$/;"	f	class:ma::SolutionTransfer
~SolutionTransfers	ma/maSolutionTransfer.cc	/^SolutionTransfers::~SolutionTransfers()$/;"	f	class:ma::SolutionTransfers
~Splitter	apf/apfPartition.h	/^    virtual ~Splitter() {}$/;"	f	class:apf::Splitter
~Stepper	parma/diffMC/parma_step.cc	/^  Stepper::~Stepper() {$/;"	f	class:parma::Stepper
~StkBridge	stk/apfSTK.cc	/^    virtual ~StkBridge() {}$/;"	f	class:apf::StkBridge
~StkModels	stk/apfSTK.cc	/^StkModels::~StkModels()$/;"	f	class:apf::StkModels
~Stop	parma/diffMC/parma_stop.h	/^      virtual ~Stop() {}$/;"	f	class:parma::Stop
~TagCAP	apf_cap/apfCAP.cc	/^    virtual ~TagCAP()$/;"	f	class:apf::TagCAP
~TagData	apf/apfTagData.cc	/^TagData::~TagData()$/;"	f	class:apf::TagData
~TagHandle	pumi/GenTag.cc	/^TagHandle::~TagHandle()$/;"	f	class:TagHandle
~TagSIM	apf_sim/apfSIM.cc	/^    virtual ~TagSIM()$/;"	f	class:apf::TagSIM
~Taggable	pumi/GenTag.cc	/^Taggable::~Taggable()$/;"	f	class:Taggable
~Targets	parma/diffMC/parma_targets.h	/^      virtual ~Targets() {}$/;"	f	class:parma::Targets
~VectorElement	apf/apfVectorElement.h	/^    virtual ~VectorElement() {}$/;"	f	class:apf::VectorElement
~VectorField	apf/apfVectorField.h	/^    virtual ~VectorField() {}$/;"	f	class:apf::VectorField
~VertexIteratorSIM	apf_sim/apfSIM.cc	/^    virtual ~VertexIteratorSIM()$/;"	f	class:apf::VertexIteratorSIM
~VtxSelector	parma/diffMC/parma_vtxSelector.cc	/^  VtxSelector::~VtxSelector() { }$/;"	f	class:parma::VtxSelector
~Weights	parma/diffMC/parma_weights.h	/^      virtual ~Weights() {}$/;"	f	class:parma::Weights
~ZoltanBalancer	zoltan/apfZoltan.cc	/^    virtual ~ZoltanBalancer() {}$/;"	f	class:apf::ZoltanBalancer
~ZoltanData	zoltan/apfZoltanCallbacks.cc	/^ZoltanData::~ZoltanData()$/;"	f	class:apf::ZoltanData
~ZoltanMesh	zoltan/apfZoltanMesh.cc	/^ZoltanMesh::~ZoltanMesh()$/;"	f	class:apf::ZoltanMesh
~ZoltanSplitter	zoltan/apfZoltan.cc	/^    virtual ~ZoltanSplitter() {}$/;"	f	class:apf::ZoltanSplitter
~dcComponents	parma/diffMC/parma_components.cc	/^  dcComponents::~dcComponents() { delete c; delete bItr; }$/;"	f	class:parma::dcComponents
~dcPart	parma/diffMC/parma_dcpart.cc	/^dcPart::~dcPart() {$/;"	f	class:dcPart
~dcPartFixer	parma/diffMC/parma_dcpartFixer.cc	/^dcPartFixer::~dcPartFixer() {$/;"	f	class:dcPartFixer
~gEntity	pumi/pumi_gentity.cc	/^gEntity::~gEntity() {}$/;"	f	class:gEntity
~gModel	pumi/pumi_geom.cc	/^gModel::~gModel()$/;"	f	class:gModel
~mPartEntityContainer	pumi/mPartEntityContainer.cc	/^mPartEntityContainer::~mPartEntityContainer()$/;"	f	class:mPartEntityContainer
~ptnstats	mds/mdsUgrid.cc	/^      ~ptnstats() {$/;"	f	class:__anon101::ptnstats
~pumi	pumi/pumi_mesh.cc	/^pumi::~pumi()$/;"	f	class:pumi
~testOwnership	test/pumi.cc	/^  ~testOwnership()$/;"	f	struct:testOwnership
